/* Generated by Cython 0.24 */

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#ifndef Py_PYTHON_H
    #error Python headers needed to compile C extensions, please install development version of Python.
#elif PY_VERSION_HEX < 0x02060000 || (0x03000000 <= PY_VERSION_HEX && PY_VERSION_HEX < 0x03020000)
    #error Cython requires Python 2.6+ or Python 3.2+.
#else
#define CYTHON_ABI "0_24"
#include <stddef.h>
#ifndef offsetof
  #define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
#endif
#if !defined(WIN32) && !defined(MS_WINDOWS)
  #ifndef __stdcall
    #define __stdcall
  #endif
  #ifndef __cdecl
    #define __cdecl
  #endif
  #ifndef __fastcall
    #define __fastcall
  #endif
#endif
#ifndef DL_IMPORT
  #define DL_IMPORT(t) t
#endif
#ifndef DL_EXPORT
  #define DL_EXPORT(t) t
#endif
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#ifndef Py_HUGE_VAL
  #define Py_HUGE_VAL HUGE_VAL
#endif
#ifdef PYPY_VERSION
  #define CYTHON_COMPILING_IN_PYPY 1
  #define CYTHON_COMPILING_IN_CPYTHON 0
#else
  #define CYTHON_COMPILING_IN_PYPY 0
  #define CYTHON_COMPILING_IN_CPYTHON 1
#endif
#if !defined(CYTHON_USE_PYLONG_INTERNALS) && CYTHON_COMPILING_IN_CPYTHON && PY_VERSION_HEX >= 0x02070000
  #define CYTHON_USE_PYLONG_INTERNALS 1
#endif
#if CYTHON_USE_PYLONG_INTERNALS
  #include "longintrepr.h"
  #undef SHIFT
  #undef BASE
  #undef MASK
#endif
#if CYTHON_COMPILING_IN_PYPY && PY_VERSION_HEX < 0x02070600 && !defined(Py_OptimizeFlag)
  #define Py_OptimizeFlag 0
#endif
#define __PYX_BUILD_PY_SSIZE_T "n"
#define CYTHON_FORMAT_SSIZE_T "z"
#if PY_MAJOR_VERSION < 3
  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a+k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyClass_Type
#else
  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
  #define __Pyx_PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)\
          PyCode_New(a, k, l, s, f, code, c, n, v, fv, cell, fn, name, fline, lnos)
  #define __Pyx_DefaultClassType PyType_Type
#endif
#ifndef Py_TPFLAGS_CHECKTYPES
  #define Py_TPFLAGS_CHECKTYPES 0
#endif
#ifndef Py_TPFLAGS_HAVE_INDEX
  #define Py_TPFLAGS_HAVE_INDEX 0
#endif
#ifndef Py_TPFLAGS_HAVE_NEWBUFFER
  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
#endif
#ifndef Py_TPFLAGS_HAVE_FINALIZE
  #define Py_TPFLAGS_HAVE_FINALIZE 0
#endif
#if PY_VERSION_HEX > 0x03030000 && defined(PyUnicode_KIND)
  #define CYTHON_PEP393_ENABLED 1
  #define __Pyx_PyUnicode_READY(op)       (likely(PyUnicode_IS_READY(op)) ?\
                                              0 : _PyUnicode_Ready((PyObject *)(op)))
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_LENGTH(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) PyUnicode_READ_CHAR(u, i)
  #define __Pyx_PyUnicode_KIND(u)         PyUnicode_KIND(u)
  #define __Pyx_PyUnicode_DATA(u)         PyUnicode_DATA(u)
  #define __Pyx_PyUnicode_READ(k, d, i)   PyUnicode_READ(k, d, i)
  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != (likely(PyUnicode_IS_READY(u)) ? PyUnicode_GET_LENGTH(u) : PyUnicode_GET_SIZE(u)))
#else
  #define CYTHON_PEP393_ENABLED 0
  #define __Pyx_PyUnicode_READY(op)       (0)
  #define __Pyx_PyUnicode_GET_LENGTH(u)   PyUnicode_GET_SIZE(u)
  #define __Pyx_PyUnicode_READ_CHAR(u, i) ((Py_UCS4)(PyUnicode_AS_UNICODE(u)[i]))
  #define __Pyx_PyUnicode_KIND(u)         (sizeof(Py_UNICODE))
  #define __Pyx_PyUnicode_DATA(u)         ((void*)PyUnicode_AS_UNICODE(u))
  #define __Pyx_PyUnicode_READ(k, d, i)   ((void)(k), (Py_UCS4)(((Py_UNICODE*)d)[i]))
  #define __Pyx_PyUnicode_IS_TRUE(u)      (0 != PyUnicode_GET_SIZE(u))
#endif
#if CYTHON_COMPILING_IN_PYPY
  #define __Pyx_PyUnicode_Concat(a, b)      PyNumber_Add(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  PyNumber_Add(a, b)
#else
  #define __Pyx_PyUnicode_Concat(a, b)      PyUnicode_Concat(a, b)
  #define __Pyx_PyUnicode_ConcatSafe(a, b)  ((unlikely((a) == Py_None) || unlikely((b) == Py_None)) ?\
      PyNumber_Add(a, b) : __Pyx_PyUnicode_Concat(a, b))
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyUnicode_Contains)
  #define PyUnicode_Contains(u, s)  PySequence_Contains(u, s)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Format)
  #define PyObject_Format(obj, fmt)  PyObject_CallMethod(obj, "__format__", "O", fmt)
#endif
#if CYTHON_COMPILING_IN_PYPY && !defined(PyObject_Malloc)
  #define PyObject_Malloc(s)   PyMem_Malloc(s)
  #define PyObject_Free(p)     PyMem_Free(p)
  #define PyObject_Realloc(p)  PyMem_Realloc(p)
#endif
#define __Pyx_PyString_FormatSafe(a, b)   ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : __Pyx_PyString_Format(a, b))
#define __Pyx_PyUnicode_FormatSafe(a, b)  ((unlikely((a) == Py_None)) ? PyNumber_Remainder(a, b) : PyUnicode_Format(a, b))
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyString_Format(a, b)  PyUnicode_Format(a, b)
#else
  #define __Pyx_PyString_Format(a, b)  PyString_Format(a, b)
#endif
#if PY_MAJOR_VERSION < 3 && !defined(PyObject_ASCII)
  #define PyObject_ASCII(o)            PyObject_Repr(o)
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyStringObject               PyUnicodeObject
  #define PyString_Type                PyUnicode_Type
  #define PyString_Check               PyUnicode_Check
  #define PyString_CheckExact          PyUnicode_CheckExact
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyBaseString_Check(obj) PyUnicode_Check(obj)
  #define __Pyx_PyBaseString_CheckExact(obj) PyUnicode_CheckExact(obj)
#else
  #define __Pyx_PyBaseString_Check(obj) (PyString_Check(obj) || PyUnicode_Check(obj))
  #define __Pyx_PyBaseString_CheckExact(obj) (PyString_CheckExact(obj) || PyUnicode_CheckExact(obj))
#endif
#ifndef PySet_CheckExact
  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
#endif
#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)
#if PY_MAJOR_VERSION >= 3
  #define PyIntObject                  PyLongObject
  #define PyInt_Type                   PyLong_Type
  #define PyInt_Check(op)              PyLong_Check(op)
  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
  #define PyInt_FromString             PyLong_FromString
  #define PyInt_FromUnicode            PyLong_FromUnicode
  #define PyInt_FromLong               PyLong_FromLong
  #define PyInt_FromSize_t             PyLong_FromSize_t
  #define PyInt_FromSsize_t            PyLong_FromSsize_t
  #define PyInt_AsLong                 PyLong_AsLong
  #define PyInt_AS_LONG                PyLong_AS_LONG
  #define PyInt_AsSsize_t              PyLong_AsSsize_t
  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
  #define PyNumber_Int                 PyNumber_Long
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBoolObject                 PyLongObject
#endif
#if PY_MAJOR_VERSION >= 3 && CYTHON_COMPILING_IN_PYPY
  #ifndef PyUnicode_InternFromString
    #define PyUnicode_InternFromString(s) PyUnicode_FromString(s)
  #endif
#endif
#if PY_VERSION_HEX < 0x030200A4
  typedef long Py_hash_t;
  #define __Pyx_PyInt_FromHash_t PyInt_FromLong
  #define __Pyx_PyInt_AsHash_t   PyInt_AsLong
#else
  #define __Pyx_PyInt_FromHash_t PyInt_FromSsize_t
  #define __Pyx_PyInt_AsHash_t   PyInt_AsSsize_t
#endif
#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
#else
  #define __Pyx_PyMethod_New(func, self, klass) PyMethod_New(func, self, klass)
#endif
#if PY_VERSION_HEX >= 0x030500B1
#define __Pyx_PyAsyncMethodsStruct PyAsyncMethods
#define __Pyx_PyType_AsAsync(obj) (Py_TYPE(obj)->tp_as_async)
#elif CYTHON_COMPILING_IN_CPYTHON && PY_MAJOR_VERSION >= 3
typedef struct {
    unaryfunc am_await;
    unaryfunc am_aiter;
    unaryfunc am_anext;
} __Pyx_PyAsyncMethodsStruct;
#define __Pyx_PyType_AsAsync(obj) ((__Pyx_PyAsyncMethodsStruct*) (Py_TYPE(obj)->tp_reserved))
#else
#define __Pyx_PyType_AsAsync(obj) NULL
#endif
#ifndef CYTHON_RESTRICT
  #if defined(__GNUC__)
    #define CYTHON_RESTRICT __restrict__
  #elif defined(_MSC_VER) && _MSC_VER >= 1400
    #define CYTHON_RESTRICT __restrict
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_RESTRICT restrict
  #else
    #define CYTHON_RESTRICT
  #endif
#endif
#define __Pyx_void_to_None(void_result) ((void)(void_result), Py_INCREF(Py_None), Py_None)

#ifndef CYTHON_INLINE
  #if defined(__GNUC__)
    #define CYTHON_INLINE __inline__
  #elif defined(_MSC_VER)
    #define CYTHON_INLINE __inline
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_INLINE inline
  #else
    #define CYTHON_INLINE
  #endif
#endif

#if defined(WIN32) || defined(MS_WINDOWS)
  #define _USE_MATH_DEFINES
#endif
#include <math.h>
#ifdef NAN
#define __PYX_NAN() ((float) NAN)
#else
static CYTHON_INLINE float __PYX_NAN() {
  float value;
  memset(&value, 0xFF, sizeof(value));
  return value;
}
#endif


#define __PYX_ERR(f_index, lineno, Ln_error) \
{ \
  __pyx_filename = __pyx_f[f_index]; __pyx_lineno = lineno; __pyx_clineno = __LINE__; goto Ln_error; \
}

#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#else
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
#endif

#ifndef __PYX_EXTERN_C
  #ifdef __cplusplus
    #define __PYX_EXTERN_C extern "C"
  #else
    #define __PYX_EXTERN_C extern
  #endif
#endif

#define __PYX_HAVE__pysam__calignmentfile
#define __PYX_HAVE_API__pysam__calignmentfile
#include "stdint.h"
#include "string.h"
#include "stdlib.h"
#include "stdio.h"
#include "pythread.h"
#include "sys/types.h"
#include "zlib.h"
#include "htslib/kstring.h"
#include "htslib_util.h"
#include "htslib/hfile.h"
#include "htslib/bgzf.h"
#include "htslib/hts.h"
#include "htslib/sam.h"
#include "htslib/faidx.h"
#include "htslib/tbx.h"
#include "htslib/vcf.h"
#include "htslib/vcfutils.h"
#include "pysam_stream.h"
#include "samfile_util.h"
#include "pysam_util.h"
#ifdef _OPENMP
#include <omp.h>
#endif /* _OPENMP */

#ifdef PYREX_WITHOUT_ASSERTIONS
#define CYTHON_WITHOUT_ASSERTIONS
#endif

#ifndef CYTHON_UNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define CYTHON_UNUSED __attribute__ ((__unused__))
#   else
#     define CYTHON_UNUSED
#   endif
# elif defined(__ICC) || (defined(__INTEL_COMPILER) && !defined(_MSC_VER))
#   define CYTHON_UNUSED __attribute__ ((__unused__))
# else
#   define CYTHON_UNUSED
# endif
#endif
#ifndef CYTHON_NCP_UNUSED
# if CYTHON_COMPILING_IN_CPYTHON
#  define CYTHON_NCP_UNUSED
# else
#  define CYTHON_NCP_UNUSED CYTHON_UNUSED
# endif
#endif
typedef struct {PyObject **p; const char *s; const Py_ssize_t n; const char* encoding;
                const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry;

#define __PYX_DEFAULT_STRING_ENCODING_IS_ASCII 0
#define __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT 0
#define __PYX_DEFAULT_STRING_ENCODING ""
#define __Pyx_PyObject_FromString __Pyx_PyBytes_FromString
#define __Pyx_PyObject_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#define __Pyx_uchar_cast(c) ((unsigned char)c)
#define __Pyx_long_cast(x) ((long)x)
#define __Pyx_fits_Py_ssize_t(v, type, is_signed)  (\
    (sizeof(type) < sizeof(Py_ssize_t))  ||\
    (sizeof(type) > sizeof(Py_ssize_t) &&\
          likely(v < (type)PY_SSIZE_T_MAX ||\
                 v == (type)PY_SSIZE_T_MAX)  &&\
          (!is_signed || likely(v > (type)PY_SSIZE_T_MIN ||\
                                v == (type)PY_SSIZE_T_MIN)))  ||\
    (sizeof(type) == sizeof(Py_ssize_t) &&\
          (is_signed || likely(v < (type)PY_SSIZE_T_MAX ||\
                               v == (type)PY_SSIZE_T_MAX)))  )
#if defined (__cplusplus) && __cplusplus >= 201103L
    #include <cstdlib>
    #define __Pyx_sst_abs(value) std::abs(value)
#elif SIZEOF_INT >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) abs(value)
#elif SIZEOF_LONG >= SIZEOF_SIZE_T
    #define __Pyx_sst_abs(value) labs(value)
#elif defined (_MSC_VER) && defined (_M_X64)
    #define __Pyx_sst_abs(value) _abs64(value)
#elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define __Pyx_sst_abs(value) llabs(value)
#elif defined (__GNUC__)
    #define __Pyx_sst_abs(value) __builtin_llabs(value)
#else
    #define __Pyx_sst_abs(value) ((value<0) ? -value : value)
#endif
static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject*);
static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject*, Py_ssize_t* length);
#define __Pyx_PyByteArray_FromString(s) PyByteArray_FromStringAndSize((const char*)s, strlen((const char*)s))
#define __Pyx_PyByteArray_FromStringAndSize(s, l) PyByteArray_FromStringAndSize((const char*)s, l)
#define __Pyx_PyBytes_FromString        PyBytes_FromString
#define __Pyx_PyBytes_FromStringAndSize PyBytes_FromStringAndSize
static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char*);
#if PY_MAJOR_VERSION < 3
    #define __Pyx_PyStr_FromString        __Pyx_PyBytes_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyBytes_FromStringAndSize
#else
    #define __Pyx_PyStr_FromString        __Pyx_PyUnicode_FromString
    #define __Pyx_PyStr_FromStringAndSize __Pyx_PyUnicode_FromStringAndSize
#endif
#define __Pyx_PyObject_AsSString(s)    ((signed char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_AsUString(s)    ((unsigned char*) __Pyx_PyObject_AsString(s))
#define __Pyx_PyObject_FromCString(s)  __Pyx_PyObject_FromString((const char*)s)
#define __Pyx_PyBytes_FromCString(s)   __Pyx_PyBytes_FromString((const char*)s)
#define __Pyx_PyByteArray_FromCString(s)   __Pyx_PyByteArray_FromString((const char*)s)
#define __Pyx_PyStr_FromCString(s)     __Pyx_PyStr_FromString((const char*)s)
#define __Pyx_PyUnicode_FromCString(s) __Pyx_PyUnicode_FromString((const char*)s)
#if PY_MAJOR_VERSION < 3
static CYTHON_INLINE size_t __Pyx_Py_UNICODE_strlen(const Py_UNICODE *u)
{
    const Py_UNICODE *u_end = u;
    while (*u_end++) ;
    return (size_t)(u_end - u - 1);
}
#else
#define __Pyx_Py_UNICODE_strlen Py_UNICODE_strlen
#endif
#define __Pyx_PyUnicode_FromUnicode(u)       PyUnicode_FromUnicode(u, __Pyx_Py_UNICODE_strlen(u))
#define __Pyx_PyUnicode_FromUnicodeAndLength PyUnicode_FromUnicode
#define __Pyx_PyUnicode_AsUnicode            PyUnicode_AsUnicode
#define __Pyx_NewRef(obj) (Py_INCREF(obj), obj)
#define __Pyx_Owned_Py_None(b) __Pyx_NewRef(Py_None)
#define __Pyx_PyBool_FromLong(b) ((b) ? __Pyx_NewRef(Py_True) : __Pyx_NewRef(Py_False))
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x);
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
#if CYTHON_COMPILING_IN_CPYTHON
#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))
#else
#define __pyx_PyFloat_AsDouble(x) PyFloat_AsDouble(x)
#endif
#define __pyx_PyFloat_AsFloat(x) ((float) __pyx_PyFloat_AsDouble(x))
#if PY_MAJOR_VERSION >= 3
#define __Pyx_PyNumber_Int(x) (PyLong_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Long(x))
#else
#define __Pyx_PyNumber_Int(x) (PyInt_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Int(x))
#endif
#define __Pyx_PyNumber_Float(x) (PyFloat_CheckExact(x) ? __Pyx_NewRef(x) : PyNumber_Float(x))
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
static int __Pyx_sys_getdefaultencoding_not_ascii;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    PyObject* ascii_chars_u = NULL;
    PyObject* ascii_chars_b = NULL;
    const char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    if (strcmp(default_encoding_c, "ascii") == 0) {
        __Pyx_sys_getdefaultencoding_not_ascii = 0;
    } else {
        char ascii_chars[128];
        int c;
        for (c = 0; c < 128; c++) {
            ascii_chars[c] = c;
        }
        __Pyx_sys_getdefaultencoding_not_ascii = 1;
        ascii_chars_u = PyUnicode_DecodeASCII(ascii_chars, 128, NULL);
        if (!ascii_chars_u) goto bad;
        ascii_chars_b = PyUnicode_AsEncodedString(ascii_chars_u, default_encoding_c, NULL);
        if (!ascii_chars_b || !PyBytes_Check(ascii_chars_b) || memcmp(ascii_chars, PyBytes_AS_STRING(ascii_chars_b), 128) != 0) {
            PyErr_Format(
                PyExc_ValueError,
                "This module compiled with c_string_encoding=ascii, but default encoding '%.200s' is not a superset of ascii.",
                default_encoding_c);
            goto bad;
        }
        Py_DECREF(ascii_chars_u);
        Py_DECREF(ascii_chars_b);
    }
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    Py_XDECREF(ascii_chars_u);
    Py_XDECREF(ascii_chars_b);
    return -1;
}
#endif
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT && PY_MAJOR_VERSION >= 3
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_DecodeUTF8(c_str, size, NULL)
#else
#define __Pyx_PyUnicode_FromStringAndSize(c_str, size) PyUnicode_Decode(c_str, size, __PYX_DEFAULT_STRING_ENCODING, NULL)
#if __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT
static char* __PYX_DEFAULT_STRING_ENCODING;
static int __Pyx_init_sys_getdefaultencoding_params(void) {
    PyObject* sys;
    PyObject* default_encoding = NULL;
    char* default_encoding_c;
    sys = PyImport_ImportModule("sys");
    if (!sys) goto bad;
    default_encoding = PyObject_CallMethod(sys, (char*) (const char*) "getdefaultencoding", NULL);
    Py_DECREF(sys);
    if (!default_encoding) goto bad;
    default_encoding_c = PyBytes_AsString(default_encoding);
    if (!default_encoding_c) goto bad;
    __PYX_DEFAULT_STRING_ENCODING = (char*) malloc(strlen(default_encoding_c));
    if (!__PYX_DEFAULT_STRING_ENCODING) goto bad;
    strcpy(__PYX_DEFAULT_STRING_ENCODING, default_encoding_c);
    Py_DECREF(default_encoding);
    return 0;
bad:
    Py_XDECREF(default_encoding);
    return -1;
}
#endif
#endif


/* Test for GCC > 2.95 */
#if defined(__GNUC__)     && (__GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)))
  #define likely(x)   __builtin_expect(!!(x), 1)
  #define unlikely(x) __builtin_expect(!!(x), 0)
#else /* !__GNUC__ or GCC < 2.95 */
  #define likely(x)   (x)
  #define unlikely(x) (x)
#endif /* __GNUC__ */

static PyObject *__pyx_m;
static PyObject *__pyx_d;
static PyObject *__pyx_b;
static PyObject *__pyx_empty_tuple;
static PyObject *__pyx_empty_bytes;
static PyObject *__pyx_empty_unicode;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static const char * __pyx_cfilenm= __FILE__;
static const char *__pyx_filename;


static const char *__pyx_f[] = {
  "pysam/calignmentfile.pyx",
  "pysam/calignmentfile.pxd",
  "array.pxd",
  "type.pxd",
  "bool.pxd",
  "complex.pxd",
  "pysam/cfaidx.pxd",
  "pysam/calignedsegment.pxd",
};

/*--- Type declarations ---*/
#ifndef _ARRAYARRAY_H
struct arrayobject;
typedef struct arrayobject arrayobject;
#endif
struct __pyx_obj_5pysam_6cfaidx_FastaFile;
struct __pyx_obj_5pysam_6cfaidx_FastqProxy;
struct __pyx_obj_5pysam_6cfaidx_PersistentFastqProxy;
struct __pyx_obj_5pysam_6cfaidx_FastxFile;
struct __pyx_obj_5pysam_6cfaidx_FastqFile;
struct __pyx_obj_5pysam_6cfaidx_Fastafile;
struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment;
struct __pyx_obj_5pysam_15calignedsegment_PileupColumn;
struct __pyx_obj_5pysam_15calignedsegment_PileupRead;
struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile;
struct __pyx_obj_5pysam_14calignmentfile_PileupColumn;
struct __pyx_obj_5pysam_14calignmentfile_PileupRead;
struct __pyx_obj_5pysam_14calignmentfile_IteratorRow;
struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion;
struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead;
struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll;
struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs;
struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection;
struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn;
struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnRegion;
struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnAllRefs;
struct __pyx_obj_5pysam_14calignmentfile_IndexedReads;
struct __pyx_obj_5pysam_14calignmentfile_SNPCall;
struct __pyx_opt_args_5pysam_6cfaidx_10FastqProxy_get_quality_array;
struct __pyx_opt_args_5pysam_6cfaidx_20PersistentFastqProxy_get_quality_array;

/* "pysam/cfaidx.pxd":51
 *     cdef kseq_t * _delegate
 *     cdef cython.str tostring(self)
 *     cpdef array.array get_quality_array(self, int offset=*)             # <<<<<<<<<<<<<<
 * 
 * 
 */
struct __pyx_opt_args_5pysam_6cfaidx_10FastqProxy_get_quality_array {
  int __pyx_n;
  int offset;
};

/* "pysam/cfaidx.pxd":60
 *     cdef public str comment, quality, sequence, name
 *     cdef cython.str tostring(self)
 *     cpdef array.array get_quality_array(self, int offset=*)             # <<<<<<<<<<<<<<
 * 
 * 
 */
struct __pyx_opt_args_5pysam_6cfaidx_20PersistentFastqProxy_get_quality_array {
  int __pyx_n;
  int offset;
};
struct __pyx_opt_args_5pysam_15calignedsegment_14AlignedSegment_set_tag;
struct __pyx_opt_args_5pysam_15calignedsegment_14AlignedSegment_get_tag;

/* "pysam/calignedsegment.pxd":36
 * 
 * from pysam.calignmentfile cimport AlignmentFile
 * ctypedef AlignmentFile AlignmentFile_t             # <<<<<<<<<<<<<<
 * 
 * 
 */
typedef struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_t_5pysam_15calignedsegment_AlignmentFile_t;

/* "pysam/calignedsegment.pxd":56
 *     # add an alignment tag with value to the AlignedSegment
 *     # an existing tag of the same name will be replaced.
 *     cpdef set_tag(self, tag, value, value_type=?, replace=?)             # <<<<<<<<<<<<<<
 * 
 *     # add an alignment tag with value to the AlignedSegment
 */
struct __pyx_opt_args_5pysam_15calignedsegment_14AlignedSegment_set_tag {
  int __pyx_n;
  PyObject *value_type;
  PyObject *replace;
};

/* "pysam/calignedsegment.pxd":60
 *     # add an alignment tag with value to the AlignedSegment
 *     # an existing tag of the same name will be replaced.
 *     cpdef get_tag(self, tag, with_value_type=?)             # <<<<<<<<<<<<<<
 * 
 *     # return true if tag exists
 */
struct __pyx_opt_args_5pysam_15calignedsegment_14AlignedSegment_get_tag {
  int __pyx_n;
  PyObject *with_value_type;
};
struct __pyx_opt_args_5pysam_6cutils_parse_region;
struct __pyx_opt_args_5pysam_6cutils_qualitystring_to_array;
struct __pyx_opt_args_5pysam_6cutils_array_to_qualitystring;
struct __pyx_opt_args_5pysam_6cutils_qualities_to_qualitystring;
struct __pyx_opt_args_5pysam_6cutils_charptr_to_str;
struct __pyx_opt_args_5pysam_6cutils_charptr_to_bytes;
struct __pyx_opt_args_5pysam_6cutils_charptr_to_str_w_len;
struct __pyx_opt_args_5pysam_6cutils_force_str;
struct __pyx_opt_args_5pysam_6cutils_force_bytes;

/* "pysam/cutils.pxd":7
 * from cpython cimport array as c_array
 * 
 * cpdef parse_region(reference=*, start=*, end=*, region=*)             # <<<<<<<<<<<<<<
 * 
 * #########################################################################
 */
struct __pyx_opt_args_5pysam_6cutils_parse_region {
  int __pyx_n;
  PyObject *reference;
  PyObject *start;
  PyObject *end;
  PyObject *region;
};

/* "pysam/cutils.pxd":12
 * # Utility functions for quality string conversions
 * 
 * cpdef c_array.array qualitystring_to_array(input_str, int offset=*)             # <<<<<<<<<<<<<<
 * cpdef array_to_qualitystring(c_array.array arr, int offset=*)
 * cpdef qualities_to_qualitystring(qualities, int offset=*)
 */
struct __pyx_opt_args_5pysam_6cutils_qualitystring_to_array {
  int __pyx_n;
  int offset;
};

/* "pysam/cutils.pxd":13
 * 
 * cpdef c_array.array qualitystring_to_array(input_str, int offset=*)
 * cpdef array_to_qualitystring(c_array.array arr, int offset=*)             # <<<<<<<<<<<<<<
 * cpdef qualities_to_qualitystring(qualities, int offset=*)
 * 
 */
struct __pyx_opt_args_5pysam_6cutils_array_to_qualitystring {
  int __pyx_n;
  int offset;
};

/* "pysam/cutils.pxd":14
 * cpdef c_array.array qualitystring_to_array(input_str, int offset=*)
 * cpdef array_to_qualitystring(c_array.array arr, int offset=*)
 * cpdef qualities_to_qualitystring(qualities, int offset=*)             # <<<<<<<<<<<<<<
 * 
 * ########################################################################
 */
struct __pyx_opt_args_5pysam_6cutils_qualities_to_qualitystring {
  int __pyx_n;
  int offset;
};

/* "pysam/cutils.pxd":21
 * ## Python 3 compatibility functions
 * ########################################################################
 * cdef charptr_to_str(const char *s, encoding=*)             # <<<<<<<<<<<<<<
 * cdef bytes charptr_to_bytes(const char *s, encoding=*)
 * cdef charptr_to_str_w_len(const char* s, size_t n, encoding=*)
 */
struct __pyx_opt_args_5pysam_6cutils_charptr_to_str {
  int __pyx_n;
  PyObject *encoding;
};

/* "pysam/cutils.pxd":22
 * ########################################################################
 * cdef charptr_to_str(const char *s, encoding=*)
 * cdef bytes charptr_to_bytes(const char *s, encoding=*)             # <<<<<<<<<<<<<<
 * cdef charptr_to_str_w_len(const char* s, size_t n, encoding=*)
 * cdef force_str(object s, encoding=*)
 */
struct __pyx_opt_args_5pysam_6cutils_charptr_to_bytes {
  int __pyx_n;
  PyObject *encoding;
};

/* "pysam/cutils.pxd":23
 * cdef charptr_to_str(const char *s, encoding=*)
 * cdef bytes charptr_to_bytes(const char *s, encoding=*)
 * cdef charptr_to_str_w_len(const char* s, size_t n, encoding=*)             # <<<<<<<<<<<<<<
 * cdef force_str(object s, encoding=*)
 * cdef bytes force_bytes(object s, encoding=*)
 */
struct __pyx_opt_args_5pysam_6cutils_charptr_to_str_w_len {
  int __pyx_n;
  PyObject *encoding;
};

/* "pysam/cutils.pxd":24
 * cdef bytes charptr_to_bytes(const char *s, encoding=*)
 * cdef charptr_to_str_w_len(const char* s, size_t n, encoding=*)
 * cdef force_str(object s, encoding=*)             # <<<<<<<<<<<<<<
 * cdef bytes force_bytes(object s, encoding=*)
 * cdef bytes encode_filename(object filename)
 */
struct __pyx_opt_args_5pysam_6cutils_force_str {
  int __pyx_n;
  PyObject *encoding;
};

/* "pysam/cutils.pxd":25
 * cdef charptr_to_str_w_len(const char* s, size_t n, encoding=*)
 * cdef force_str(object s, encoding=*)
 * cdef bytes force_bytes(object s, encoding=*)             # <<<<<<<<<<<<<<
 * cdef bytes encode_filename(object filename)
 * cdef from_string_and_size(const char *s, size_t length)
 */
struct __pyx_opt_args_5pysam_6cutils_force_bytes {
  int __pyx_n;
  PyObject *encoding;
};
struct __pyx_t_5pysam_14calignmentfile___iterdata;
typedef struct __pyx_t_5pysam_14calignmentfile___iterdata __pyx_t_5pysam_14calignmentfile___iterdata;
struct __pyx_opt_args_5pysam_14calignmentfile_14IteratorColumn_setupIteratorData;

/* "pysam/calignmentfile.pxd":29
 * # Utility types
 * 
 * ctypedef struct __iterdata:             # <<<<<<<<<<<<<<
 *     htsFile * htsfile
 *     bam_hdr_t * header
 */
struct __pyx_t_5pysam_14calignmentfile___iterdata {
  htsFile *htsfile;
  bam_hdr_t *header;
  hts_itr_t *iter;
  faidx_t *fastafile;
  int tid;
  char *seq;
  int seq_len;
};

/* "pysam/calignmentfile.pxd":140
 *     cdef char * getSequence(self)
 *     cdef setMask(self, mask)
 *     cdef setupIteratorData(self,             # <<<<<<<<<<<<<<
 *                            int tid,
 *                            int start,
 */
struct __pyx_opt_args_5pysam_14calignmentfile_14IteratorColumn_setupIteratorData {
  int __pyx_n;
  int multiple_iterators;
};

/* "pysam/cfaidx.pxd":40
 *                     int * dret)
 * 
 * cdef class FastaFile:             # <<<<<<<<<<<<<<
 *     cdef bint is_remote
 *     cdef object _filename, _references, _lengths, reference2length
 */
struct __pyx_obj_5pysam_6cfaidx_FastaFile {
  PyObject_HEAD
  struct __pyx_vtabstruct_5pysam_6cfaidx_FastaFile *__pyx_vtab;
  int is_remote;
  PyObject *_filename;
  PyObject *_references;
  PyObject *_lengths;
  PyObject *reference2length;
  faidx_t *fastafile;
};


/* "pysam/cfaidx.pxd":48
 * 
 * 
 * cdef class FastqProxy:             # <<<<<<<<<<<<<<
 *     cdef kseq_t * _delegate
 *     cdef cython.str tostring(self)
 */
struct __pyx_obj_5pysam_6cfaidx_FastqProxy {
  PyObject_HEAD
  struct __pyx_vtabstruct_5pysam_6cfaidx_FastqProxy *__pyx_vtab;
  kseq_t *_delegate;
};


/* "pysam/cfaidx.pxd":54
 * 
 * 
 * cdef class PersistentFastqProxy:             # <<<<<<<<<<<<<<
 *     """
 *     Python container for pysam.cfaidx.FastqProxy with persistence.
 */
struct __pyx_obj_5pysam_6cfaidx_PersistentFastqProxy {
  PyObject_HEAD
  struct __pyx_vtabstruct_5pysam_6cfaidx_PersistentFastqProxy *__pyx_vtab;
  PyObject *comment;
  PyObject *quality;
  PyObject *sequence;
  PyObject *name;
};


/* "pysam/cfaidx.pxd":63
 * 
 * 
 * cdef class FastxFile:             # <<<<<<<<<<<<<<
 *     cdef object _filename
 *     cdef gzFile fastqfile
 */
struct __pyx_obj_5pysam_6cfaidx_FastxFile {
  PyObject_HEAD
  struct __pyx_vtabstruct_5pysam_6cfaidx_FastxFile *__pyx_vtab;
  PyObject *_filename;
  gzFile fastqfile;
  kseq_t *entry;
  int persist;
};


/* "pysam/cfaidx.pxd":74
 * 
 * # Compatibility Layer for pysam 0.8.1
 * cdef class FastqFile(FastxFile):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_5pysam_6cfaidx_FastqFile {
  struct __pyx_obj_5pysam_6cfaidx_FastxFile __pyx_base;
};


/* "pysam/cfaidx.pxd":79
 * 
 * # Compatibility Layer for pysam < 0.8
 * cdef class Fastafile(FastaFile):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_5pysam_6cfaidx_Fastafile {
  struct __pyx_obj_5pysam_6cfaidx_FastaFile __pyx_base;
};


/* "pysam/calignedsegment.pxd":40
 * 
 * # Note: need to declare all C fields and methods here
 * cdef class AlignedSegment:             # <<<<<<<<<<<<<<
 * 
 *     # object that this AlignedSegment represents
 */
struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment {
  PyObject_HEAD
  struct __pyx_vtabstruct_5pysam_15calignedsegment_AlignedSegment *__pyx_vtab;
  bam1_t *_delegate;
  struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *_alignment_file;
  PyObject *cache_query_qualities;
  PyObject *cache_query_alignment_qualities;
  PyObject *cache_query_sequence;
  PyObject *cache_query_alignment_sequence;
};


/* "pysam/calignedsegment.pxd":69
 * 
 * 
 * cdef class PileupColumn:             # <<<<<<<<<<<<<<
 *     cdef bam_pileup1_t ** plp
 *     cdef int tid
 */
struct __pyx_obj_5pysam_15calignedsegment_PileupColumn {
  PyObject_HEAD
  bam_pileup1_t **plp;
  int tid;
  int pos;
  int n_pu;
  struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *_alignment_file;
};


/* "pysam/calignedsegment.pxd":77
 * 
 * 
 * cdef class PileupRead:             # <<<<<<<<<<<<<<
 *     cdef AlignedSegment _alignment
 *     cdef int32_t  _qpos
 */
struct __pyx_obj_5pysam_15calignedsegment_PileupRead {
  PyObject_HEAD
  struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *_alignment;
  int32_t _qpos;
  int _indel;
  int _level;
  uint32_t _is_del;
  uint32_t _is_head;
  uint32_t _is_tail;
  uint32_t _is_refskip;
};


/* "pysam/calignmentfile.pxd":39
 * 
 * 
 * cdef class AlignmentFile:             # <<<<<<<<<<<<<<
 * 
 *     cdef object _filename
 */
struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile {
  PyObject_HEAD
  struct __pyx_vtabstruct_5pysam_14calignmentfile_AlignmentFile *__pyx_vtab;
  PyObject *_filename;
  htsFile *htsfile;
  hts_idx_t *index;
  bam_hdr_t *header;
  int is_bam;
  int is_cram;
  int is_stream;
  int is_remote;
  bam1_t *b;
  char *mode;
  int64_t start_offset;
};


/* "pysam/calignmentfile.pxd":72
 *     cpdef int write(self, AlignedSegment read) except -1
 * 
 * cdef class PileupColumn:             # <<<<<<<<<<<<<<
 *     cdef bam_pileup1_t ** plp
 *     cdef int tid
 */
struct __pyx_obj_5pysam_14calignmentfile_PileupColumn {
  PyObject_HEAD
  bam_pileup1_t **plp;
  int tid;
  int pos;
  int n_pu;
};


/* "pysam/calignmentfile.pxd":78
 *     cdef int n_pu
 * 
 * cdef class PileupRead:             # <<<<<<<<<<<<<<
 *     cdef AlignedSegment _alignment
 *     cdef int32_t  _qpos
 */
struct __pyx_obj_5pysam_14calignmentfile_PileupRead {
  PyObject_HEAD
  struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *_alignment;
  int32_t _qpos;
  int _indel;
  int _level;
  uint32_t _is_del;
  uint32_t _is_head;
  uint32_t _is_tail;
  uint32_t _is_refskip;
};


/* "pysam/calignmentfile.pxd":88
 *     cdef uint32_t _is_refskip
 * 
 * cdef class IteratorRow:             # <<<<<<<<<<<<<<
 *     cdef int retval
 *     cdef bam1_t * b
 */
struct __pyx_obj_5pysam_14calignmentfile_IteratorRow {
  PyObject_HEAD
  int retval;
  bam1_t *b;
  struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *samfile;
  htsFile *htsfile;
  bam_hdr_t *header;
  int owns_samfile;
};


/* "pysam/calignmentfile.pxd":96
 *     cdef int owns_samfile
 * 
 * cdef class IteratorRowRegion(IteratorRow):             # <<<<<<<<<<<<<<
 *     cdef hts_itr_t * iter
 *     cdef bam1_t * getCurrent(self)
 */
struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion {
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRow __pyx_base;
  struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorRowRegion *__pyx_vtab;
  hts_itr_t *iter;
};


/* "pysam/calignmentfile.pxd":101
 *     cdef int cnext(self)
 * 
 * cdef class IteratorRowHead(IteratorRow):             # <<<<<<<<<<<<<<
 *     cdef int max_rows
 *     cdef int current_row
 */
struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead {
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRow __pyx_base;
  struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorRowHead *__pyx_vtab;
  int max_rows;
  int current_row;
};


/* "pysam/calignmentfile.pxd":107
 *     cdef int cnext(self)
 * 
 * cdef class IteratorRowAll(IteratorRow):             # <<<<<<<<<<<<<<
 *     cdef bam1_t * getCurrent(self)
 *     cdef int cnext(self)
 */
struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll {
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRow __pyx_base;
  struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorRowAll *__pyx_vtab;
};


/* "pysam/calignmentfile.pxd":111
 *     cdef int cnext(self)
 * 
 * cdef class IteratorRowAllRefs(IteratorRow):             # <<<<<<<<<<<<<<
 *     cdef int         tid
 *     cdef IteratorRowRegion rowiter
 */
struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs {
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRow __pyx_base;
  int tid;
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *rowiter;
};


/* "pysam/calignmentfile.pxd":115
 *     cdef IteratorRowRegion rowiter
 * 
 * cdef class IteratorRowSelection(IteratorRow):             # <<<<<<<<<<<<<<
 *     cdef int current_pos
 *     cdef positions
 */
struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection {
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRow __pyx_base;
  struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorRowSelection *__pyx_vtab;
  int current_pos;
  PyObject *positions;
};


/* "pysam/calignmentfile.pxd":121
 *     cdef int cnext(self)
 * 
 * cdef class IteratorColumn:             # <<<<<<<<<<<<<<
 * 
 *     # result of the last plbuf_push
 */
struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn {
  PyObject_HEAD
  struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorColumn *__pyx_vtab;
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *iter;
  int tid;
  int pos;
  int n_plp;
  int mask;
  bam_pileup1_t *plp;
  bam_plp_t pileup_iter;
  __pyx_t_5pysam_14calignmentfile___iterdata iterdata;
  struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *samfile;
  struct __pyx_obj_5pysam_6cfaidx_Fastafile *fastafile;
  PyObject *stepper;
  int max_depth;
};


/* "pysam/calignmentfile.pxd":149
 *     cdef _free_pileup_iter(self)
 * 
 * cdef class IteratorColumnRegion(IteratorColumn):             # <<<<<<<<<<<<<<
 *     cdef int start
 *     cdef int end
 */
struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnRegion {
  struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn __pyx_base;
  int start;
  int end;
  int truncate;
};


/* "pysam/calignmentfile.pxd":154
 *     cdef int truncate
 * 
 * cdef class IteratorColumnAllRefs(IteratorColumn):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */
struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnAllRefs {
  struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn __pyx_base;
};


/* "pysam/calignmentfile.pxd":157
 *     pass
 * 
 * cdef class IndexedReads:             # <<<<<<<<<<<<<<
 *     cdef AlignmentFile samfile
 *     cdef htsFile * htsfile
 */
struct __pyx_obj_5pysam_14calignmentfile_IndexedReads {
  PyObject_HEAD
  struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *samfile;
  htsFile *htsfile;
  PyObject *index;
  int owns_samfile;
  bam_hdr_t *header;
};


/* "pysam/calignmentfile.pyx":2346
 * 
 * 
 * cdef class SNPCall:             # <<<<<<<<<<<<<<
 *     '''the results of a SNP call.'''
 *     cdef int _tid
 */
struct __pyx_obj_5pysam_14calignmentfile_SNPCall {
  PyObject_HEAD
  int _tid;
  int _pos;
  char _reference_base;
  char _genotype;
  int _consensus_quality;
  int _snp_quality;
  int _rms_mapping_quality;
  int _coverage;
};



/* "pysam/cfaidx.pxd":40
 *                     int * dret)
 * 
 * cdef class FastaFile:             # <<<<<<<<<<<<<<
 *     cdef bint is_remote
 *     cdef object _filename, _references, _lengths, reference2length
 */

struct __pyx_vtabstruct_5pysam_6cfaidx_FastaFile {
  char *(*_fetch)(struct __pyx_obj_5pysam_6cfaidx_FastaFile *, char *, int, int, int *);
};
static struct __pyx_vtabstruct_5pysam_6cfaidx_FastaFile *__pyx_vtabptr_5pysam_6cfaidx_FastaFile;


/* "pysam/cfaidx.pxd":48
 * 
 * 
 * cdef class FastqProxy:             # <<<<<<<<<<<<<<
 *     cdef kseq_t * _delegate
 *     cdef cython.str tostring(self)
 */

struct __pyx_vtabstruct_5pysam_6cfaidx_FastqProxy {
  PyObject *(*tostring)(struct __pyx_obj_5pysam_6cfaidx_FastqProxy *);
  arrayobject *(*get_quality_array)(struct __pyx_obj_5pysam_6cfaidx_FastqProxy *, int __pyx_skip_dispatch, struct __pyx_opt_args_5pysam_6cfaidx_10FastqProxy_get_quality_array *__pyx_optional_args);
};
static struct __pyx_vtabstruct_5pysam_6cfaidx_FastqProxy *__pyx_vtabptr_5pysam_6cfaidx_FastqProxy;


/* "pysam/cfaidx.pxd":54
 * 
 * 
 * cdef class PersistentFastqProxy:             # <<<<<<<<<<<<<<
 *     """
 *     Python container for pysam.cfaidx.FastqProxy with persistence.
 */

struct __pyx_vtabstruct_5pysam_6cfaidx_PersistentFastqProxy {
  PyObject *(*tostring)(struct __pyx_obj_5pysam_6cfaidx_PersistentFastqProxy *);
  arrayobject *(*get_quality_array)(struct __pyx_obj_5pysam_6cfaidx_PersistentFastqProxy *, int __pyx_skip_dispatch, struct __pyx_opt_args_5pysam_6cfaidx_20PersistentFastqProxy_get_quality_array *__pyx_optional_args);
};
static struct __pyx_vtabstruct_5pysam_6cfaidx_PersistentFastqProxy *__pyx_vtabptr_5pysam_6cfaidx_PersistentFastqProxy;


/* "pysam/cfaidx.pxd":63
 * 
 * 
 * cdef class FastxFile:             # <<<<<<<<<<<<<<
 *     cdef object _filename
 *     cdef gzFile fastqfile
 */

struct __pyx_vtabstruct_5pysam_6cfaidx_FastxFile {
  kseq_t *(*getCurrent)(struct __pyx_obj_5pysam_6cfaidx_FastxFile *);
  int (*cnext)(struct __pyx_obj_5pysam_6cfaidx_FastxFile *);
};
static struct __pyx_vtabstruct_5pysam_6cfaidx_FastxFile *__pyx_vtabptr_5pysam_6cfaidx_FastxFile;


/* "pysam/cfaidx.pxd":74
 * 
 * # Compatibility Layer for pysam 0.8.1
 * cdef class FastqFile(FastxFile):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_5pysam_6cfaidx_FastqFile {
  struct __pyx_vtabstruct_5pysam_6cfaidx_FastxFile __pyx_base;
};
static struct __pyx_vtabstruct_5pysam_6cfaidx_FastqFile *__pyx_vtabptr_5pysam_6cfaidx_FastqFile;


/* "pysam/cfaidx.pxd":79
 * 
 * # Compatibility Layer for pysam < 0.8
 * cdef class Fastafile(FastaFile):             # <<<<<<<<<<<<<<
 *     pass
 * 
 */

struct __pyx_vtabstruct_5pysam_6cfaidx_Fastafile {
  struct __pyx_vtabstruct_5pysam_6cfaidx_FastaFile __pyx_base;
};
static struct __pyx_vtabstruct_5pysam_6cfaidx_Fastafile *__pyx_vtabptr_5pysam_6cfaidx_Fastafile;


/* "pysam/calignedsegment.pxd":40
 * 
 * # Note: need to declare all C fields and methods here
 * cdef class AlignedSegment:             # <<<<<<<<<<<<<<
 * 
 *     # object that this AlignedSegment represents
 */

struct __pyx_vtabstruct_5pysam_15calignedsegment_AlignedSegment {
  PyObject *(*set_tag)(struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *, PyObject *, PyObject *, int __pyx_skip_dispatch, struct __pyx_opt_args_5pysam_15calignedsegment_14AlignedSegment_set_tag *__pyx_optional_args);
  PyObject *(*get_tag)(struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *, PyObject *, int __pyx_skip_dispatch, struct __pyx_opt_args_5pysam_15calignedsegment_14AlignedSegment_get_tag *__pyx_optional_args);
  PyObject *(*has_tag)(struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *, PyObject *, int __pyx_skip_dispatch);
  PyObject *(*tostring)(struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *, __pyx_t_5pysam_15calignedsegment_AlignmentFile_t, int __pyx_skip_dispatch);
};
static struct __pyx_vtabstruct_5pysam_15calignedsegment_AlignedSegment *__pyx_vtabptr_5pysam_15calignedsegment_AlignedSegment;


/* "pysam/calignmentfile.pyx":217
 * 
 * 
 * cdef class AlignmentFile:             # <<<<<<<<<<<<<<
 *     """AlignmentFile(filepath_or_object, mode=None, template=None,
 *     reference_names=None, reference_lengths=None, text=NULL,
 */

struct __pyx_vtabstruct_5pysam_14calignmentfile_AlignmentFile {
  bam1_t *(*getCurrent)(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *);
  int (*cnext)(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *);
  int (*write)(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *, struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *, int __pyx_skip_dispatch);
};
static struct __pyx_vtabstruct_5pysam_14calignmentfile_AlignmentFile *__pyx_vtabptr_5pysam_14calignmentfile_AlignmentFile;


/* "pysam/calignmentfile.pyx":1705
 * 
 * 
 * cdef class IteratorRowRegion(IteratorRow):             # <<<<<<<<<<<<<<
 *     """*(AlignmentFile samfile, int tid, int beg, int end,
 *     int multiple_iterators=False)*
 */

struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorRowRegion {
  bam1_t *(*getCurrent)(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *);
  int (*cnext)(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *);
};
static struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorRowRegion *__pyx_vtabptr_5pysam_14calignmentfile_IteratorRowRegion;


/* "pysam/calignmentfile.pyx":1766
 * 
 * 
 * cdef class IteratorRowHead(IteratorRow):             # <<<<<<<<<<<<<<
 *     """*(AlignmentFile samfile, n, int multiple_iterators=False)*
 * 
 */

struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorRowHead {
  bam1_t *(*getCurrent)(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead *);
  int (*cnext)(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead *);
};
static struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorRowHead *__pyx_vtabptr_5pysam_14calignmentfile_IteratorRowHead;


/* "pysam/calignmentfile.pyx":1816
 * 
 * 
 * cdef class IteratorRowAll(IteratorRow):             # <<<<<<<<<<<<<<
 *     """*(AlignmentFile samfile, int multiple_iterators=False)*
 * 
 */

struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorRowAll {
  bam1_t *(*getCurrent)(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll *);
  int (*cnext)(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll *);
};
static struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorRowAll *__pyx_vtabptr_5pysam_14calignmentfile_IteratorRowAll;


/* "pysam/calignmentfile.pyx":1925
 * 
 * 
 * cdef class IteratorRowSelection(IteratorRow):             # <<<<<<<<<<<<<<
 *     """*(AlignmentFile samfile)*
 * 
 */

struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorRowSelection {
  bam1_t *(*getCurrent)(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *);
  int (*cnext)(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *);
};
static struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorRowSelection *__pyx_vtabptr_5pysam_14calignmentfile_IteratorRowSelection;


/* "pysam/calignmentfile.pyx":2076
 *     return ret
 * 
 * cdef class IteratorColumn:             # <<<<<<<<<<<<<<
 *     '''abstract base class for iterators over columns.
 * 
 */

struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorColumn {
  int (*cnext)(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *);
  char *(*getSequence)(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *);
  PyObject *(*setMask)(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *, PyObject *);
  PyObject *(*setupIteratorData)(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *, int, int, int, struct __pyx_opt_args_5pysam_14calignmentfile_14IteratorColumn_setupIteratorData *__pyx_optional_args);
  PyObject *(*reset)(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *, PyObject *, PyObject *, PyObject *);
  PyObject *(*_free_pileup_iter)(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *);
};
static struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorColumn *__pyx_vtabptr_5pysam_14calignmentfile_IteratorColumn;


/* "pysam/calignmentfile.pyx":2270
 * 
 * 
 * cdef class IteratorColumnRegion(IteratorColumn):             # <<<<<<<<<<<<<<
 *     '''iterates over a region only.
 *     '''
 */

struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorColumnRegion {
  struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorColumn __pyx_base;
};
static struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorColumnRegion *__pyx_vtabptr_5pysam_14calignmentfile_IteratorColumnRegion;


/* "pysam/calignmentfile.pyx":2307
 * 
 * 
 * cdef class IteratorColumnAllRefs(IteratorColumn):             # <<<<<<<<<<<<<<
 *     """iterates over all columns by chaining iterators over each reference
 *     """
 */

struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorColumnAllRefs {
  struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorColumn __pyx_base;
};
static struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorColumnAllRefs *__pyx_vtabptr_5pysam_14calignmentfile_IteratorColumnAllRefs;

/* --- Runtime support code (head) --- */
/* Refnanny.proto */
#ifndef CYTHON_REFNANNY
  #define CYTHON_REFNANNY 0
#endif
#if CYTHON_REFNANNY
  typedef struct {
    void (*INCREF)(void*, PyObject*, int);
    void (*DECREF)(void*, PyObject*, int);
    void (*GOTREF)(void*, PyObject*, int);
    void (*GIVEREF)(void*, PyObject*, int);
    void* (*SetupContext)(const char*, int, const char*);
    void (*FinishContext)(void**);
  } __Pyx_RefNannyAPIStruct;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname);
  #define __Pyx_RefNannyDeclarations void *__pyx_refnanny = NULL;
#ifdef WITH_THREAD
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          if (acquire_gil) {\
              PyGILState_STATE __pyx_gilstate_save = PyGILState_Ensure();\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
              PyGILState_Release(__pyx_gilstate_save);\
          } else {\
              __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__);\
          }
#else
  #define __Pyx_RefNannySetupContext(name, acquire_gil)\
          __pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
#endif
  #define __Pyx_RefNannyFinishContext()\
          __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
  #define __Pyx_INCREF(r)  __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_DECREF(r)  __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GOTREF(r)  __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_XINCREF(r)  do { if((r) != NULL) {__Pyx_INCREF(r); }} while(0)
  #define __Pyx_XDECREF(r)  do { if((r) != NULL) {__Pyx_DECREF(r); }} while(0)
  #define __Pyx_XGOTREF(r)  do { if((r) != NULL) {__Pyx_GOTREF(r); }} while(0)
  #define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);}} while(0)
#else
  #define __Pyx_RefNannyDeclarations
  #define __Pyx_RefNannySetupContext(name, acquire_gil)
  #define __Pyx_RefNannyFinishContext()
  #define __Pyx_INCREF(r) Py_INCREF(r)
  #define __Pyx_DECREF(r) Py_DECREF(r)
  #define __Pyx_GOTREF(r)
  #define __Pyx_GIVEREF(r)
  #define __Pyx_XINCREF(r) Py_XINCREF(r)
  #define __Pyx_XDECREF(r) Py_XDECREF(r)
  #define __Pyx_XGOTREF(r)
  #define __Pyx_XGIVEREF(r)
#endif
#define __Pyx_XDECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_XDECREF(tmp);\
    } while (0)
#define __Pyx_DECREF_SET(r, v) do {\
        PyObject *tmp = (PyObject *) r;\
        r = v; __Pyx_DECREF(tmp);\
    } while (0)
#define __Pyx_CLEAR(r)    do { PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);} while(0)
#define __Pyx_XCLEAR(r)   do { if((r) != NULL) {PyObject* tmp = ((PyObject*)(r)); r = NULL; __Pyx_DECREF(tmp);}} while(0)

/* PyObjectGetAttrStr.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetAttrStr(PyObject* obj, PyObject* attr_name) {
    PyTypeObject* tp = Py_TYPE(obj);
    if (likely(tp->tp_getattro))
        return tp->tp_getattro(obj, attr_name);
#if PY_MAJOR_VERSION < 3
    if (likely(tp->tp_getattr))
        return tp->tp_getattr(obj, PyString_AS_STRING(attr_name));
#endif
    return PyObject_GetAttr(obj, attr_name);
}
#else
#define __Pyx_PyObject_GetAttrStr(o,n) PyObject_GetAttr(o,n)
#endif

/* GetBuiltinName.proto */
static PyObject *__Pyx_GetBuiltinName(PyObject *name);

/* RaiseArgTupleInvalid.proto */
static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found);

/* RaiseDoubleKeywords.proto */
static void __Pyx_RaiseDoubleKeywordsError(const char* func_name, PyObject* kw_name);

/* ParseKeywords.proto */
static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],\
    PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,\
    const char* function_name);

/* Profile.proto */
#ifndef CYTHON_PROFILE
#if CYTHON_COMPILING_IN_PYPY
  #define CYTHON_PROFILE 0
#else
  #define CYTHON_PROFILE 1
#endif
#endif
#ifndef CYTHON_TRACE_NOGIL
  #define CYTHON_TRACE_NOGIL 0
#else
  #if CYTHON_TRACE_NOGIL && !defined(CYTHON_TRACE)
    #define CYTHON_TRACE 1
  #endif
#endif
#ifndef CYTHON_TRACE
  #define CYTHON_TRACE 0
#endif
#if CYTHON_TRACE
  #undef CYTHON_PROFILE_REUSE_FRAME
#endif
#ifndef CYTHON_PROFILE_REUSE_FRAME
  #define CYTHON_PROFILE_REUSE_FRAME 0
#endif
#if CYTHON_PROFILE || CYTHON_TRACE
  #include "compile.h"
  #include "frameobject.h"
  #include "traceback.h"
  #if CYTHON_PROFILE_REUSE_FRAME
    #define CYTHON_FRAME_MODIFIER static
    #define CYTHON_FRAME_DEL(frame)
  #else
    #define CYTHON_FRAME_MODIFIER
    #define CYTHON_FRAME_DEL(frame) Py_CLEAR(frame)
  #endif
  #define __Pyx_TraceDeclarations\
  static PyCodeObject *__pyx_frame_code = NULL;\
  CYTHON_FRAME_MODIFIER PyFrameObject *__pyx_frame = NULL;\
  int __Pyx_use_tracing = 0;
  #define __Pyx_TraceFrameInit(codeobj)\
  if (codeobj) __pyx_frame_code = (PyCodeObject*) codeobj;
  #ifdef WITH_THREAD
  #define __Pyx_TraceCall(funcname, srcfile, firstlineno, nogil, goto_error)\
  if (nogil) {\
      if (CYTHON_TRACE_NOGIL) {\
          PyThreadState *tstate;\
          PyGILState_STATE state = PyGILState_Ensure();\
          tstate = PyThreadState_GET();\
          if (unlikely(tstate->use_tracing) && !tstate->tracing &&\
                  (tstate->c_profilefunc || (CYTHON_TRACE && tstate->c_tracefunc))) {\
              __Pyx_use_tracing = __Pyx_TraceSetupAndCall(&__pyx_frame_code, &__pyx_frame, funcname, srcfile, firstlineno);\
          }\
          PyGILState_Release(state);\
          if (unlikely(__Pyx_use_tracing < 0)) goto_error;\
      }\
  } else {\
      PyThreadState* tstate = PyThreadState_GET();\
      if (unlikely(tstate->use_tracing) && !tstate->tracing &&\
              (tstate->c_profilefunc || (CYTHON_TRACE && tstate->c_tracefunc))) {\
          __Pyx_use_tracing = __Pyx_TraceSetupAndCall(&__pyx_frame_code, &__pyx_frame, funcname, srcfile, firstlineno);\
          if (unlikely(__Pyx_use_tracing < 0)) goto_error;\
      }\
  }
  #else
  #define __Pyx_TraceCall(funcname, srcfile, firstlineno, nogil, goto_error)\
  {   PyThreadState* tstate = PyThreadState_GET();\
      if (unlikely(tstate->use_tracing) && !tstate->tracing &&\
              (tstate->c_profilefunc || (CYTHON_TRACE && tstate->c_tracefunc))) {\
          __Pyx_use_tracing = __Pyx_TraceSetupAndCall(&__pyx_frame_code, &__pyx_frame, funcname, srcfile, firstlineno);\
          if (unlikely(__Pyx_use_tracing < 0)) goto_error;\
      }\
  }
  #endif
  #define __Pyx_TraceException()\
  if (likely(!__Pyx_use_tracing)); else {\
      PyThreadState* tstate = PyThreadState_GET();\
      if (tstate->use_tracing &&\
              (tstate->c_profilefunc || (CYTHON_TRACE && tstate->c_tracefunc))) {\
          tstate->tracing++;\
          tstate->use_tracing = 0;\
          PyObject *exc_info = __Pyx_GetExceptionTuple(tstate);\
          if (exc_info) {\
              if (CYTHON_TRACE && tstate->c_tracefunc)\
                  tstate->c_tracefunc(\
                      tstate->c_traceobj, __pyx_frame, PyTrace_EXCEPTION, exc_info);\
              tstate->c_profilefunc(\
                  tstate->c_profileobj, __pyx_frame, PyTrace_EXCEPTION, exc_info);\
              Py_DECREF(exc_info);\
          }\
          tstate->use_tracing = 1;\
          tstate->tracing--;\
      }\
  }
  static void __Pyx_call_return_trace_func(PyThreadState *tstate, PyFrameObject *frame, PyObject *result) {
      PyObject *type, *value, *traceback;
      PyErr_Fetch(&type, &value, &traceback);
      tstate->tracing++;
      tstate->use_tracing = 0;
      if (CYTHON_TRACE && tstate->c_tracefunc)
          tstate->c_tracefunc(tstate->c_traceobj, frame, PyTrace_RETURN, result);
      if (tstate->c_profilefunc)
          tstate->c_profilefunc(tstate->c_profileobj, frame, PyTrace_RETURN, result);
      CYTHON_FRAME_DEL(frame);
      tstate->use_tracing = 1;
      tstate->tracing--;
      PyErr_Restore(type, value, traceback);
  }
  #ifdef WITH_THREAD
  #define __Pyx_TraceReturn(result, nogil)\
  if (likely(!__Pyx_use_tracing)); else {\
      if (nogil) {\
          if (CYTHON_TRACE_NOGIL) {\
              PyThreadState *tstate;\
              PyGILState_STATE state = PyGILState_Ensure();\
              tstate = PyThreadState_GET();\
              if (tstate->use_tracing) {\
                  __Pyx_call_return_trace_func(tstate, __pyx_frame, (PyObject*)result);\
              }\
              PyGILState_Release(state);\
          }\
      } else {\
          PyThreadState* tstate = PyThreadState_GET();\
          if (tstate->use_tracing) {\
              __Pyx_call_return_trace_func(tstate, __pyx_frame, (PyObject*)result);\
          }\
      }\
  }
  #else
  #define __Pyx_TraceReturn(result, nogil)\
  if (likely(!__Pyx_use_tracing)); else {\
      PyThreadState* tstate = PyThreadState_GET();\
      if (tstate->use_tracing) {\
          __Pyx_call_return_trace_func(tstate, __pyx_frame, (PyObject*)result);\
      }\
  }
  #endif
  static PyCodeObject *__Pyx_createFrameCodeObject(const char *funcname, const char *srcfile, int firstlineno);
  static int __Pyx_TraceSetupAndCall(PyCodeObject** code, PyFrameObject** frame, const char *funcname, const char *srcfile, int firstlineno);
#else
  #define __Pyx_TraceDeclarations
  #define __Pyx_TraceFrameInit(codeobj)
  #define __Pyx_TraceCall(funcname, srcfile, firstlineno, nogil, goto_error)   if (1); else goto_error;
  #define __Pyx_TraceException()
  #define __Pyx_TraceReturn(result, nogil)
#endif
#if CYTHON_TRACE
  static int __Pyx_call_line_trace_func(PyThreadState *tstate, PyFrameObject *frame, int lineno) {
      int ret;
      PyObject *type, *value, *traceback;
      PyErr_Fetch(&type, &value, &traceback);
      frame->f_lineno = lineno;
      tstate->tracing++;
      tstate->use_tracing = 0;
      ret = tstate->c_tracefunc(tstate->c_traceobj, frame, PyTrace_LINE, NULL);
      tstate->use_tracing = 1;
      tstate->tracing--;
      if (likely(!ret)) {
          PyErr_Restore(type, value, traceback);
      } else {
          Py_XDECREF(type);
          Py_XDECREF(value);
          Py_XDECREF(traceback);
      }
      return ret;
  }
  #ifdef WITH_THREAD
  #define __Pyx_TraceLine(lineno, nogil, goto_error)\
  if (likely(!__Pyx_use_tracing)); else {\
      if (nogil) {\
          if (CYTHON_TRACE_NOGIL) {\
              int ret = 0;\
              PyThreadState *tstate;\
              PyGILState_STATE state = PyGILState_Ensure();\
              tstate = PyThreadState_GET();\
              if (unlikely(tstate->use_tracing && tstate->c_tracefunc)) {\
                  ret = __Pyx_call_line_trace_func(tstate, __pyx_frame, lineno);\
              }\
              PyGILState_Release(state);\
              if (unlikely(ret)) goto_error;\
          }\
      } else {\
          PyThreadState* tstate = PyThreadState_GET();\
          if (unlikely(tstate->use_tracing && tstate->c_tracefunc)) {\
              int ret = __Pyx_call_line_trace_func(tstate, __pyx_frame, lineno);\
              if (unlikely(ret)) goto_error;\
          }\
      }\
  }
  #else
  #define __Pyx_TraceLine(lineno, nogil, goto_error)\
  if (likely(!__Pyx_use_tracing)); else {\
      PyThreadState* tstate = PyThreadState_GET();\
      if (unlikely(tstate->use_tracing && tstate->c_tracefunc)) {\
          int ret = __Pyx_call_line_trace_func(tstate, __pyx_frame, lineno);\
          if (unlikely(ret)) goto_error;\
      }\
  }
  #endif
#else
  #define __Pyx_TraceLine(lineno, nogil, goto_error)   if (1); else goto_error;
#endif

/* IncludeStringH.proto */
#include <string.h>

/* BytesEquals.proto */
static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals);

/* UnicodeEquals.proto */
static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals);

/* StrEquals.proto */
#if PY_MAJOR_VERSION >= 3
#define __Pyx_PyString_Equals __Pyx_PyUnicode_Equals
#else
#define __Pyx_PyString_Equals __Pyx_PyBytes_Equals
#endif

/* ListAppend.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE int __Pyx_PyList_Append(PyObject* list, PyObject* x) {
    PyListObject* L = (PyListObject*) list;
    Py_ssize_t len = Py_SIZE(list);
    if (likely(L->allocated > len) & likely(len > (L->allocated >> 1))) {
        Py_INCREF(x);
        PyList_SET_ITEM(list, len, x);
        Py_SIZE(list) = len+1;
        return 0;
    }
    return PyList_Append(list, x);
}
#else
#define __Pyx_PyList_Append(L,x) PyList_Append(L,x)
#endif

/* PyObjectCall.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw);
#else
#define __Pyx_PyObject_Call(func, arg, kw) PyObject_Call(func, arg, kw)
#endif

/* PyObjectCallMethO.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg);
#endif

/* PyObjectCallOneArg.proto */
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg);

/* PyObjectCallNoArg.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func);
#else
#define __Pyx_PyObject_CallNoArg(func) __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL)
#endif

/* GetModuleGlobalName.proto */
static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name);

/* PySequenceContains.proto */
static CYTHON_INLINE int __Pyx_PySequence_ContainsTF(PyObject* item, PyObject* seq, int eq) {
    int result = PySequence_Contains(seq, item);
    return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
}

/* StringJoin.proto */
#if PY_MAJOR_VERSION < 3
#define __Pyx_PyString_Join __Pyx_PyBytes_Join
#define __Pyx_PyBaseString_Join(s, v) (PyUnicode_CheckExact(s) ? PyUnicode_Join(s, v) : __Pyx_PyBytes_Join(s, v))
#else
#define __Pyx_PyString_Join PyUnicode_Join
#define __Pyx_PyBaseString_Join PyUnicode_Join
#endif
#if CYTHON_COMPILING_IN_CPYTHON
    #if PY_MAJOR_VERSION < 3
    #define __Pyx_PyBytes_Join _PyString_Join
    #else
    #define __Pyx_PyBytes_Join _PyBytes_Join
    #endif
#else
static CYTHON_INLINE PyObject* __Pyx_PyBytes_Join(PyObject* sep, PyObject* values);
#endif

/* PyThreadStateGet.proto */
#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_PyThreadState_declare  PyThreadState *__pyx_tstate;
#define __Pyx_PyThreadState_assign  __pyx_tstate = PyThreadState_GET();
#else
#define __Pyx_PyThreadState_declare
#define __Pyx_PyThreadState_assign
#endif

/* PyErrFetchRestore.proto */
#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_ErrRestoreWithState(type, value, tb)  __Pyx_ErrRestoreInState(PyThreadState_GET(), type, value, tb)
#define __Pyx_ErrFetchWithState(type, value, tb)    __Pyx_ErrFetchInState(PyThreadState_GET(), type, value, tb)
#define __Pyx_ErrRestore(type, value, tb)  __Pyx_ErrRestoreInState(__pyx_tstate, type, value, tb)
#define __Pyx_ErrFetch(type, value, tb)    __Pyx_ErrFetchInState(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#else
#define __Pyx_ErrRestoreWithState(type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetchWithState(type, value, tb)  PyErr_Fetch(type, value, tb)
#define __Pyx_ErrRestore(type, value, tb)  PyErr_Restore(type, value, tb)
#define __Pyx_ErrFetch(type, value, tb)  PyErr_Fetch(type, value, tb)
#endif

/* RaiseException.proto */
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause);

/* RaiseTooManyValuesToUnpack.proto */
static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected);

/* RaiseNeedMoreValuesToUnpack.proto */
static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);

/* IterFinish.proto */
static CYTHON_INLINE int __Pyx_IterFinish(void);

/* UnpackItemEndCheck.proto */
static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected);

/* SaveResetException.proto */
#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_ExceptionSave(type, value, tb)  __Pyx__ExceptionSave(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#define __Pyx_ExceptionReset(type, value, tb)  __Pyx__ExceptionReset(__pyx_tstate, type, value, tb)
static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb);
#else
#define __Pyx_ExceptionSave(type, value, tb)   PyErr_GetExcInfo(type, value, tb)
#define __Pyx_ExceptionReset(type, value, tb)  PyErr_SetExcInfo(type, value, tb)
#endif

/* PyErrExceptionMatches.proto */
#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_PyErr_ExceptionMatches(err) __Pyx_PyErr_ExceptionMatchesInState(__pyx_tstate, err)
static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err);
#else
#define __Pyx_PyErr_ExceptionMatches(err)  PyErr_ExceptionMatches(err)
#endif

/* GetException.proto */
#if CYTHON_COMPILING_IN_CPYTHON
#define __Pyx_GetException(type, value, tb)  __Pyx__GetException(__pyx_tstate, type, value, tb)
static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb);
#else
static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb);
#endif

/* GetItemInt.proto */
#define __Pyx_GetItemInt(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_GetItemInt_Fast(o, (Py_ssize_t)i, is_list, wraparound, boundscheck) :\
    (is_list ? (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL) :\
               __Pyx_GetItemInt_Generic(o, to_py_func(i))))
#define __Pyx_GetItemInt_List(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_GetItemInt_List_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
    (PyErr_SetString(PyExc_IndexError, "list index out of range"), (PyObject*)NULL))
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck);
#define __Pyx_GetItemInt_Tuple(o, i, type, is_signed, to_py_func, is_list, wraparound, boundscheck)\
    (__Pyx_fits_Py_ssize_t(i, type, is_signed) ?\
    __Pyx_GetItemInt_Tuple_Fast(o, (Py_ssize_t)i, wraparound, boundscheck) :\
    (PyErr_SetString(PyExc_IndexError, "tuple index out of range"), (PyObject*)NULL))
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                              int wraparound, int boundscheck);
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j);
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i,
                                                     int is_list, int wraparound, int boundscheck);

/* WriteUnraisableException.proto */
static void __Pyx_WriteUnraisable(const char *name, int clineno,
                                  int lineno, const char *filename,
                                  int full_traceback, int nogil);

/* KeywordStringCheck.proto */
static CYTHON_INLINE int __Pyx_CheckKeywordStrings(PyObject *kwdict, const char* function_name, int kw_allowed);

/* PyDictContains.proto */
static CYTHON_INLINE int __Pyx_PyDict_ContainsTF(PyObject* item, PyObject* dict, int eq) {
    int result = PyDict_Contains(dict, item);
    return unlikely(result < 0) ? result : (result == (eq == Py_EQ));
}

/* DictGetItem.proto */
#if PY_MAJOR_VERSION >= 3 && !CYTHON_COMPILING_IN_PYPY
static PyObject *__Pyx_PyDict_GetItem(PyObject *d, PyObject* key) {
    PyObject *value;
    value = PyDict_GetItemWithError(d, key);
    if (unlikely(!value)) {
        if (!PyErr_Occurred()) {
            PyObject* args = PyTuple_Pack(1, key);
            if (likely(args))
                PyErr_SetObject(PyExc_KeyError, args);
            Py_XDECREF(args);
        }
        return NULL;
    }
    Py_INCREF(value);
    return value;
}
#else
    #define __Pyx_PyDict_GetItem(d, key) PyObject_GetItem(d, key)
#endif

/* ArgTypeTest.proto */
static CYTHON_INLINE int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
    const char *name, int exact);

/* ListCompAppend.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE int __Pyx_ListComp_Append(PyObject* list, PyObject* x) {
    PyListObject* L = (PyListObject*) list;
    Py_ssize_t len = Py_SIZE(list);
    if (likely(L->allocated > len)) {
        Py_INCREF(x);
        PyList_SET_ITEM(list, len, x);
        Py_SIZE(list) = len+1;
        return 0;
    }
    return PyList_Append(list, x);
}
#else
#define __Pyx_ListComp_Append(L,x) PyList_Append(L,x)
#endif

/* PyObjectCallMethod1.proto */
static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg);

/* append.proto */
static CYTHON_INLINE int __Pyx_PyObject_Append(PyObject* L, PyObject* x);

/* SliceObject.proto */
static CYTHON_INLINE PyObject* __Pyx_PyObject_GetSlice(
        PyObject* obj, Py_ssize_t cstart, Py_ssize_t cstop,
        PyObject** py_start, PyObject** py_stop, PyObject** py_slice,
        int has_cstart, int has_cstop, int wraparound);

/* PyIntBinop.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx_PyInt_SubtractObjC(PyObject *op1, PyObject *op2, long intval, int inplace);
#else
#define __Pyx_PyInt_SubtractObjC(op1, op2, intval, inplace)\
    (inplace ? PyNumber_InPlaceSubtract(op1, op2) : PyNumber_Subtract(op1, op2))
#endif

/* PyObjectCallMethod0.proto */
static PyObject* __Pyx_PyObject_CallMethod0(PyObject* obj, PyObject* method_name);

/* RaiseNoneIterError.proto */
static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void);

/* UnpackTupleError.proto */
static void __Pyx_UnpackTupleError(PyObject *, Py_ssize_t index);

/* UnpackTuple2.proto */
static CYTHON_INLINE int __Pyx_unpack_tuple2(PyObject* tuple, PyObject** value1, PyObject** value2,
                                             int is_tuple, int has_known_size, int decref_tuple);

/* dict_iter.proto */
static CYTHON_INLINE PyObject* __Pyx_dict_iterator(PyObject* dict, int is_dict, PyObject* method_name,
                                                   Py_ssize_t* p_orig_length, int* p_is_dict);
static CYTHON_INLINE int __Pyx_dict_iter_next(PyObject* dict_or_iter, Py_ssize_t orig_length, Py_ssize_t* ppos,
                                              PyObject** pkey, PyObject** pvalue, PyObject** pitem, int is_dict);

/* MergeKeywords.proto */
static int __Pyx_MergeKeywords(PyObject *kwdict, PyObject *source_mapping);

/* ExtTypeTest.proto */
static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type);

/* PyIntBinop.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx_PyInt_AndObjC(PyObject *op1, PyObject *op2, long intval, int inplace);
#else
#define __Pyx_PyInt_AndObjC(op1, op2, intval, inplace)\
    (inplace ? PyNumber_InPlaceAnd(op1, op2) : PyNumber_And(op1, op2))
#endif

/* PyIntBinop.proto */
#if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx_PyInt_AddObjC(PyObject *op1, PyObject *op2, long intval, int inplace);
#else
#define __Pyx_PyInt_AddObjC(op1, op2, intval, inplace)\
    (inplace ? PyNumber_InPlaceAdd(op1, op2) : PyNumber_Add(op1, op2))
#endif

/* dict_getitem_default.proto */
static PyObject* __Pyx_PyDict_GetItemDefault(PyObject* d, PyObject* key, PyObject* default_value);

/* SetVTable.proto */
static int __Pyx_SetVtable(PyObject *dict, void *vtable);

/* GetVTable.proto */
static void* __Pyx_GetVtable(PyObject *dict);

/* Import.proto */
static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level);

/* ImportFrom.proto */
static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name);

/* CodeObjectCache.proto */
typedef struct {
    PyCodeObject* code_object;
    int code_line;
} __Pyx_CodeObjectCacheEntry;
struct __Pyx_CodeObjectCache {
    int count;
    int max_count;
    __Pyx_CodeObjectCacheEntry* entries;
};
static struct __Pyx_CodeObjectCache __pyx_code_cache = {0,0,NULL};
static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line);
static PyCodeObject *__pyx_find_code_object(int code_line);
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object);

/* AddTraceback.proto */
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename);

/* ArrayAPI.proto */
#ifndef _ARRAYARRAY_H
#define _ARRAYARRAY_H
typedef struct arraydescr {
    int typecode;
    int itemsize;
    PyObject * (*getitem)(struct arrayobject *, Py_ssize_t);
    int (*setitem)(struct arrayobject *, Py_ssize_t, PyObject *);
#if PY_MAJOR_VERSION >= 3
    char *formats;
#endif
} arraydescr;
struct arrayobject {
    PyObject_HEAD
    Py_ssize_t ob_size;
    union {
        char *ob_item;
        float *as_floats;
        double *as_doubles;
        int *as_ints;
        unsigned int *as_uints;
        unsigned char *as_uchars;
        signed char *as_schars;
        char *as_chars;
        unsigned long *as_ulongs;
        long *as_longs;
        short *as_shorts;
        unsigned short *as_ushorts;
        Py_UNICODE *as_pyunicodes;
        void *as_voidptr;
    } data;
    Py_ssize_t allocated;
    struct arraydescr *ob_descr;
    PyObject *weakreflist;
#if PY_MAJOR_VERSION >= 3
        int ob_exports;
#endif
};
#ifndef NO_NEWARRAY_INLINE
static CYTHON_INLINE PyObject * newarrayobject(PyTypeObject *type, Py_ssize_t size,
    struct arraydescr *descr) {
    arrayobject *op;
    size_t nbytes;
    if (size < 0) {
        PyErr_BadInternalCall();
        return NULL;
    }
    nbytes = size * descr->itemsize;
    if (nbytes / descr->itemsize != (size_t)size) {
        return PyErr_NoMemory();
    }
    op = (arrayobject *) type->tp_alloc(type, 0);
    if (op == NULL) {
        return NULL;
    }
    op->ob_descr = descr;
    op->allocated = size;
    op->weakreflist = NULL;
    op->ob_size = size;
    if (size <= 0) {
        op->data.ob_item = NULL;
    }
    else {
        op->data.ob_item = PyMem_NEW(char, nbytes);
        if (op->data.ob_item == NULL) {
            Py_DECREF(op);
            return PyErr_NoMemory();
        }
    }
    return (PyObject *) op;
}
#else
PyObject* newarrayobject(PyTypeObject *type, Py_ssize_t size,
    struct arraydescr *descr);
#endif
static CYTHON_INLINE int resize(arrayobject *self, Py_ssize_t n) {
    void *items = (void*) self->data.ob_item;
    PyMem_Resize(items, char, (size_t)(n * self->ob_descr->itemsize));
    if (items == NULL) {
        PyErr_NoMemory();
        return -1;
    }
    self->data.ob_item = (char*) items;
    self->ob_size = n;
    self->allocated = n;
    return 0;
}
static CYTHON_INLINE int resize_smart(arrayobject *self, Py_ssize_t n) {
    void *items = (void*) self->data.ob_item;
    Py_ssize_t newsize;
    if (n < self->ob_size) {
        self->ob_size = n;
        return 0;
    }
    newsize = n + (n / 2) + 1;
    if (newsize <= self->allocated) {
        PyErr_NoMemory();
        return -1;
    }
    PyMem_Resize(items, char, (size_t)(newsize * self->ob_descr->itemsize));
    if (items == NULL) {
        PyErr_NoMemory();
        return -1;
    }
    self->data.ob_item = (char*) items;
    self->ob_size = n;
    self->allocated = newsize;
    return 0;
}
#endif

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value);

/* ForceInitThreads.proto */
#ifndef __PYX_FORCE_INIT_THREADS
  #define __PYX_FORCE_INIT_THREADS 0
#endif

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int32_t(int32_t value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int64_t(int64_t value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_uint64_t(uint64_t value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_PY_LONG_LONG(PY_LONG_LONG value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_uint32_t(uint32_t value);

/* CIntToPy.proto */
static CYTHON_INLINE PyObject* __Pyx_PyInt_From_uint16_t(uint16_t value);

/* CIntFromPy.proto */
static CYTHON_INLINE uint64_t __Pyx_PyInt_As_uint64_t(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE uint32_t __Pyx_PyInt_As_uint32_t(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE size_t __Pyx_PyInt_As_size_t(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE int64_t __Pyx_PyInt_As_int64_t(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_As_PY_LONG_LONG(PyObject *);

/* CIntFromPy.proto */
static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *);

/* CheckBinaryVersion.proto */
static int __Pyx_check_binary_version(void);

/* PyIdentifierFromString.proto */
#if !defined(__Pyx_PyIdentifier_FromString)
#if PY_MAJOR_VERSION < 3
  #define __Pyx_PyIdentifier_FromString(s) PyString_FromString(s)
#else
  #define __Pyx_PyIdentifier_FromString(s) PyUnicode_FromString(s)
#endif
#endif

/* ModuleImport.proto */
static PyObject *__Pyx_ImportModule(const char *name);

/* TypeImport.proto */
static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name, size_t size, int strict);

/* FunctionImport.proto */
static int __Pyx_ImportFunction(PyObject *module, const char *funcname, void (**f)(void), const char *sig);

/* InitStrings.proto */
static int __Pyx_InitStrings(__Pyx_StringTabEntry *t);

static int __pyx_f_5pysam_14calignmentfile_13AlignmentFile_write(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *__pyx_v_read, int __pyx_skip_dispatch); /* proto*/
static bam1_t *__pyx_f_5pysam_14calignmentfile_13AlignmentFile_getCurrent(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto*/
static int __pyx_f_5pysam_14calignmentfile_13AlignmentFile_cnext(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto*/
static bam1_t *__pyx_f_5pysam_14calignmentfile_17IteratorRowRegion_getCurrent(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *__pyx_v_self); /* proto*/
static int __pyx_f_5pysam_14calignmentfile_17IteratorRowRegion_cnext(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *__pyx_v_self); /* proto*/
static bam1_t *__pyx_f_5pysam_14calignmentfile_15IteratorRowHead_getCurrent(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead *__pyx_v_self); /* proto*/
static int __pyx_f_5pysam_14calignmentfile_15IteratorRowHead_cnext(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead *__pyx_v_self); /* proto*/
static bam1_t *__pyx_f_5pysam_14calignmentfile_14IteratorRowAll_getCurrent(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll *__pyx_v_self); /* proto*/
static int __pyx_f_5pysam_14calignmentfile_14IteratorRowAll_cnext(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll *__pyx_v_self); /* proto*/
static bam1_t *__pyx_f_5pysam_14calignmentfile_20IteratorRowSelection_getCurrent(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *__pyx_v_self); /* proto*/
static int __pyx_f_5pysam_14calignmentfile_20IteratorRowSelection_cnext(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *__pyx_v_self); /* proto*/
static int __pyx_f_5pysam_14calignmentfile_14IteratorColumn_cnext(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self); /* proto*/
static char *__pyx_f_5pysam_14calignmentfile_14IteratorColumn_getSequence(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self); /* proto*/
static PyObject *__pyx_f_5pysam_14calignmentfile_14IteratorColumn_setMask(CYTHON_UNUSED struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_mask); /* proto*/
static PyObject *__pyx_f_5pysam_14calignmentfile_14IteratorColumn_setupIteratorData(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self, int __pyx_v_tid, int __pyx_v_start, int __pyx_v_end, struct __pyx_opt_args_5pysam_14calignmentfile_14IteratorColumn_setupIteratorData *__pyx_optional_args); /* proto*/
static PyObject *__pyx_f_5pysam_14calignmentfile_14IteratorColumn_reset(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self, PyObject *__pyx_v_tid, PyObject *__pyx_v_start, PyObject *__pyx_v_end); /* proto*/
static PyObject *__pyx_f_5pysam_14calignmentfile_14IteratorColumn__free_pileup_iter(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self); /* proto*/

/* Module declarations from 'libc.stdint' */

/* Module declarations from 'libc.string' */

/* Module declarations from 'libc.stdlib' */

/* Module declarations from 'libc.stdio' */

/* Module declarations from 'cython' */

/* Module declarations from 'cpython.version' */

/* Module declarations from '__builtin__' */

/* Module declarations from 'cpython.type' */
static PyTypeObject *__pyx_ptype_7cpython_4type_type = 0;

/* Module declarations from 'cpython.object' */

/* Module declarations from 'cpython.ref' */

/* Module declarations from 'cpython.exc' */

/* Module declarations from 'cpython.module' */

/* Module declarations from 'cpython.mem' */

/* Module declarations from 'cpython.tuple' */

/* Module declarations from 'cpython.list' */

/* Module declarations from 'cpython.sequence' */

/* Module declarations from 'cpython.mapping' */

/* Module declarations from 'cpython.iterator' */

/* Module declarations from 'cpython.number' */

/* Module declarations from 'cpython.int' */

/* Module declarations from '__builtin__' */

/* Module declarations from 'cpython.bool' */
static PyTypeObject *__pyx_ptype_7cpython_4bool_bool = 0;

/* Module declarations from 'cpython.long' */

/* Module declarations from 'cpython.float' */

/* Module declarations from '__builtin__' */

/* Module declarations from 'cpython.complex' */
static PyTypeObject *__pyx_ptype_7cpython_7complex_complex = 0;

/* Module declarations from 'cpython.string' */

/* Module declarations from 'cpython.unicode' */

/* Module declarations from 'cpython.dict' */

/* Module declarations from 'cpython.instance' */

/* Module declarations from 'cpython.function' */

/* Module declarations from 'cpython.method' */

/* Module declarations from 'cpython.weakref' */

/* Module declarations from 'cpython.getargs' */

/* Module declarations from 'cpython.pythread' */

/* Module declarations from 'cpython.pystate' */

/* Module declarations from 'cpython.cobject' */

/* Module declarations from 'cpython.oldbuffer' */

/* Module declarations from 'cpython.set' */

/* Module declarations from 'cpython.buffer' */

/* Module declarations from 'cpython.bytes' */

/* Module declarations from 'cpython.pycapsule' */

/* Module declarations from 'cpython' */

/* Module declarations from 'array' */

/* Module declarations from 'cpython.array' */
static PyTypeObject *__pyx_ptype_7cpython_5array_array = 0;
static CYTHON_INLINE arrayobject *__pyx_f_7cpython_5array_clone(arrayobject *, Py_ssize_t, int); /*proto*/
static CYTHON_INLINE int __pyx_f_7cpython_5array_extend_buffer(arrayobject *, char *, Py_ssize_t); /*proto*/

/* Module declarations from 'posix.types' */

/* Module declarations from 'pysam.chtslib' */

/* Module declarations from 'pysam.cfaidx' */
static PyTypeObject *__pyx_ptype_5pysam_6cfaidx_FastaFile = 0;
static PyTypeObject *__pyx_ptype_5pysam_6cfaidx_FastqProxy = 0;
static PyTypeObject *__pyx_ptype_5pysam_6cfaidx_PersistentFastqProxy = 0;
static PyTypeObject *__pyx_ptype_5pysam_6cfaidx_FastxFile = 0;
static PyTypeObject *__pyx_ptype_5pysam_6cfaidx_FastqFile = 0;
static PyTypeObject *__pyx_ptype_5pysam_6cfaidx_Fastafile = 0;

/* Module declarations from 'pysam.calignedsegment' */
static PyTypeObject *__pyx_ptype_5pysam_15calignedsegment_AlignedSegment = 0;
static PyTypeObject *__pyx_ptype_5pysam_15calignedsegment_PileupColumn = 0;
static PyTypeObject *__pyx_ptype_5pysam_15calignedsegment_PileupRead = 0;
static PyObject *(*__pyx_f_5pysam_15calignedsegment_makeAlignedSegment)(bam1_t *, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *); /*proto*/
static PyObject *(*__pyx_f_5pysam_15calignedsegment_makePileupColumn)(bam_pileup1_t **, int, int, int, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *); /*proto*/

/* Module declarations from 'pysam.cutils' */
static PyObject *(*__pyx_f_5pysam_6cutils_charptr_to_str)(char const *, struct __pyx_opt_args_5pysam_6cutils_charptr_to_str *__pyx_optional_args); /*proto*/
static PyObject *(*__pyx_f_5pysam_6cutils_force_str)(PyObject *, struct __pyx_opt_args_5pysam_6cutils_force_str *__pyx_optional_args); /*proto*/
static PyObject *(*__pyx_f_5pysam_6cutils_force_bytes)(PyObject *, struct __pyx_opt_args_5pysam_6cutils_force_bytes *__pyx_optional_args); /*proto*/
static PyObject *(*__pyx_f_5pysam_6cutils_encode_filename)(PyObject *); /*proto*/
static PyObject *(*__pyx_f_5pysam_6cutils_from_string_and_size)(char const *, size_t); /*proto*/

/* Module declarations from 'pysam.calignmentfile' */
static PyTypeObject *__pyx_ptype_5pysam_14calignmentfile_AlignmentFile = 0;
static PyTypeObject *__pyx_ptype_5pysam_14calignmentfile_PileupColumn = 0;
static PyTypeObject *__pyx_ptype_5pysam_14calignmentfile_PileupRead = 0;
static PyTypeObject *__pyx_ptype_5pysam_14calignmentfile_IteratorRow = 0;
static PyTypeObject *__pyx_ptype_5pysam_14calignmentfile_IteratorRowRegion = 0;
static PyTypeObject *__pyx_ptype_5pysam_14calignmentfile_IteratorRowHead = 0;
static PyTypeObject *__pyx_ptype_5pysam_14calignmentfile_IteratorRowAll = 0;
static PyTypeObject *__pyx_ptype_5pysam_14calignmentfile_IteratorRowAllRefs = 0;
static PyTypeObject *__pyx_ptype_5pysam_14calignmentfile_IteratorRowSelection = 0;
static PyTypeObject *__pyx_ptype_5pysam_14calignmentfile_IteratorColumn = 0;
static PyTypeObject *__pyx_ptype_5pysam_14calignmentfile_IteratorColumnRegion = 0;
static PyTypeObject *__pyx_ptype_5pysam_14calignmentfile_IteratorColumnAllRefs = 0;
static PyTypeObject *__pyx_ptype_5pysam_14calignmentfile_IndexedReads = 0;
static PyTypeObject *__pyx_ptype_5pysam_14calignmentfile_SNPCall = 0;
static int __pyx_v_5pysam_14calignmentfile_MAX_POS;
static bam_hdr_t *__pyx_f_5pysam_14calignmentfile_build_header(PyObject *); /*proto*/
static int __pyx_f_5pysam_14calignmentfile___advance_nofilter(void *, bam1_t *); /*proto*/
static int __pyx_f_5pysam_14calignmentfile___advance_all(void *, bam1_t *); /*proto*/
static int __pyx_f_5pysam_14calignmentfile___advance_snpcalls(void *, bam1_t *); /*proto*/
#define __Pyx_MODULE_NAME "pysam.calignmentfile"
int __pyx_module_is_main_pysam__calignmentfile = 0;

/* Implementation of 'pysam.calignmentfile' */
static PyObject *__pyx_builtin_ValueError;
static PyObject *__pyx_builtin_KeyError;
static PyObject *__pyx_builtin_AttributeError;
static PyObject *__pyx_builtin_NotImplementedError;
static PyObject *__pyx_builtin_IOError;
static PyObject *__pyx_builtin_OSError;
static PyObject *__pyx_builtin_OverflowError;
static PyObject *__pyx_builtin_enumerate;
static PyObject *__pyx_builtin_zip;
static PyObject *__pyx_builtin_StopIteration;
static PyObject *__pyx_builtin_map;
static PyObject *__pyx_builtin_MemoryError;
static const char __pyx_k_A[] = "A";
static const char __pyx_k_C[] = "C";
static const char __pyx_k_G[] = "G";
static const char __pyx_k_L[] = "L";
static const char __pyx_k_T[] = "T";
static const char __pyx_k_b[] = "b";
static const char __pyx_k_c[] = "c";
static const char __pyx_k_h[] = "h";
static const char __pyx_k_n[] = "n";
static const char __pyx_k_r[] = "r";
static const char __pyx_k_s[] = "@%s";
static const char __pyx_k_w[] = "w";
static const char __pyx_k_AS[] = "AS";
static const char __pyx_k_CL[] = "CL";
static const char __pyx_k_CN[] = "CN";
static const char __pyx_k_CO[] = "CO";
static const char __pyx_k_DS[] = "DS";
static const char __pyx_k_DT[] = "DT";
static const char __pyx_k_FO[] = "FO";
static const char __pyx_k_GO[] = "GO";
static const char __pyx_k_HD[] = "HD";
static const char __pyx_k_ID[] = "ID";
static const char __pyx_k_KS[] = "KS";
static const char __pyx_k_LB[] = "LB";
static const char __pyx_k_LN[] = "LN";
static const char __pyx_k_M5[] = "M5";
static const char __pyx_k_PG[] = "PG";
static const char __pyx_k_PI[] = "PI";
static const char __pyx_k_PL[] = "PL";
static const char __pyx_k_PM[] = "PM";
static const char __pyx_k_PN[] = "PN";
static const char __pyx_k_PP[] = "PP";
static const char __pyx_k_PU[] = "PU";
static const char __pyx_k_RG[] = "RG";
static const char __pyx_k_SM[] = "SM";
static const char __pyx_k_SN[] = "SN";
static const char __pyx_k_SO[] = "SO";
static const char __pyx_k_SP[] = "SP";
static const char __pyx_k_SQ[] = "SQ";
static const char __pyx_k_UR[] = "UR";
static const char __pyx_k_VN[] = "VN";
static const char __pyx_k__2[] = "\t";
static const char __pyx_k__3[] = "\n";
static const char __pyx_k_io[] = "io";
static const char __pyx_k_os[] = "os";
static const char __pyx_k_rU[] = "rU";
static const char __pyx_k_rb[] = "rb";
static const char __pyx_k_rc[] = "rc";
static const char __pyx_k_re[] = "re";
static const char __pyx_k_wb[] = "wb";
static const char __pyx_k_wc[] = "wc";
static const char __pyx_k_wh[] = "wh";
static const char __pyx_k__12[] = "-";
static const char __pyx_k__13[] = "";
static const char __pyx_k__23[] = "[:-]";
static const char __pyx_k__44[] = "@";
static const char __pyx_k__50[] = ":";
static const char __pyx_k_all[] = "all";
static const char __pyx_k_bai[] = ".bai";
static const char __pyx_k_beg[] = "beg";
static const char __pyx_k_end[] = "end";
static const char __pyx_k_get[] = "get";
static const char __pyx_k_key[] = "key";
static const char __pyx_k_map[] = "map";
static const char __pyx_k_pos[] = "pos";
static const char __pyx_k_s_s[] = "%s:%s";
static const char __pyx_k_seq[] = "seq";
static const char __pyx_k_tid[] = "tid";
static const char __pyx_k_wb0[] = "wb0";
static const char __pyx_k_wbu[] = "wbu";
static const char __pyx_k_zip[] = "zip";
static const char __pyx_k_crai[] = ".crai";
static const char __pyx_k_flag[] = "flag";
static const char __pyx_k_init[] = "__init__";
static const char __pyx_k_join[] = "join";
static const char __pyx_k_line[] = "line";
static const char __pyx_k_main[] = "__main__";
static const char __pyx_k_mode[] = "mode";
static const char __pyx_k_name[] = "name";
static const char __pyx_k_open[] = "_open";
static const char __pyx_k_path[] = "path";
static const char __pyx_k_port[] = "port";
static const char __pyx_k_seek[] = "seek";
static const char __pyx_k_tell[] = "tell";
static const char __pyx_k_test[] = "__test__";
static const char __pyx_k_text[] = "text";
static const char __pyx_k_warn[] = "warn";
static const char __pyx_k_all_2[] = "__all__";
static const char __pyx_k_array[] = "array";
static const char __pyx_k_ascii[] = "ascii";
static const char __pyx_k_close[] = "close";
static const char __pyx_k_fetch[] = "fetch";
static const char __pyx_k_items[] = "items";
static const char __pyx_k_split[] = "split";
static const char __pyx_k_start[] = "start";
static const char __pyx_k_strip[] = "strip";
static const char __pyx_k_where[] = "where";
static const char __pyx_k_write[] = "write";
static const char __pyx_k_append[] = "append";
static const char __pyx_k_closed[] = "closed";
static const char __pyx_k_encode[] = "encode";
static const char __pyx_k_exists[] = "exists";
static const char __pyx_k_fields[] = "fields";
static const char __pyx_k_fileno[] = "fileno";
static const char __pyx_k_gettid[] = "gettid";
static const char __pyx_k_header[] = "header";
static const char __pyx_k_import[] = "__import__";
static const char __pyx_k_offset[] = "offset";
static const char __pyx_k_record[] = "record";
static const char __pyx_k_region[] = "region";
static const char __pyx_k_IOError[] = "IOError";
static const char __pyx_k_OSError[] = "OSError";
static const char __pyx_k_get_tid[] = "get_tid";
static const char __pyx_k_is_open[] = "is_open";
static const char __pyx_k_islower[] = "islower";
static const char __pyx_k_isupper[] = "isupper";
static const char __pyx_k_lengths[] = "lengths";
static const char __pyx_k_samfile[] = "samfile";
static const char __pyx_k_stepper[] = "stepper";
static const char __pyx_k_KeyError[] = "KeyError";
static const char __pyx_k_StringIO[] = "StringIO";
static const char __pyx_k_check_sq[] = "check_sq";
static const char __pyx_k_coverage[] = "coverage";
static const char __pyx_k_exc_type[] = "exc_type";
static const char __pyx_k_filename[] = "filename";
static const char __pyx_k_genotype[] = "genotype";
static const char __pyx_k_nextiter[] = "nextiter";
static const char __pyx_k_nofilter[] = "nofilter";
static const char __pyx_k_samtools[] = "samtools";
static const char __pyx_k_stringio[] = "stringio";
static const char __pyx_k_template[] = "template";
static const char __pyx_k_truncate[] = "truncate";
static const char __pyx_k_warnings[] = "warnings";
static const char __pyx_k_enumerate[] = "enumerate";
static const char __pyx_k_exc_value[] = "exc_value";
static const char __pyx_k_fastafile[] = "fastafile";
static const char __pyx_k_has_index[] = "has_index";
static const char __pyx_k_max_depth[] = "max_depth";
static const char __pyx_k_positions[] = "positions";
static const char __pyx_k_reference[] = "reference";
static const char __pyx_k_traceback[] = "traceback";
static const char __pyx_k_until_eof[] = "until_eof";
static const char __pyx_k_ValueError[] = "ValueError";
static const char __pyx_k_pyx_vtable[] = "__pyx_vtable__";
static const char __pyx_k_query_name[] = "query_name";
static const char __pyx_k_references[] = "references";
static const char __pyx_k_startswith[] = "startswith";
static const char __pyx_k_IteratorRow[] = "IteratorRow";
static const char __pyx_k_MemoryError[] = "MemoryError";
static const char __pyx_k_add_sq_text[] = "add_sq_text";
static const char __pyx_k_check_index[] = "check_index";
static const char __pyx_k_collections[] = "collections";
static const char __pyx_k_defaultdict[] = "defaultdict";
static const char __pyx_k_nreferences[] = "nreferences";
static const char __pyx_k_snp_quality[] = "snp_quality";
static const char __pyx_k_IndexedReads[] = "IndexedReads";
static const char __pyx_k_SQ_SN_s_LN_s[] = "@SQ\tSN:%s\tLN:%s\n";
static const char __pyx_k_check_header[] = "check_header";
static const char __pyx_k_parse_region[] = "parse_region";
static const char __pyx_k_AlignmentFile[] = "AlignmentFile";
static const char __pyx_k_OverflowError[] = "OverflowError";
static const char __pyx_k_StopIteration[] = "StopIteration";
static const char __pyx_k_VALID_HEADERS[] = "VALID_HEADERS";
static const char __pyx_k_read_callback[] = "read_callback";
static const char __pyx_k_AttributeError[] = "AttributeError";
static const char __pyx_k_IteratorColumn[] = "IteratorColumn";
static const char __pyx_k_filepath_index[] = "filepath_index";
static const char __pyx_k_mate_not_found[] = "mate not found";
static const char __pyx_k_reference_base[] = "reference_base";
static const char __pyx_k_referencenames[] = "referencenames";
static const char __pyx_k_truncated_file[] = "truncated file";
static const char __pyx_k_mapping_quality[] = "mapping_quality";
static const char __pyx_k_query_qualities[] = "query_qualities";
static const char __pyx_k_reference_names[] = "reference_names";
static const char __pyx_k_file_s_not_found[] = "file `%s` not found";
static const char __pyx_k_read_s_not_found[] = "read %s not found";
static const char __pyx_k_referencelengths[] = "referencelengths";
static const char __pyx_k_sam_write_failed[] = "sam write failed";
static const char __pyx_k_build_header_line[] = "build_header_line";
static const char __pyx_k_consensus_quality[] = "consensus_quality";
static const char __pyx_k_get_aligned_pairs[] = "get_aligned_pairs";
static const char __pyx_k_quality_threshold[] = "quality_threshold";
static const char __pyx_k_reference_lengths[] = "reference_lengths";
static const char __pyx_k_VALID_HEADER_ORDER[] = "VALID_HEADER_ORDER";
static const char __pyx_k_VALID_HEADER_TYPES[] = "VALID_HEADER_TYPES";
static const char __pyx_k_end_out_of_range_i[] = "end out of range (%i)";
static const char __pyx_k_filepath_or_object[] = "filepath_or_object";
static const char __pyx_k_get_reference_name[] = "get_reference_name";
static const char __pyx_k_mate_s_is_unmapped[] = "mate %s: is unmapped";
static const char __pyx_k_multiple_iterators[] = "multiple_iterators";
static const char __pyx_k_read_s_is_unpaired[] = "read %s: is unpaired";
static const char __pyx_k_reference_filename[] = "reference_filename";
static const char __pyx_k_KNOWN_HEADER_FIELDS[] = "KNOWN_HEADER_FIELDS";
static const char __pyx_k_NotImplementedError[] = "NotImplementedError";
static const char __pyx_k_invalid_reference_s[] = "invalid reference `%s`";
static const char __pyx_k_pysam_calignmentfile[] = "pysam.calignmentfile";
static const char __pyx_k_start_out_of_range_i[] = "start out of range (%i)";
static const char __pyx_k_could_not_open_file_s[] = "could not open file `%s`";
static const char __pyx_k_header_line_without_s[] = "header line without '@': '%s'";
static const char __pyx_k_error_during_iteration[] = "error during iteration";
static const char __pyx_k_unable_to_open_index_at_s[] = "unable to open index at %s";
static const char __pyx_k_invalid_file_opening_mode_s[] = "invalid file opening mode `%s`";
static const char __pyx_k_I_O_operation_on_closed_file[] = "I/O operation on closed file";
static const char __pyx_k_no_index_available_for_fetch[] = "no index available for fetch";
static const char __pyx_k_seek_no_available_in_streams[] = "seek no available in streams";
static const char __pyx_k_no_index_available_for_pileup[] = "no index available for pileup";
static const char __pyx_k_error_while_opening_index_for_s[] = "error while opening index for '%s'";
static const char __pyx_k_fetch_called_on_bamfile_without[] = "fetch called on bamfile without index";
static const char __pyx_k_file_does_not_have_valid_header[] = "file does not have valid header (mode='%s') - is it BAM format?";
static const char __pyx_k_header_line_with_invalid_type_s[] = "header line with invalid type '%s': '%s'";
static const char __pyx_k_home_vagrant_Downloads_pysam_py[] = "/home/vagrant/Downloads/pysam/pysam_repo/pysam/pysam/calignmentfile.pyx";
static const char __pyx_k_incomplete_sequence_information[] = "incomplete sequence information in '%s'";
static const char __pyx_k_invalid_coordinates_start_i_end[] = "invalid coordinates: start (%i) > end (%i)";
static const char __pyx_k_malformatted_header_no_in_field[] = "malformatted header: no ':' in field";
static const char __pyx_k_unable_to_open_remote_index_for[] = "unable to open remote index for '%s'";
static const char __pyx_k_AlignmentFile_mapped_only_availa[] = "AlignmentFile.mapped only available in bam files";
static const char __pyx_k_access_from_StringIO_objects_not[] = "access from StringIO objects not supported";
static const char __pyx_k_can_not_iterate_over_samfile_wit[] = "can not iterate over samfile without header";
static const char __pyx_k_can_only_IndexReads_on_bam_files[] = "can only IndexReads on bam files";
static const char __pyx_k_could_not_open_file_mode_s_is_it[] = "could not open file (mode='%s') - is it SAM/BAM format?";
static const char __pyx_k_either_supply_options_template_h[] = "either supply options `template`, `header` or  both `reference_names` and `reference_lengths` for writing";
static const char __pyx_k_fetch_called_for_htsfile_without[] = "fetch called for htsfile without header";
static const char __pyx_k_fetching_by_region_is_not_availa[] = "fetching by region is not available for sam files";
static const char __pyx_k_file_has_no_sequences_defined_mo[] = "file has no sequences defined (mode='%s') - is it SAM/BAM format? Consider opening with check_seq=True";
static const char __pyx_k_invalid_type_for_record_s_s_expe[] = "invalid type for record %s: %s, expected %s";
static const char __pyx_k_mapping_information_not_recorded[] = "mapping information not recorded in index or index not available";
static const char __pyx_k_multiple_s_lines_are_not_permitt[] = "multiple '%s' lines are not permitted";
static const char __pyx_k_no_index_available_for_iteration[] = "no index available for iteration";
static const char __pyx_k_pileup_of_samfiles_not_implement[] = "pileup of samfiles not implemented yet";
static const char __pyx_k_reference_id_i_out_of_range_0_ti[] = "reference_id %i out of range 0<=tid<%i";
static const char __pyx_k_reference_sequence_for_s_tid_i_n[] = "reference sequence for '%s' (tid=%i) not found";
static const char __pyx_k_seek_only_available_in_bam_files[] = "seek only available in bam files";
static const char __pyx_k_unequal_names_and_lengths_of_ref[] = "unequal names and lengths of reference sequences";
static const char __pyx_k_unknown_stepper_option_s_in_Iter[] = "unknown stepper option `%s` in IteratorColumn";
static const char __pyx_k_file_does_not_have_valid_header_2[] = "file does not have valid header (mode='%s') - is it SAM format?";
static PyObject *__pyx_n_s_A;
static PyObject *__pyx_n_s_AS;
static PyObject *__pyx_n_s_AlignmentFile;
static PyObject *__pyx_kp_s_AlignmentFile_mapped_only_availa;
static PyObject *__pyx_n_s_AttributeError;
static PyObject *__pyx_n_s_C;
static PyObject *__pyx_n_s_CL;
static PyObject *__pyx_n_s_CN;
static PyObject *__pyx_n_s_CO;
static PyObject *__pyx_n_s_DS;
static PyObject *__pyx_n_s_DT;
static PyObject *__pyx_n_s_FO;
static PyObject *__pyx_n_s_G;
static PyObject *__pyx_n_s_GO;
static PyObject *__pyx_n_s_HD;
static PyObject *__pyx_n_s_ID;
static PyObject *__pyx_n_s_IOError;
static PyObject *__pyx_kp_s_I_O_operation_on_closed_file;
static PyObject *__pyx_n_s_IndexedReads;
static PyObject *__pyx_n_s_IteratorColumn;
static PyObject *__pyx_n_s_IteratorRow;
static PyObject *__pyx_n_s_KNOWN_HEADER_FIELDS;
static PyObject *__pyx_n_s_KS;
static PyObject *__pyx_n_s_KeyError;
static PyObject *__pyx_n_s_L;
static PyObject *__pyx_n_s_LB;
static PyObject *__pyx_n_s_LN;
static PyObject *__pyx_n_s_M5;
static PyObject *__pyx_n_s_MemoryError;
static PyObject *__pyx_n_s_NotImplementedError;
static PyObject *__pyx_n_s_OSError;
static PyObject *__pyx_n_s_OverflowError;
static PyObject *__pyx_n_s_PG;
static PyObject *__pyx_n_s_PI;
static PyObject *__pyx_n_s_PL;
static PyObject *__pyx_n_s_PM;
static PyObject *__pyx_n_s_PN;
static PyObject *__pyx_n_s_PP;
static PyObject *__pyx_n_s_PU;
static PyObject *__pyx_n_s_RG;
static PyObject *__pyx_n_s_SM;
static PyObject *__pyx_n_s_SN;
static PyObject *__pyx_n_s_SO;
static PyObject *__pyx_n_s_SP;
static PyObject *__pyx_n_s_SQ;
static PyObject *__pyx_kp_s_SQ_SN_s_LN_s;
static PyObject *__pyx_n_s_StopIteration;
static PyObject *__pyx_n_s_StringIO;
static PyObject *__pyx_n_s_T;
static PyObject *__pyx_n_s_UR;
static PyObject *__pyx_n_s_VALID_HEADERS;
static PyObject *__pyx_n_s_VALID_HEADER_ORDER;
static PyObject *__pyx_n_s_VALID_HEADER_TYPES;
static PyObject *__pyx_n_s_VN;
static PyObject *__pyx_n_s_ValueError;
static PyObject *__pyx_kp_b__12;
static PyObject *__pyx_kp_s__13;
static PyObject *__pyx_kp_s__2;
static PyObject *__pyx_kp_s__23;
static PyObject *__pyx_kp_s__3;
static PyObject *__pyx_kp_s__44;
static PyObject *__pyx_kp_s__50;
static PyObject *__pyx_kp_s_access_from_StringIO_objects_not;
static PyObject *__pyx_n_s_add_sq_text;
static PyObject *__pyx_n_s_all;
static PyObject *__pyx_n_s_all_2;
static PyObject *__pyx_n_s_append;
static PyObject *__pyx_n_s_array;
static PyObject *__pyx_n_s_ascii;
static PyObject *__pyx_n_s_b;
static PyObject *__pyx_kp_b_bai;
static PyObject *__pyx_n_s_beg;
static PyObject *__pyx_n_s_build_header_line;
static PyObject *__pyx_n_s_c;
static PyObject *__pyx_kp_s_can_not_iterate_over_samfile_wit;
static PyObject *__pyx_kp_s_can_only_IndexReads_on_bam_files;
static PyObject *__pyx_n_s_check_header;
static PyObject *__pyx_n_s_check_index;
static PyObject *__pyx_n_s_check_sq;
static PyObject *__pyx_n_s_close;
static PyObject *__pyx_n_s_closed;
static PyObject *__pyx_n_s_collections;
static PyObject *__pyx_n_s_consensus_quality;
static PyObject *__pyx_kp_s_could_not_open_file_mode_s_is_it;
static PyObject *__pyx_kp_s_could_not_open_file_s;
static PyObject *__pyx_n_s_coverage;
static PyObject *__pyx_kp_b_crai;
static PyObject *__pyx_n_s_defaultdict;
static PyObject *__pyx_kp_s_either_supply_options_template_h;
static PyObject *__pyx_n_s_encode;
static PyObject *__pyx_n_s_end;
static PyObject *__pyx_kp_s_end_out_of_range_i;
static PyObject *__pyx_n_s_enumerate;
static PyObject *__pyx_kp_s_error_during_iteration;
static PyObject *__pyx_kp_s_error_while_opening_index_for_s;
static PyObject *__pyx_n_s_exc_type;
static PyObject *__pyx_n_s_exc_value;
static PyObject *__pyx_n_s_exists;
static PyObject *__pyx_n_s_fastafile;
static PyObject *__pyx_n_s_fetch;
static PyObject *__pyx_kp_s_fetch_called_for_htsfile_without;
static PyObject *__pyx_kp_s_fetch_called_on_bamfile_without;
static PyObject *__pyx_kp_s_fetching_by_region_is_not_availa;
static PyObject *__pyx_n_s_fields;
static PyObject *__pyx_kp_s_file_does_not_have_valid_header;
static PyObject *__pyx_kp_s_file_does_not_have_valid_header_2;
static PyObject *__pyx_kp_s_file_has_no_sequences_defined_mo;
static PyObject *__pyx_kp_s_file_s_not_found;
static PyObject *__pyx_n_s_filename;
static PyObject *__pyx_n_s_fileno;
static PyObject *__pyx_n_s_filepath_index;
static PyObject *__pyx_n_s_filepath_or_object;
static PyObject *__pyx_n_s_flag;
static PyObject *__pyx_n_s_genotype;
static PyObject *__pyx_n_s_get;
static PyObject *__pyx_n_s_get_aligned_pairs;
static PyObject *__pyx_n_s_get_reference_name;
static PyObject *__pyx_n_s_get_tid;
static PyObject *__pyx_n_s_gettid;
static PyObject *__pyx_n_s_h;
static PyObject *__pyx_n_s_has_index;
static PyObject *__pyx_n_s_header;
static PyObject *__pyx_kp_s_header_line_with_invalid_type_s;
static PyObject *__pyx_kp_s_header_line_without_s;
static PyObject *__pyx_kp_s_home_vagrant_Downloads_pysam_py;
static PyObject *__pyx_n_s_import;
static PyObject *__pyx_kp_s_incomplete_sequence_information;
static PyObject *__pyx_n_s_init;
static PyObject *__pyx_kp_s_invalid_coordinates_start_i_end;
static PyObject *__pyx_kp_s_invalid_file_opening_mode_s;
static PyObject *__pyx_kp_s_invalid_reference_s;
static PyObject *__pyx_kp_s_invalid_type_for_record_s_s_expe;
static PyObject *__pyx_n_s_io;
static PyObject *__pyx_n_s_is_open;
static PyObject *__pyx_n_s_islower;
static PyObject *__pyx_n_s_isupper;
static PyObject *__pyx_n_s_items;
static PyObject *__pyx_n_s_join;
static PyObject *__pyx_n_s_key;
static PyObject *__pyx_n_s_lengths;
static PyObject *__pyx_n_s_line;
static PyObject *__pyx_n_s_main;
static PyObject *__pyx_kp_s_malformatted_header_no_in_field;
static PyObject *__pyx_n_s_map;
static PyObject *__pyx_kp_s_mapping_information_not_recorded;
static PyObject *__pyx_n_s_mapping_quality;
static PyObject *__pyx_kp_s_mate_not_found;
static PyObject *__pyx_kp_s_mate_s_is_unmapped;
static PyObject *__pyx_n_s_max_depth;
static PyObject *__pyx_n_s_mode;
static PyObject *__pyx_n_s_multiple_iterators;
static PyObject *__pyx_kp_s_multiple_s_lines_are_not_permitt;
static PyObject *__pyx_n_s_n;
static PyObject *__pyx_n_s_name;
static PyObject *__pyx_n_s_nextiter;
static PyObject *__pyx_kp_s_no_index_available_for_fetch;
static PyObject *__pyx_kp_s_no_index_available_for_iteration;
static PyObject *__pyx_kp_s_no_index_available_for_pileup;
static PyObject *__pyx_n_s_nofilter;
static PyObject *__pyx_n_s_nreferences;
static PyObject *__pyx_n_s_offset;
static PyObject *__pyx_n_s_open;
static PyObject *__pyx_n_s_os;
static PyObject *__pyx_n_s_parse_region;
static PyObject *__pyx_n_s_path;
static PyObject *__pyx_kp_s_pileup_of_samfiles_not_implement;
static PyObject *__pyx_n_s_port;
static PyObject *__pyx_n_s_pos;
static PyObject *__pyx_n_s_positions;
static PyObject *__pyx_n_s_pysam_calignmentfile;
static PyObject *__pyx_n_s_pyx_vtable;
static PyObject *__pyx_n_s_quality_threshold;
static PyObject *__pyx_n_s_query_name;
static PyObject *__pyx_n_s_query_qualities;
static PyObject *__pyx_n_s_r;
static PyObject *__pyx_n_s_rU;
static PyObject *__pyx_n_s_rb;
static PyObject *__pyx_n_s_rc;
static PyObject *__pyx_n_s_re;
static PyObject *__pyx_n_s_read_callback;
static PyObject *__pyx_kp_s_read_s_is_unpaired;
static PyObject *__pyx_kp_s_read_s_not_found;
static PyObject *__pyx_n_s_record;
static PyObject *__pyx_n_s_reference;
static PyObject *__pyx_n_s_reference_base;
static PyObject *__pyx_n_s_reference_filename;
static PyObject *__pyx_kp_s_reference_id_i_out_of_range_0_ti;
static PyObject *__pyx_n_s_reference_lengths;
static PyObject *__pyx_n_s_reference_names;
static PyObject *__pyx_kp_s_reference_sequence_for_s_tid_i_n;
static PyObject *__pyx_n_s_referencelengths;
static PyObject *__pyx_n_s_referencenames;
static PyObject *__pyx_n_s_references;
static PyObject *__pyx_n_s_region;
static PyObject *__pyx_kp_s_s;
static PyObject *__pyx_kp_s_s_s;
static PyObject *__pyx_kp_s_sam_write_failed;
static PyObject *__pyx_n_s_samfile;
static PyObject *__pyx_n_s_samtools;
static PyObject *__pyx_n_s_seek;
static PyObject *__pyx_kp_s_seek_no_available_in_streams;
static PyObject *__pyx_kp_s_seek_only_available_in_bam_files;
static PyObject *__pyx_n_s_seq;
static PyObject *__pyx_n_s_snp_quality;
static PyObject *__pyx_n_s_split;
static PyObject *__pyx_n_s_start;
static PyObject *__pyx_kp_s_start_out_of_range_i;
static PyObject *__pyx_n_s_startswith;
static PyObject *__pyx_n_s_stepper;
static PyObject *__pyx_n_s_stringio;
static PyObject *__pyx_n_s_strip;
static PyObject *__pyx_n_s_tell;
static PyObject *__pyx_n_s_template;
static PyObject *__pyx_n_s_test;
static PyObject *__pyx_n_s_text;
static PyObject *__pyx_n_s_tid;
static PyObject *__pyx_n_s_traceback;
static PyObject *__pyx_n_s_truncate;
static PyObject *__pyx_kp_s_truncated_file;
static PyObject *__pyx_kp_s_unable_to_open_index_at_s;
static PyObject *__pyx_kp_s_unable_to_open_remote_index_for;
static PyObject *__pyx_kp_s_unequal_names_and_lengths_of_ref;
static PyObject *__pyx_kp_s_unknown_stepper_option_s_in_Iter;
static PyObject *__pyx_n_s_until_eof;
static PyObject *__pyx_n_s_w;
static PyObject *__pyx_n_s_warn;
static PyObject *__pyx_n_s_warnings;
static PyObject *__pyx_n_s_wb;
static PyObject *__pyx_n_s_wb0;
static PyObject *__pyx_n_s_wbu;
static PyObject *__pyx_n_s_wc;
static PyObject *__pyx_n_s_wh;
static PyObject *__pyx_n_s_where;
static PyObject *__pyx_n_s_write;
static PyObject *__pyx_n_s_zip;
static PyObject *__pyx_pf_5pysam_14calignmentfile_build_header_line(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_fields, PyObject *__pyx_v_record); /* proto */
static int __pyx_pf_5pysam_14calignmentfile_13AlignmentFile___cinit__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_args, PyObject *__pyx_v_kwargs); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_2is_open(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_4has_index(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_6check_index(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_8_open(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_filepath_or_object, PyObject *__pyx_v_mode, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_template, PyObject *__pyx_v_reference_names, PyObject *__pyx_v_reference_lengths, PyObject *__pyx_v_reference_filename, PyObject *__pyx_v_text, PyObject *__pyx_v_header, CYTHON_UNUSED PyObject *__pyx_v_port, PyObject *__pyx_v_add_sq_text, PyObject *__pyx_v_check_header, PyObject *__pyx_v_check_sq, PyObject *__pyx_v_filepath_index, PyObject *__pyx_v_referencenames, PyObject *__pyx_v_referencelengths); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_10get_tid(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_reference); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_12get_reference_name(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_tid); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_14reset(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_16seek(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, uint64_t __pyx_v_offset, int __pyx_v_where); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_18tell(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_20parse_region(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_reference, PyObject *__pyx_v_start, PyObject *__pyx_v_end, PyObject *__pyx_v_region, PyObject *__pyx_v_tid); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_22fetch(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_reference, PyObject *__pyx_v_start, PyObject *__pyx_v_end, PyObject *__pyx_v_region, PyObject *__pyx_v_tid, PyObject *__pyx_v_until_eof, PyObject *__pyx_v_multiple_iterators); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_24head(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_n, PyObject *__pyx_v_multiple_iterators); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_26mate(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *__pyx_v_read); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_28pileup(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_reference, PyObject *__pyx_v_start, PyObject *__pyx_v_end, PyObject *__pyx_v_region, PyObject *__pyx_v_kwargs); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_30count(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_reference, PyObject *__pyx_v_start, PyObject *__pyx_v_end, PyObject *__pyx_v_region, PyObject *__pyx_v_until_eof, PyObject *__pyx_v_read_callback); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_32count_coverage(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_reference, PyObject *__pyx_v_start, PyObject *__pyx_v_end, PyObject *__pyx_v_region, PyObject *__pyx_v_quality_threshold, PyObject *__pyx_v_read_callback); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_34close(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static void __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_36__dealloc__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_38write(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *__pyx_v_read); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_40__enter__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_42__exit__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_exc_type, CYTHON_UNUSED PyObject *__pyx_v_exc_value, CYTHON_UNUSED PyObject *__pyx_v_traceback); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_6closed___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_8filename___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_11nreferences___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_10references___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_7lengths___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_6mapped___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_8unmapped___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_12nocoordinate___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_6format___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_4text___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_6header___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_44__iter__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_46__next__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_48gettid(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_reference); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_50getrname(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_tid); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_6is_bam___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_7is_cram___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_9is_stream___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_9is_remote___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self); /* proto */
static int __pyx_pf_5pysam_14calignmentfile_11IteratorRow___init__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRow *__pyx_v_self, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile, int __pyx_v_multiple_iterators); /* proto */
static void __pyx_pf_5pysam_14calignmentfile_11IteratorRow_2__dealloc__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRow *__pyx_v_self); /* proto */
static int __pyx_pf_5pysam_14calignmentfile_17IteratorRowRegion___init__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *__pyx_v_self, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile, int __pyx_v_tid, int __pyx_v_beg, int __pyx_v_end, int __pyx_v_multiple_iterators); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_17IteratorRowRegion_2__iter__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_17IteratorRowRegion_4__next__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *__pyx_v_self); /* proto */
static void __pyx_pf_5pysam_14calignmentfile_17IteratorRowRegion_6__dealloc__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *__pyx_v_self); /* proto */
static int __pyx_pf_5pysam_14calignmentfile_15IteratorRowHead___init__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead *__pyx_v_self, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile, int __pyx_v_n, int __pyx_v_multiple_iterators); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_15IteratorRowHead_2__iter__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_15IteratorRowHead_4__next__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead *__pyx_v_self); /* proto */
static int __pyx_pf_5pysam_14calignmentfile_14IteratorRowAll___init__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll *__pyx_v_self, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile, int __pyx_v_multiple_iterators); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_14IteratorRowAll_2__iter__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_14IteratorRowAll_4__next__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll *__pyx_v_self); /* proto */
static int __pyx_pf_5pysam_14calignmentfile_18IteratorRowAllRefs___init__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs *__pyx_v_self, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile, PyObject *__pyx_v_multiple_iterators); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_18IteratorRowAllRefs_2nextiter(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_18IteratorRowAllRefs_4__iter__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_18IteratorRowAllRefs_6__next__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs *__pyx_v_self); /* proto */
static int __pyx_pf_5pysam_14calignmentfile_20IteratorRowSelection___init__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *__pyx_v_self, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile, PyObject *__pyx_v_positions, int __pyx_v_multiple_iterators); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_20IteratorRowSelection_2__iter__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_20IteratorRowSelection_4__next__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *__pyx_v_self); /* proto */
static int __pyx_pf_5pysam_14calignmentfile_14IteratorColumn___cinit__(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile, PyObject *__pyx_v_kwargs); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_14IteratorColumn_2__iter__(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_14IteratorColumn_7seq_len___get__(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_14IteratorColumn_4addReference(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self, struct __pyx_obj_5pysam_6cfaidx_Fastafile *__pyx_v_fastafile); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_14IteratorColumn_6hasReference(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self); /* proto */
static void __pyx_pf_5pysam_14calignmentfile_14IteratorColumn_8__dealloc__(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self); /* proto */
static int __pyx_pf_5pysam_14calignmentfile_20IteratorColumnRegion___cinit__(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnRegion *__pyx_v_self, CYTHON_UNUSED struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile, int __pyx_v_tid, int __pyx_v_start, int __pyx_v_end, int __pyx_v_truncate, CYTHON_UNUSED PyObject *__pyx_v_kwargs); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_20IteratorColumnRegion_2__next__(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnRegion *__pyx_v_self); /* proto */
static int __pyx_pf_5pysam_14calignmentfile_21IteratorColumnAllRefs___cinit__(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnAllRefs *__pyx_v_self, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile, CYTHON_UNUSED PyObject *__pyx_v_kwargs); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_21IteratorColumnAllRefs_2__next__(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnAllRefs *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_7SNPCall_3tid___get__(struct __pyx_obj_5pysam_14calignmentfile_SNPCall *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_7SNPCall_3pos___get__(struct __pyx_obj_5pysam_14calignmentfile_SNPCall *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_7SNPCall_14reference_base___get__(struct __pyx_obj_5pysam_14calignmentfile_SNPCall *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_7SNPCall_8genotype___get__(struct __pyx_obj_5pysam_14calignmentfile_SNPCall *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_7SNPCall_17consensus_quality___get__(struct __pyx_obj_5pysam_14calignmentfile_SNPCall *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_7SNPCall_11snp_quality___get__(struct __pyx_obj_5pysam_14calignmentfile_SNPCall *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_7SNPCall_15mapping_quality___get__(struct __pyx_obj_5pysam_14calignmentfile_SNPCall *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_7SNPCall_8coverage___get__(struct __pyx_obj_5pysam_14calignmentfile_SNPCall *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_7SNPCall___str__(struct __pyx_obj_5pysam_14calignmentfile_SNPCall *__pyx_v_self); /* proto */
static int __pyx_pf_5pysam_14calignmentfile_12IndexedReads___init__(struct __pyx_obj_5pysam_14calignmentfile_IndexedReads *__pyx_v_self, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile, int __pyx_v_multiple_iterators); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_12IndexedReads_2build(struct __pyx_obj_5pysam_14calignmentfile_IndexedReads *__pyx_v_self); /* proto */
static PyObject *__pyx_pf_5pysam_14calignmentfile_12IndexedReads_4find(struct __pyx_obj_5pysam_14calignmentfile_IndexedReads *__pyx_v_self, PyObject *__pyx_v_query_name); /* proto */
static void __pyx_pf_5pysam_14calignmentfile_12IndexedReads_6__dealloc__(struct __pyx_obj_5pysam_14calignmentfile_IndexedReads *__pyx_v_self); /* proto */
static int __pyx_pf_7cpython_5array_5array___getbuffer__(arrayobject *__pyx_v_self, Py_buffer *__pyx_v_info, CYTHON_UNUSED int __pyx_v_flags); /* proto */
static void __pyx_pf_7cpython_5array_5array_2__releasebuffer__(CYTHON_UNUSED arrayobject *__pyx_v_self, Py_buffer *__pyx_v_info); /* proto */
static PyObject *__pyx_tp_new_5pysam_14calignmentfile_AlignmentFile(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_5pysam_14calignmentfile_PileupColumn(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_5pysam_14calignmentfile_PileupRead(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_5pysam_14calignmentfile_IteratorRow(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_5pysam_14calignmentfile_IteratorRowRegion(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_5pysam_14calignmentfile_IteratorRowHead(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_5pysam_14calignmentfile_IteratorRowAll(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_5pysam_14calignmentfile_IteratorRowAllRefs(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_5pysam_14calignmentfile_IteratorRowSelection(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_5pysam_14calignmentfile_IteratorColumn(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_5pysam_14calignmentfile_IteratorColumnRegion(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_5pysam_14calignmentfile_IteratorColumnAllRefs(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_5pysam_14calignmentfile_IndexedReads(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_tp_new_5pysam_14calignmentfile_SNPCall(PyTypeObject *t, PyObject *a, PyObject *k); /*proto*/
static PyObject *__pyx_int_0;
static PyObject *__pyx_int_1;
static PyObject *__pyx_int_15;
static PyObject *__pyx_int_1796;
static PyObject *__pyx_int_8000;
static PyObject *__pyx_int_536870912;
static PyObject *__pyx_int_neg_4;
static PyObject *__pyx_int_neg_5;
static int __pyx_k__64;
static PyObject *__pyx_codeobj_;
static PyObject *__pyx_tuple__4;
static PyObject *__pyx_tuple__5;
static PyObject *__pyx_tuple__6;
static PyObject *__pyx_tuple__7;
static PyObject *__pyx_tuple__8;
static PyObject *__pyx_tuple__9;
static PyObject *__pyx_slice__14;
static PyObject *__pyx_slice__15;
static PyObject *__pyx_slice__46;
static PyObject *__pyx_slice__48;
static PyObject *__pyx_slice__49;
static PyObject *__pyx_tuple__10;
static PyObject *__pyx_tuple__11;
static PyObject *__pyx_tuple__16;
static PyObject *__pyx_tuple__17;
static PyObject *__pyx_tuple__18;
static PyObject *__pyx_tuple__19;
static PyObject *__pyx_tuple__20;
static PyObject *__pyx_tuple__21;
static PyObject *__pyx_tuple__22;
static PyObject *__pyx_tuple__24;
static PyObject *__pyx_tuple__25;
static PyObject *__pyx_tuple__26;
static PyObject *__pyx_tuple__27;
static PyObject *__pyx_tuple__28;
static PyObject *__pyx_tuple__29;
static PyObject *__pyx_tuple__30;
static PyObject *__pyx_tuple__31;
static PyObject *__pyx_tuple__32;
static PyObject *__pyx_tuple__33;
static PyObject *__pyx_tuple__34;
static PyObject *__pyx_tuple__35;
static PyObject *__pyx_tuple__36;
static PyObject *__pyx_tuple__37;
static PyObject *__pyx_tuple__38;
static PyObject *__pyx_tuple__39;
static PyObject *__pyx_tuple__40;
static PyObject *__pyx_tuple__41;
static PyObject *__pyx_tuple__42;
static PyObject *__pyx_tuple__43;
static PyObject *__pyx_tuple__45;
static PyObject *__pyx_tuple__47;
static PyObject *__pyx_tuple__51;
static PyObject *__pyx_tuple__52;
static PyObject *__pyx_tuple__53;
static PyObject *__pyx_tuple__54;
static PyObject *__pyx_tuple__55;
static PyObject *__pyx_tuple__56;
static PyObject *__pyx_tuple__57;
static PyObject *__pyx_tuple__58;
static PyObject *__pyx_tuple__59;
static PyObject *__pyx_tuple__60;
static PyObject *__pyx_tuple__61;
static PyObject *__pyx_tuple__62;
static PyObject *__pyx_tuple__63;
static PyObject *__pyx_tuple__65;
static PyObject *__pyx_tuple__66;
static PyObject *__pyx_tuple__67;
static PyObject *__pyx_tuple__68;
static PyObject *__pyx_tuple__69;
static PyObject *__pyx_tuple__70;
static PyObject *__pyx_tuple__71;
static PyObject *__pyx_tuple__72;

/* "pysam/calignmentfile.pyx":120
 * 
 * 
 * def build_header_line(fields, record):             # <<<<<<<<<<<<<<
 *     '''build a header line from `fields` dictionary for `record`'''
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_1build_header_line(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_build_header_line[] = "build_header_line(fields, record)\nbuild a header line from `fields` dictionary for `record`";
static PyMethodDef __pyx_mdef_5pysam_14calignmentfile_1build_header_line = {"build_header_line", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_1build_header_line, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pysam_14calignmentfile_build_header_line};
static PyObject *__pyx_pw_5pysam_14calignmentfile_1build_header_line(PyObject *__pyx_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_fields = 0;
  PyObject *__pyx_v_record = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("build_header_line (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_fields,&__pyx_n_s_record,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_fields)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_record)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("build_header_line", 1, 2, 2, 1); __PYX_ERR(0, 120, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "build_header_line") < 0)) __PYX_ERR(0, 120, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
    }
    __pyx_v_fields = values[0];
    __pyx_v_record = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("build_header_line", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 120, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.build_header_line", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_build_header_line(__pyx_self, __pyx_v_fields, __pyx_v_record);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_build_header_line(CYTHON_UNUSED PyObject *__pyx_self, PyObject *__pyx_v_fields, PyObject *__pyx_v_record) {
  PyObject *__pyx_v_line = NULL;
  PyObject *__pyx_v_key = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  Py_ssize_t __pyx_t_6;
  PyObject *(*__pyx_t_7)(PyObject *);
  int __pyx_t_8;
  PyObject *__pyx_t_9 = NULL;
  __Pyx_TraceFrameInit(__pyx_codeobj_)
  __Pyx_RefNannySetupContext("build_header_line", 0);
  __Pyx_TraceCall("build_header_line", __pyx_f[0], 120, 0, __PYX_ERR(0, 120, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":124
 * 
 *     # TODO: add checking for field and sort order
 *     line = ["@%s" % record]             # <<<<<<<<<<<<<<
 *         # comment
 *     if record == "CO":
 */
  __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_s, __pyx_v_record); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 124, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyList_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 124, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_1);
  PyList_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_v_line = ((PyObject*)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "pysam/calignmentfile.pyx":126
 *     line = ["@%s" % record]
 *         # comment
 *     if record == "CO":             # <<<<<<<<<<<<<<
 *         line.append(fields)
 *     # user tags
 */
  __pyx_t_3 = (__Pyx_PyString_Equals(__pyx_v_record, __pyx_n_s_CO, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 126, __pyx_L1_error)
  if (__pyx_t_3) {

    /* "pysam/calignmentfile.pyx":127
 *         # comment
 *     if record == "CO":
 *         line.append(fields)             # <<<<<<<<<<<<<<
 *     # user tags
 *     elif record.islower():
 */
    __pyx_t_4 = __Pyx_PyList_Append(__pyx_v_line, __pyx_v_fields); if (unlikely(__pyx_t_4 == -1)) __PYX_ERR(0, 127, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":126
 *     line = ["@%s" % record]
 *         # comment
 *     if record == "CO":             # <<<<<<<<<<<<<<
 *         line.append(fields)
 *     # user tags
 */
    goto __pyx_L3;
  }

  /* "pysam/calignmentfile.pyx":129
 *         line.append(fields)
 *     # user tags
 *     elif record.islower():             # <<<<<<<<<<<<<<
 *         for key in sorted(fields):
 *             line.append("%s:%s" % (key, str(fields[key])))
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_record, __pyx_n_s_islower); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 129, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_5 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_5)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_5);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
    }
  }
  if (__pyx_t_5) {
    __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 129, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  } else {
    __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 129, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 129, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (__pyx_t_3) {

    /* "pysam/calignmentfile.pyx":130
 *     # user tags
 *     elif record.islower():
 *         for key in sorted(fields):             # <<<<<<<<<<<<<<
 *             line.append("%s:%s" % (key, str(fields[key])))
 *     # defined tags
 */
    __pyx_t_1 = PySequence_List(__pyx_v_fields); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 130, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = ((PyObject*)__pyx_t_1);
    __pyx_t_1 = 0;
    __pyx_t_4 = PyList_Sort(__pyx_t_2); if (unlikely(__pyx_t_4 == -1)) __PYX_ERR(0, 130, __pyx_L1_error)
    if (unlikely(__pyx_t_2 == Py_None)) {
      PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
      __PYX_ERR(0, 130, __pyx_L1_error)
    }
    __pyx_t_1 = __pyx_t_2; __Pyx_INCREF(__pyx_t_1); __pyx_t_6 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    for (;;) {
      if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_1)) break;
      #if CYTHON_COMPILING_IN_CPYTHON
      __pyx_t_2 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_6); __Pyx_INCREF(__pyx_t_2); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 130, __pyx_L1_error)
      #else
      __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 130, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      #endif
      __Pyx_XDECREF_SET(__pyx_v_key, __pyx_t_2);
      __pyx_t_2 = 0;

      /* "pysam/calignmentfile.pyx":131
 *     elif record.islower():
 *         for key in sorted(fields):
 *             line.append("%s:%s" % (key, str(fields[key])))             # <<<<<<<<<<<<<<
 *     # defined tags
 *     else:
 */
      __pyx_t_2 = PyObject_GetItem(__pyx_v_fields, __pyx_v_key); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 131, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 131, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_GIVEREF(__pyx_t_2);
      PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2);
      __pyx_t_2 = 0;
      __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)(&PyString_Type)), __pyx_t_5, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 131, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 131, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_INCREF(__pyx_v_key);
      __Pyx_GIVEREF(__pyx_v_key);
      PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_key);
      __Pyx_GIVEREF(__pyx_t_2);
      PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_2);
      __pyx_t_2 = 0;
      __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_s_s, __pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 131, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_4 = __Pyx_PyList_Append(__pyx_v_line, __pyx_t_2); if (unlikely(__pyx_t_4 == -1)) __PYX_ERR(0, 131, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

      /* "pysam/calignmentfile.pyx":130
 *     # user tags
 *     elif record.islower():
 *         for key in sorted(fields):             # <<<<<<<<<<<<<<
 *             line.append("%s:%s" % (key, str(fields[key])))
 *     # defined tags
 */
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "pysam/calignmentfile.pyx":129
 *         line.append(fields)
 *     # user tags
 *     elif record.islower():             # <<<<<<<<<<<<<<
 *         for key in sorted(fields):
 *             line.append("%s:%s" % (key, str(fields[key])))
 */
    goto __pyx_L3;
  }

  /* "pysam/calignmentfile.pyx":135
 *     else:
 *         # write fields of the specification
 *         for key in VALID_HEADER_ORDER[record]:             # <<<<<<<<<<<<<<
 *             if key in fields:
 *                 line.append("%s:%s" % (key, str(fields[key])))
 */
  /*else*/ {
    __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_VALID_HEADER_ORDER); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 135, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = PyObject_GetItem(__pyx_t_1, __pyx_v_record); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 135, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (likely(PyList_CheckExact(__pyx_t_2)) || PyTuple_CheckExact(__pyx_t_2)) {
      __pyx_t_1 = __pyx_t_2; __Pyx_INCREF(__pyx_t_1); __pyx_t_6 = 0;
      __pyx_t_7 = NULL;
    } else {
      __pyx_t_6 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 135, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_7 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 135, __pyx_L1_error)
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    for (;;) {
      if (likely(!__pyx_t_7)) {
        if (likely(PyList_CheckExact(__pyx_t_1))) {
          if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_1)) break;
          #if CYTHON_COMPILING_IN_CPYTHON
          __pyx_t_2 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_6); __Pyx_INCREF(__pyx_t_2); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 135, __pyx_L1_error)
          #else
          __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 135, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          #endif
        } else {
          if (__pyx_t_6 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
          #if CYTHON_COMPILING_IN_CPYTHON
          __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_6); __Pyx_INCREF(__pyx_t_2); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 135, __pyx_L1_error)
          #else
          __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 135, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          #endif
        }
      } else {
        __pyx_t_2 = __pyx_t_7(__pyx_t_1);
        if (unlikely(!__pyx_t_2)) {
          PyObject* exc_type = PyErr_Occurred();
          if (exc_type) {
            if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
            else __PYX_ERR(0, 135, __pyx_L1_error)
          }
          break;
        }
        __Pyx_GOTREF(__pyx_t_2);
      }
      __Pyx_XDECREF_SET(__pyx_v_key, __pyx_t_2);
      __pyx_t_2 = 0;

      /* "pysam/calignmentfile.pyx":136
 *         # write fields of the specification
 *         for key in VALID_HEADER_ORDER[record]:
 *             if key in fields:             # <<<<<<<<<<<<<<
 *                 line.append("%s:%s" % (key, str(fields[key])))
 *         # write user fields
 */
      __pyx_t_3 = (__Pyx_PySequence_ContainsTF(__pyx_v_key, __pyx_v_fields, Py_EQ)); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 136, __pyx_L1_error)
      __pyx_t_8 = (__pyx_t_3 != 0);
      if (__pyx_t_8) {

        /* "pysam/calignmentfile.pyx":137
 *         for key in VALID_HEADER_ORDER[record]:
 *             if key in fields:
 *                 line.append("%s:%s" % (key, str(fields[key])))             # <<<<<<<<<<<<<<
 *         # write user fields
 *         for key in fields:
 */
        __pyx_t_2 = PyObject_GetItem(__pyx_v_fields, __pyx_v_key); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 137, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 137, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_GIVEREF(__pyx_t_2);
        PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2);
        __pyx_t_2 = 0;
        __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)(&PyString_Type)), __pyx_t_5, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 137, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 137, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_INCREF(__pyx_v_key);
        __Pyx_GIVEREF(__pyx_v_key);
        PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_key);
        __Pyx_GIVEREF(__pyx_t_2);
        PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_2);
        __pyx_t_2 = 0;
        __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_s_s, __pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 137, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __pyx_t_4 = __Pyx_PyList_Append(__pyx_v_line, __pyx_t_2); if (unlikely(__pyx_t_4 == -1)) __PYX_ERR(0, 137, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

        /* "pysam/calignmentfile.pyx":136
 *         # write fields of the specification
 *         for key in VALID_HEADER_ORDER[record]:
 *             if key in fields:             # <<<<<<<<<<<<<<
 *                 line.append("%s:%s" % (key, str(fields[key])))
 *         # write user fields
 */
      }

      /* "pysam/calignmentfile.pyx":135
 *     else:
 *         # write fields of the specification
 *         for key in VALID_HEADER_ORDER[record]:             # <<<<<<<<<<<<<<
 *             if key in fields:
 *                 line.append("%s:%s" % (key, str(fields[key])))
 */
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "pysam/calignmentfile.pyx":139
 *                 line.append("%s:%s" % (key, str(fields[key])))
 *         # write user fields
 *         for key in fields:             # <<<<<<<<<<<<<<
 *             if not key.isupper():
 *                 line.append("%s:%s" % (key, str(fields[key])))
 */
    if (likely(PyList_CheckExact(__pyx_v_fields)) || PyTuple_CheckExact(__pyx_v_fields)) {
      __pyx_t_1 = __pyx_v_fields; __Pyx_INCREF(__pyx_t_1); __pyx_t_6 = 0;
      __pyx_t_7 = NULL;
    } else {
      __pyx_t_6 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_v_fields); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 139, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_7 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 139, __pyx_L1_error)
    }
    for (;;) {
      if (likely(!__pyx_t_7)) {
        if (likely(PyList_CheckExact(__pyx_t_1))) {
          if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_1)) break;
          #if CYTHON_COMPILING_IN_CPYTHON
          __pyx_t_2 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_6); __Pyx_INCREF(__pyx_t_2); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 139, __pyx_L1_error)
          #else
          __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 139, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          #endif
        } else {
          if (__pyx_t_6 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
          #if CYTHON_COMPILING_IN_CPYTHON
          __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_6); __Pyx_INCREF(__pyx_t_2); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 139, __pyx_L1_error)
          #else
          __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 139, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          #endif
        }
      } else {
        __pyx_t_2 = __pyx_t_7(__pyx_t_1);
        if (unlikely(!__pyx_t_2)) {
          PyObject* exc_type = PyErr_Occurred();
          if (exc_type) {
            if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
            else __PYX_ERR(0, 139, __pyx_L1_error)
          }
          break;
        }
        __Pyx_GOTREF(__pyx_t_2);
      }
      __Pyx_XDECREF_SET(__pyx_v_key, __pyx_t_2);
      __pyx_t_2 = 0;

      /* "pysam/calignmentfile.pyx":140
 *         # write user fields
 *         for key in fields:
 *             if not key.isupper():             # <<<<<<<<<<<<<<
 *                 line.append("%s:%s" % (key, str(fields[key])))
 * 
 */
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_v_key, __pyx_n_s_isupper); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 140, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_9 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_5))) {
        __pyx_t_9 = PyMethod_GET_SELF(__pyx_t_5);
        if (likely(__pyx_t_9)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
          __Pyx_INCREF(__pyx_t_9);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_5, function);
        }
      }
      if (__pyx_t_9) {
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_9); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 140, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      } else {
        __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 140, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_8 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_8 < 0)) __PYX_ERR(0, 140, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_3 = ((!__pyx_t_8) != 0);
      if (__pyx_t_3) {

        /* "pysam/calignmentfile.pyx":141
 *         for key in fields:
 *             if not key.isupper():
 *                 line.append("%s:%s" % (key, str(fields[key])))             # <<<<<<<<<<<<<<
 * 
 *     return "\t".join(line)
 */
        __pyx_t_2 = PyObject_GetItem(__pyx_v_fields, __pyx_v_key); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 141, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 141, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_GIVEREF(__pyx_t_2);
        PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_2);
        __pyx_t_2 = 0;
        __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)(&PyString_Type)), __pyx_t_5, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 141, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 141, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_INCREF(__pyx_v_key);
        __Pyx_GIVEREF(__pyx_v_key);
        PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_v_key);
        __Pyx_GIVEREF(__pyx_t_2);
        PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_2);
        __pyx_t_2 = 0;
        __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_s_s, __pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 141, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __pyx_t_4 = __Pyx_PyList_Append(__pyx_v_line, __pyx_t_2); if (unlikely(__pyx_t_4 == -1)) __PYX_ERR(0, 141, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

        /* "pysam/calignmentfile.pyx":140
 *         # write user fields
 *         for key in fields:
 *             if not key.isupper():             # <<<<<<<<<<<<<<
 *                 line.append("%s:%s" % (key, str(fields[key])))
 * 
 */
      }

      /* "pysam/calignmentfile.pyx":139
 *                 line.append("%s:%s" % (key, str(fields[key])))
 *         # write user fields
 *         for key in fields:             # <<<<<<<<<<<<<<
 *             if not key.isupper():
 *                 line.append("%s:%s" % (key, str(fields[key])))
 */
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }
  __pyx_L3:;

  /* "pysam/calignmentfile.pyx":143
 *                 line.append("%s:%s" % (key, str(fields[key])))
 * 
 *     return "\t".join(line)             # <<<<<<<<<<<<<<
 * 
 * cdef bam_hdr_t * build_header(new_header):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyString_Join(__pyx_kp_s__2, __pyx_v_line); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 143, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":120
 * 
 * 
 * def build_header_line(fields, record):             # <<<<<<<<<<<<<<
 *     '''build a header line from `fields` dictionary for `record`'''
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("pysam.calignmentfile.build_header_line", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_line);
  __Pyx_XDECREF(__pyx_v_key);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":145
 *     return "\t".join(line)
 * 
 * cdef bam_hdr_t * build_header(new_header):             # <<<<<<<<<<<<<<
 *     '''return a new header built from a dictionary in `new_header`.
 * 
 */

static bam_hdr_t *__pyx_f_5pysam_14calignmentfile_build_header(PyObject *__pyx_v_new_header) {
  PyObject *__pyx_v_lines = NULL;
  bam_hdr_t *__pyx_v_dest;
  PyObject *__pyx_v_record = NULL;
  PyObject *__pyx_v_ttype = NULL;
  PyObject *__pyx_v_data = NULL;
  PyObject *__pyx_v_fields = NULL;
  PyObject *__pyx_v_text = NULL;
  PyObject *__pyx_v_btext = 0;
  PyObject *__pyx_v_bseqname = 0;
  PyObject *__pyx_v_seqs = NULL;
  long __pyx_v_x;
  PyObject *__pyx_v_seqname = NULL;
  PyObject *__pyx_v_seqlen = NULL;
  bam_hdr_t *__pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  Py_ssize_t __pyx_t_3;
  PyObject *(*__pyx_t_4)(PyObject *);
  int __pyx_t_5;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  Py_ssize_t __pyx_t_9;
  PyObject *__pyx_t_10 = NULL;
  int __pyx_t_11;
  PyObject *(*__pyx_t_12)(PyObject *);
  Py_ssize_t __pyx_t_13;
  PyObject *__pyx_t_14 = NULL;
  PyObject *(*__pyx_t_15)(PyObject *);
  char const *__pyx_t_16;
  PyObject *__pyx_t_17 = NULL;
  PyObject *__pyx_t_18 = NULL;
  PyObject *__pyx_t_19 = NULL;
  int __pyx_t_20;
  int32_t __pyx_t_21;
  uint32_t __pyx_t_22;
  __Pyx_RefNannySetupContext("build_header", 0);
  __Pyx_TraceCall("build_header", __pyx_f[0], 145, 0, __PYX_ERR(0, 145, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":151
 *     '''
 * 
 *     lines = []             # <<<<<<<<<<<<<<
 * 
 *     # check if hash exists
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 151, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_lines = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pysam/calignmentfile.pyx":158
 *     cdef bam_hdr_t * dest
 * 
 *     dest = bam_hdr_init()             # <<<<<<<<<<<<<<
 * 
 *     # first: defined tags
 */
  __pyx_v_dest = bam_hdr_init();

  /* "pysam/calignmentfile.pyx":161
 * 
 *     # first: defined tags
 *     for record in VALID_HEADERS:             # <<<<<<<<<<<<<<
 *         if record in new_header:
 *             ttype = VALID_HEADER_TYPES[record]
 */
  __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_VALID_HEADERS); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 161, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (likely(PyList_CheckExact(__pyx_t_1)) || PyTuple_CheckExact(__pyx_t_1)) {
    __pyx_t_2 = __pyx_t_1; __Pyx_INCREF(__pyx_t_2); __pyx_t_3 = 0;
    __pyx_t_4 = NULL;
  } else {
    __pyx_t_3 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 161, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 161, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  for (;;) {
    if (likely(!__pyx_t_4)) {
      if (likely(PyList_CheckExact(__pyx_t_2))) {
        if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_2)) break;
        #if CYTHON_COMPILING_IN_CPYTHON
        __pyx_t_1 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 161, __pyx_L1_error)
        #else
        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 161, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        #endif
      } else {
        if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
        #if CYTHON_COMPILING_IN_CPYTHON
        __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 161, __pyx_L1_error)
        #else
        __pyx_t_1 = PySequence_ITEM(__pyx_t_2, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 161, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        #endif
      }
    } else {
      __pyx_t_1 = __pyx_t_4(__pyx_t_2);
      if (unlikely(!__pyx_t_1)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 161, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_1);
    }
    __Pyx_XDECREF_SET(__pyx_v_record, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "pysam/calignmentfile.pyx":162
 *     # first: defined tags
 *     for record in VALID_HEADERS:
 *         if record in new_header:             # <<<<<<<<<<<<<<
 *             ttype = VALID_HEADER_TYPES[record]
 *             data = new_header[record]
 */
    __pyx_t_5 = (__Pyx_PySequence_ContainsTF(__pyx_v_record, __pyx_v_new_header, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 162, __pyx_L1_error)
    __pyx_t_6 = (__pyx_t_5 != 0);
    if (__pyx_t_6) {

      /* "pysam/calignmentfile.pyx":163
 *     for record in VALID_HEADERS:
 *         if record in new_header:
 *             ttype = VALID_HEADER_TYPES[record]             # <<<<<<<<<<<<<<
 *             data = new_header[record]
 *             if type(data) != type(ttype()):
 */
      __pyx_t_1 = __Pyx_GetModuleGlobalName(__pyx_n_s_VALID_HEADER_TYPES); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 163, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_7 = PyObject_GetItem(__pyx_t_1, __pyx_v_record); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 163, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_XDECREF_SET(__pyx_v_ttype, __pyx_t_7);
      __pyx_t_7 = 0;

      /* "pysam/calignmentfile.pyx":164
 *         if record in new_header:
 *             ttype = VALID_HEADER_TYPES[record]
 *             data = new_header[record]             # <<<<<<<<<<<<<<
 *             if type(data) != type(ttype()):
 *                 raise ValueError(
 */
      __pyx_t_7 = PyObject_GetItem(__pyx_v_new_header, __pyx_v_record); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 164, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_XDECREF_SET(__pyx_v_data, __pyx_t_7);
      __pyx_t_7 = 0;

      /* "pysam/calignmentfile.pyx":165
 *             ttype = VALID_HEADER_TYPES[record]
 *             data = new_header[record]
 *             if type(data) != type(ttype()):             # <<<<<<<<<<<<<<
 *                 raise ValueError(
 *                     "invalid type for record %s: %s, expected %s" %
 */
      __Pyx_INCREF(__pyx_v_ttype);
      __pyx_t_1 = __pyx_v_ttype; __pyx_t_8 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_1))) {
        __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_1);
        if (likely(__pyx_t_8)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
          __Pyx_INCREF(__pyx_t_8);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_1, function);
        }
      }
      if (__pyx_t_8) {
        __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_8); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 165, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      } else {
        __pyx_t_7 = __Pyx_PyObject_CallNoArg(__pyx_t_1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 165, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_1 = PyObject_RichCompare(((PyObject *)Py_TYPE(__pyx_v_data)), ((PyObject *)Py_TYPE(__pyx_t_7)), Py_NE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 165, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_6 < 0)) __PYX_ERR(0, 165, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (__pyx_t_6) {

        /* "pysam/calignmentfile.pyx":168
 *                 raise ValueError(
 *                     "invalid type for record %s: %s, expected %s" %
 *                     (record, type(data), type(ttype())))             # <<<<<<<<<<<<<<
 *             if type(data) is dict:
 *                 lines.append(build_header_line(data, record))
 */
        __Pyx_INCREF(__pyx_v_ttype);
        __pyx_t_7 = __pyx_v_ttype; __pyx_t_8 = NULL;
        if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_7))) {
          __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
          if (likely(__pyx_t_8)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
            __Pyx_INCREF(__pyx_t_8);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_7, function);
          }
        }
        if (__pyx_t_8) {
          __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_7, __pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 168, __pyx_L1_error)
          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
        } else {
          __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 168, __pyx_L1_error)
        }
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        __pyx_t_7 = PyTuple_New(3); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 168, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_INCREF(__pyx_v_record);
        __Pyx_GIVEREF(__pyx_v_record);
        PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_v_record);
        __Pyx_INCREF(((PyObject *)Py_TYPE(__pyx_v_data)));
        __Pyx_GIVEREF(((PyObject *)Py_TYPE(__pyx_v_data)));
        PyTuple_SET_ITEM(__pyx_t_7, 1, ((PyObject *)Py_TYPE(__pyx_v_data)));
        __Pyx_INCREF(((PyObject *)Py_TYPE(__pyx_t_1)));
        __Pyx_GIVEREF(((PyObject *)Py_TYPE(__pyx_t_1)));
        PyTuple_SET_ITEM(__pyx_t_7, 2, ((PyObject *)Py_TYPE(__pyx_t_1)));
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "pysam/calignmentfile.pyx":167
 *             if type(data) != type(ttype()):
 *                 raise ValueError(
 *                     "invalid type for record %s: %s, expected %s" %             # <<<<<<<<<<<<<<
 *                     (record, type(data), type(ttype())))
 *             if type(data) is dict:
 */
        __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_invalid_type_for_record_s_s_expe, __pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 167, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

        /* "pysam/calignmentfile.pyx":166
 *             data = new_header[record]
 *             if type(data) != type(ttype()):
 *                 raise ValueError(             # <<<<<<<<<<<<<<
 *                     "invalid type for record %s: %s, expected %s" %
 *                     (record, type(data), type(ttype())))
 */
        __pyx_t_7 = PyTuple_New(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 166, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_GIVEREF(__pyx_t_1);
        PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_1);
        __pyx_t_1 = 0;
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 166, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_Raise(__pyx_t_1, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __PYX_ERR(0, 166, __pyx_L1_error)

        /* "pysam/calignmentfile.pyx":165
 *             ttype = VALID_HEADER_TYPES[record]
 *             data = new_header[record]
 *             if type(data) != type(ttype()):             # <<<<<<<<<<<<<<
 *                 raise ValueError(
 *                     "invalid type for record %s: %s, expected %s" %
 */
      }

      /* "pysam/calignmentfile.pyx":169
 *                     "invalid type for record %s: %s, expected %s" %
 *                     (record, type(data), type(ttype())))
 *             if type(data) is dict:             # <<<<<<<<<<<<<<
 *                 lines.append(build_header_line(data, record))
 *             else:
 */
      __pyx_t_6 = (((PyObject *)Py_TYPE(__pyx_v_data)) == ((PyObject *)(&PyDict_Type)));
      __pyx_t_5 = (__pyx_t_6 != 0);
      if (__pyx_t_5) {

        /* "pysam/calignmentfile.pyx":170
 *                     (record, type(data), type(ttype())))
 *             if type(data) is dict:
 *                 lines.append(build_header_line(data, record))             # <<<<<<<<<<<<<<
 *             else:
 *                 for fields in new_header[record]:
 */
        __pyx_t_7 = __Pyx_GetModuleGlobalName(__pyx_n_s_build_header_line); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 170, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_7);
        __pyx_t_8 = NULL;
        __pyx_t_9 = 0;
        if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_7))) {
          __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_7);
          if (likely(__pyx_t_8)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_7);
            __Pyx_INCREF(__pyx_t_8);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_7, function);
            __pyx_t_9 = 1;
          }
        }
        __pyx_t_10 = PyTuple_New(2+__pyx_t_9); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 170, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_10);
        if (__pyx_t_8) {
          __Pyx_GIVEREF(__pyx_t_8); PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_8); __pyx_t_8 = NULL;
        }
        __Pyx_INCREF(__pyx_v_data);
        __Pyx_GIVEREF(__pyx_v_data);
        PyTuple_SET_ITEM(__pyx_t_10, 0+__pyx_t_9, __pyx_v_data);
        __Pyx_INCREF(__pyx_v_record);
        __Pyx_GIVEREF(__pyx_v_record);
        PyTuple_SET_ITEM(__pyx_t_10, 1+__pyx_t_9, __pyx_v_record);
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_7, __pyx_t_10, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 170, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        __pyx_t_11 = __Pyx_PyList_Append(__pyx_v_lines, __pyx_t_1); if (unlikely(__pyx_t_11 == -1)) __PYX_ERR(0, 170, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

        /* "pysam/calignmentfile.pyx":169
 *                     "invalid type for record %s: %s, expected %s" %
 *                     (record, type(data), type(ttype())))
 *             if type(data) is dict:             # <<<<<<<<<<<<<<
 *                 lines.append(build_header_line(data, record))
 *             else:
 */
        goto __pyx_L7;
      }

      /* "pysam/calignmentfile.pyx":172
 *                 lines.append(build_header_line(data, record))
 *             else:
 *                 for fields in new_header[record]:             # <<<<<<<<<<<<<<
 *                     lines.append(build_header_line(fields, record))
 * 
 */
      /*else*/ {
        __pyx_t_1 = PyObject_GetItem(__pyx_v_new_header, __pyx_v_record); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 172, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        if (likely(PyList_CheckExact(__pyx_t_1)) || PyTuple_CheckExact(__pyx_t_1)) {
          __pyx_t_7 = __pyx_t_1; __Pyx_INCREF(__pyx_t_7); __pyx_t_9 = 0;
          __pyx_t_12 = NULL;
        } else {
          __pyx_t_9 = -1; __pyx_t_7 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 172, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_7);
          __pyx_t_12 = Py_TYPE(__pyx_t_7)->tp_iternext; if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 172, __pyx_L1_error)
        }
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        for (;;) {
          if (likely(!__pyx_t_12)) {
            if (likely(PyList_CheckExact(__pyx_t_7))) {
              if (__pyx_t_9 >= PyList_GET_SIZE(__pyx_t_7)) break;
              #if CYTHON_COMPILING_IN_CPYTHON
              __pyx_t_1 = PyList_GET_ITEM(__pyx_t_7, __pyx_t_9); __Pyx_INCREF(__pyx_t_1); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 172, __pyx_L1_error)
              #else
              __pyx_t_1 = PySequence_ITEM(__pyx_t_7, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 172, __pyx_L1_error)
              __Pyx_GOTREF(__pyx_t_1);
              #endif
            } else {
              if (__pyx_t_9 >= PyTuple_GET_SIZE(__pyx_t_7)) break;
              #if CYTHON_COMPILING_IN_CPYTHON
              __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_7, __pyx_t_9); __Pyx_INCREF(__pyx_t_1); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 172, __pyx_L1_error)
              #else
              __pyx_t_1 = PySequence_ITEM(__pyx_t_7, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 172, __pyx_L1_error)
              __Pyx_GOTREF(__pyx_t_1);
              #endif
            }
          } else {
            __pyx_t_1 = __pyx_t_12(__pyx_t_7);
            if (unlikely(!__pyx_t_1)) {
              PyObject* exc_type = PyErr_Occurred();
              if (exc_type) {
                if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
                else __PYX_ERR(0, 172, __pyx_L1_error)
              }
              break;
            }
            __Pyx_GOTREF(__pyx_t_1);
          }
          __Pyx_XDECREF_SET(__pyx_v_fields, __pyx_t_1);
          __pyx_t_1 = 0;

          /* "pysam/calignmentfile.pyx":173
 *             else:
 *                 for fields in new_header[record]:
 *                     lines.append(build_header_line(fields, record))             # <<<<<<<<<<<<<<
 * 
 *     # then: user tags (lower case), sorted alphabetically
 */
          __pyx_t_10 = __Pyx_GetModuleGlobalName(__pyx_n_s_build_header_line); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 173, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_10);
          __pyx_t_8 = NULL;
          __pyx_t_13 = 0;
          if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_10))) {
            __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_10);
            if (likely(__pyx_t_8)) {
              PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_10);
              __Pyx_INCREF(__pyx_t_8);
              __Pyx_INCREF(function);
              __Pyx_DECREF_SET(__pyx_t_10, function);
              __pyx_t_13 = 1;
            }
          }
          __pyx_t_14 = PyTuple_New(2+__pyx_t_13); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 173, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_14);
          if (__pyx_t_8) {
            __Pyx_GIVEREF(__pyx_t_8); PyTuple_SET_ITEM(__pyx_t_14, 0, __pyx_t_8); __pyx_t_8 = NULL;
          }
          __Pyx_INCREF(__pyx_v_fields);
          __Pyx_GIVEREF(__pyx_v_fields);
          PyTuple_SET_ITEM(__pyx_t_14, 0+__pyx_t_13, __pyx_v_fields);
          __Pyx_INCREF(__pyx_v_record);
          __Pyx_GIVEREF(__pyx_v_record);
          PyTuple_SET_ITEM(__pyx_t_14, 1+__pyx_t_13, __pyx_v_record);
          __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_10, __pyx_t_14, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 173, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
          __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
          __pyx_t_11 = __Pyx_PyList_Append(__pyx_v_lines, __pyx_t_1); if (unlikely(__pyx_t_11 == -1)) __PYX_ERR(0, 173, __pyx_L1_error)
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

          /* "pysam/calignmentfile.pyx":172
 *                 lines.append(build_header_line(data, record))
 *             else:
 *                 for fields in new_header[record]:             # <<<<<<<<<<<<<<
 *                     lines.append(build_header_line(fields, record))
 * 
 */
        }
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      }
      __pyx_L7:;

      /* "pysam/calignmentfile.pyx":162
 *     # first: defined tags
 *     for record in VALID_HEADERS:
 *         if record in new_header:             # <<<<<<<<<<<<<<
 *             ttype = VALID_HEADER_TYPES[record]
 *             data = new_header[record]
 */
    }

    /* "pysam/calignmentfile.pyx":161
 * 
 *     # first: defined tags
 *     for record in VALID_HEADERS:             # <<<<<<<<<<<<<<
 *         if record in new_header:
 *             ttype = VALID_HEADER_TYPES[record]
 */
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pysam/calignmentfile.pyx":176
 * 
 *     # then: user tags (lower case), sorted alphabetically
 *     for record, data in sorted(new_header.items()):             # <<<<<<<<<<<<<<
 *         if record in VALID_HEADERS: continue
 *         if type(data) is dict:
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_new_header, __pyx_n_s_items); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 176, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_10 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_1))) {
    __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_1);
    if (likely(__pyx_t_10)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
      __Pyx_INCREF(__pyx_t_10);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_1, function);
    }
  }
  if (__pyx_t_10) {
    __pyx_t_7 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_t_10); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 176, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
  } else {
    __pyx_t_7 = __Pyx_PyObject_CallNoArg(__pyx_t_1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 176, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_7);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = PySequence_List(__pyx_t_7); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 176, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __pyx_t_2 = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;
  __pyx_t_11 = PyList_Sort(__pyx_t_2); if (unlikely(__pyx_t_11 == -1)) __PYX_ERR(0, 176, __pyx_L1_error)
  if (unlikely(__pyx_t_2 == Py_None)) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
    __PYX_ERR(0, 176, __pyx_L1_error)
  }
  __pyx_t_1 = __pyx_t_2; __Pyx_INCREF(__pyx_t_1); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  for (;;) {
    if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_1)) break;
    #if CYTHON_COMPILING_IN_CPYTHON
    __pyx_t_2 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_3); __Pyx_INCREF(__pyx_t_2); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 176, __pyx_L1_error)
    #else
    __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 176, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    #endif
    if ((likely(PyTuple_CheckExact(__pyx_t_2))) || (PyList_CheckExact(__pyx_t_2))) {
      PyObject* sequence = __pyx_t_2;
      #if CYTHON_COMPILING_IN_CPYTHON
      Py_ssize_t size = Py_SIZE(sequence);
      #else
      Py_ssize_t size = PySequence_Size(sequence);
      #endif
      if (unlikely(size != 2)) {
        if (size > 2) __Pyx_RaiseTooManyValuesError(2);
        else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
        __PYX_ERR(0, 176, __pyx_L1_error)
      }
      #if CYTHON_COMPILING_IN_CPYTHON
      if (likely(PyTuple_CheckExact(sequence))) {
        __pyx_t_7 = PyTuple_GET_ITEM(sequence, 0); 
        __pyx_t_10 = PyTuple_GET_ITEM(sequence, 1); 
      } else {
        __pyx_t_7 = PyList_GET_ITEM(sequence, 0); 
        __pyx_t_10 = PyList_GET_ITEM(sequence, 1); 
      }
      __Pyx_INCREF(__pyx_t_7);
      __Pyx_INCREF(__pyx_t_10);
      #else
      __pyx_t_7 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 176, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_10 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 176, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_10);
      #endif
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    } else {
      Py_ssize_t index = -1;
      __pyx_t_14 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 176, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_14);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_15 = Py_TYPE(__pyx_t_14)->tp_iternext;
      index = 0; __pyx_t_7 = __pyx_t_15(__pyx_t_14); if (unlikely(!__pyx_t_7)) goto __pyx_L12_unpacking_failed;
      __Pyx_GOTREF(__pyx_t_7);
      index = 1; __pyx_t_10 = __pyx_t_15(__pyx_t_14); if (unlikely(!__pyx_t_10)) goto __pyx_L12_unpacking_failed;
      __Pyx_GOTREF(__pyx_t_10);
      if (__Pyx_IternextUnpackEndCheck(__pyx_t_15(__pyx_t_14), 2) < 0) __PYX_ERR(0, 176, __pyx_L1_error)
      __pyx_t_15 = NULL;
      __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
      goto __pyx_L13_unpacking_done;
      __pyx_L12_unpacking_failed:;
      __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
      __pyx_t_15 = NULL;
      if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
      __PYX_ERR(0, 176, __pyx_L1_error)
      __pyx_L13_unpacking_done:;
    }
    __Pyx_XDECREF_SET(__pyx_v_record, __pyx_t_7);
    __pyx_t_7 = 0;
    __Pyx_XDECREF_SET(__pyx_v_data, __pyx_t_10);
    __pyx_t_10 = 0;

    /* "pysam/calignmentfile.pyx":177
 *     # then: user tags (lower case), sorted alphabetically
 *     for record, data in sorted(new_header.items()):
 *         if record in VALID_HEADERS: continue             # <<<<<<<<<<<<<<
 *         if type(data) is dict:
 *             lines.append(build_header_line(data, record))
 */
    __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_VALID_HEADERS); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 177, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_5 = (__Pyx_PySequence_ContainsTF(__pyx_v_record, __pyx_t_2, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 177, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_6 = (__pyx_t_5 != 0);
    if (__pyx_t_6) {
      goto __pyx_L10_continue;
    }

    /* "pysam/calignmentfile.pyx":178
 *     for record, data in sorted(new_header.items()):
 *         if record in VALID_HEADERS: continue
 *         if type(data) is dict:             # <<<<<<<<<<<<<<
 *             lines.append(build_header_line(data, record))
 *         else:
 */
    __pyx_t_6 = (((PyObject *)Py_TYPE(__pyx_v_data)) == ((PyObject *)(&PyDict_Type)));
    __pyx_t_5 = (__pyx_t_6 != 0);
    if (__pyx_t_5) {

      /* "pysam/calignmentfile.pyx":179
 *         if record in VALID_HEADERS: continue
 *         if type(data) is dict:
 *             lines.append(build_header_line(data, record))             # <<<<<<<<<<<<<<
 *         else:
 *             for fields in new_header[record]:
 */
      __pyx_t_10 = __Pyx_GetModuleGlobalName(__pyx_n_s_build_header_line); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 179, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_10);
      __pyx_t_7 = NULL;
      __pyx_t_9 = 0;
      if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_10))) {
        __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_10);
        if (likely(__pyx_t_7)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_10);
          __Pyx_INCREF(__pyx_t_7);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_10, function);
          __pyx_t_9 = 1;
        }
      }
      __pyx_t_14 = PyTuple_New(2+__pyx_t_9); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 179, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_14);
      if (__pyx_t_7) {
        __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_14, 0, __pyx_t_7); __pyx_t_7 = NULL;
      }
      __Pyx_INCREF(__pyx_v_data);
      __Pyx_GIVEREF(__pyx_v_data);
      PyTuple_SET_ITEM(__pyx_t_14, 0+__pyx_t_9, __pyx_v_data);
      __Pyx_INCREF(__pyx_v_record);
      __Pyx_GIVEREF(__pyx_v_record);
      PyTuple_SET_ITEM(__pyx_t_14, 1+__pyx_t_9, __pyx_v_record);
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_10, __pyx_t_14, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 179, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
      __pyx_t_11 = __Pyx_PyList_Append(__pyx_v_lines, __pyx_t_2); if (unlikely(__pyx_t_11 == -1)) __PYX_ERR(0, 179, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

      /* "pysam/calignmentfile.pyx":178
 *     for record, data in sorted(new_header.items()):
 *         if record in VALID_HEADERS: continue
 *         if type(data) is dict:             # <<<<<<<<<<<<<<
 *             lines.append(build_header_line(data, record))
 *         else:
 */
      goto __pyx_L15;
    }

    /* "pysam/calignmentfile.pyx":181
 *             lines.append(build_header_line(data, record))
 *         else:
 *             for fields in new_header[record]:             # <<<<<<<<<<<<<<
 *                 lines.append(build_header_line(fields, record))
 * 
 */
    /*else*/ {
      __pyx_t_2 = PyObject_GetItem(__pyx_v_new_header, __pyx_v_record); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 181, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      if (likely(PyList_CheckExact(__pyx_t_2)) || PyTuple_CheckExact(__pyx_t_2)) {
        __pyx_t_10 = __pyx_t_2; __Pyx_INCREF(__pyx_t_10); __pyx_t_9 = 0;
        __pyx_t_4 = NULL;
      } else {
        __pyx_t_9 = -1; __pyx_t_10 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 181, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_10);
        __pyx_t_4 = Py_TYPE(__pyx_t_10)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 181, __pyx_L1_error)
      }
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      for (;;) {
        if (likely(!__pyx_t_4)) {
          if (likely(PyList_CheckExact(__pyx_t_10))) {
            if (__pyx_t_9 >= PyList_GET_SIZE(__pyx_t_10)) break;
            #if CYTHON_COMPILING_IN_CPYTHON
            __pyx_t_2 = PyList_GET_ITEM(__pyx_t_10, __pyx_t_9); __Pyx_INCREF(__pyx_t_2); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 181, __pyx_L1_error)
            #else
            __pyx_t_2 = PySequence_ITEM(__pyx_t_10, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 181, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_2);
            #endif
          } else {
            if (__pyx_t_9 >= PyTuple_GET_SIZE(__pyx_t_10)) break;
            #if CYTHON_COMPILING_IN_CPYTHON
            __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_10, __pyx_t_9); __Pyx_INCREF(__pyx_t_2); __pyx_t_9++; if (unlikely(0 < 0)) __PYX_ERR(0, 181, __pyx_L1_error)
            #else
            __pyx_t_2 = PySequence_ITEM(__pyx_t_10, __pyx_t_9); __pyx_t_9++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 181, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_2);
            #endif
          }
        } else {
          __pyx_t_2 = __pyx_t_4(__pyx_t_10);
          if (unlikely(!__pyx_t_2)) {
            PyObject* exc_type = PyErr_Occurred();
            if (exc_type) {
              if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
              else __PYX_ERR(0, 181, __pyx_L1_error)
            }
            break;
          }
          __Pyx_GOTREF(__pyx_t_2);
        }
        __Pyx_XDECREF_SET(__pyx_v_fields, __pyx_t_2);
        __pyx_t_2 = 0;

        /* "pysam/calignmentfile.pyx":182
 *         else:
 *             for fields in new_header[record]:
 *                 lines.append(build_header_line(fields, record))             # <<<<<<<<<<<<<<
 * 
 *     text = "\n".join(lines) + "\n"
 */
        __pyx_t_14 = __Pyx_GetModuleGlobalName(__pyx_n_s_build_header_line); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 182, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_14);
        __pyx_t_7 = NULL;
        __pyx_t_13 = 0;
        if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_14))) {
          __pyx_t_7 = PyMethod_GET_SELF(__pyx_t_14);
          if (likely(__pyx_t_7)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_14);
            __Pyx_INCREF(__pyx_t_7);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_14, function);
            __pyx_t_13 = 1;
          }
        }
        __pyx_t_8 = PyTuple_New(2+__pyx_t_13); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 182, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_8);
        if (__pyx_t_7) {
          __Pyx_GIVEREF(__pyx_t_7); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_7); __pyx_t_7 = NULL;
        }
        __Pyx_INCREF(__pyx_v_fields);
        __Pyx_GIVEREF(__pyx_v_fields);
        PyTuple_SET_ITEM(__pyx_t_8, 0+__pyx_t_13, __pyx_v_fields);
        __Pyx_INCREF(__pyx_v_record);
        __Pyx_GIVEREF(__pyx_v_record);
        PyTuple_SET_ITEM(__pyx_t_8, 1+__pyx_t_13, __pyx_v_record);
        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_14, __pyx_t_8, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 182, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
        __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
        __pyx_t_11 = __Pyx_PyList_Append(__pyx_v_lines, __pyx_t_2); if (unlikely(__pyx_t_11 == -1)) __PYX_ERR(0, 182, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

        /* "pysam/calignmentfile.pyx":181
 *             lines.append(build_header_line(data, record))
 *         else:
 *             for fields in new_header[record]:             # <<<<<<<<<<<<<<
 *                 lines.append(build_header_line(fields, record))
 * 
 */
      }
      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
    }
    __pyx_L15:;

    /* "pysam/calignmentfile.pyx":176
 * 
 *     # then: user tags (lower case), sorted alphabetically
 *     for record, data in sorted(new_header.items()):             # <<<<<<<<<<<<<<
 *         if record in VALID_HEADERS: continue
 *         if type(data) is dict:
 */
    __pyx_L10_continue:;
  }
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pysam/calignmentfile.pyx":184
 *                 lines.append(build_header_line(fields, record))
 * 
 *     text = "\n".join(lines) + "\n"             # <<<<<<<<<<<<<<
 *     if dest.text != NULL: free( dest.text )
 *     dest.text = <char*>calloc(len(text), sizeof(char))
 */
  __pyx_t_1 = __Pyx_PyString_Join(__pyx_kp_s__3, __pyx_v_lines); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 184, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_10 = PyNumber_Add(__pyx_t_1, __pyx_kp_s__3); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 184, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_10);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_text = ((PyObject*)__pyx_t_10);
  __pyx_t_10 = 0;

  /* "pysam/calignmentfile.pyx":185
 * 
 *     text = "\n".join(lines) + "\n"
 *     if dest.text != NULL: free( dest.text )             # <<<<<<<<<<<<<<
 *     dest.text = <char*>calloc(len(text), sizeof(char))
 *     dest.l_text = len(text)
 */
  __pyx_t_5 = ((__pyx_v_dest->text != NULL) != 0);
  if (__pyx_t_5) {
    free(__pyx_v_dest->text);
  }

  /* "pysam/calignmentfile.pyx":186
 *     text = "\n".join(lines) + "\n"
 *     if dest.text != NULL: free( dest.text )
 *     dest.text = <char*>calloc(len(text), sizeof(char))             # <<<<<<<<<<<<<<
 *     dest.l_text = len(text)
 *     cdef bytes btext = text.encode('ascii')
 */
  __pyx_t_3 = PyObject_Length(__pyx_v_text); if (unlikely(__pyx_t_3 == -1)) __PYX_ERR(0, 186, __pyx_L1_error)
  __pyx_v_dest->text = ((char *)calloc(__pyx_t_3, (sizeof(char))));

  /* "pysam/calignmentfile.pyx":187
 *     if dest.text != NULL: free( dest.text )
 *     dest.text = <char*>calloc(len(text), sizeof(char))
 *     dest.l_text = len(text)             # <<<<<<<<<<<<<<
 *     cdef bytes btext = text.encode('ascii')
 *     strncpy(dest.text, btext, dest.l_text)
 */
  __pyx_t_3 = PyObject_Length(__pyx_v_text); if (unlikely(__pyx_t_3 == -1)) __PYX_ERR(0, 187, __pyx_L1_error)
  __pyx_v_dest->l_text = __pyx_t_3;

  /* "pysam/calignmentfile.pyx":188
 *     dest.text = <char*>calloc(len(text), sizeof(char))
 *     dest.l_text = len(text)
 *     cdef bytes btext = text.encode('ascii')             # <<<<<<<<<<<<<<
 *     strncpy(dest.text, btext, dest.l_text)
 * 
 */
  __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_v_text, __pyx_n_s_encode); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 188, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_10);
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_10, __pyx_tuple__4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 188, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
  if (!(likely(PyBytes_CheckExact(__pyx_t_1))||((__pyx_t_1) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_1)->tp_name), 0))) __PYX_ERR(0, 188, __pyx_L1_error)
  __pyx_v_btext = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pysam/calignmentfile.pyx":189
 *     dest.l_text = len(text)
 *     cdef bytes btext = text.encode('ascii')
 *     strncpy(dest.text, btext, dest.l_text)             # <<<<<<<<<<<<<<
 * 
 *     cdef bytes bseqname
 */
  __pyx_t_16 = __Pyx_PyObject_AsString(__pyx_v_btext); if (unlikely((!__pyx_t_16) && PyErr_Occurred())) __PYX_ERR(0, 189, __pyx_L1_error)
  strncpy(__pyx_v_dest->text, __pyx_t_16, __pyx_v_dest->l_text);

  /* "pysam/calignmentfile.pyx":193
 *     cdef bytes bseqname
 *     # collect targets
 *     if "SQ" in new_header:             # <<<<<<<<<<<<<<
 *         seqs = []
 *         for fields in new_header["SQ"]:
 */
  __pyx_t_5 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_SQ, __pyx_v_new_header, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 193, __pyx_L1_error)
  __pyx_t_6 = (__pyx_t_5 != 0);
  if (__pyx_t_6) {

    /* "pysam/calignmentfile.pyx":194
 *     # collect targets
 *     if "SQ" in new_header:
 *         seqs = []             # <<<<<<<<<<<<<<
 *         for fields in new_header["SQ"]:
 *             try:
 */
    __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 194, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_v_seqs = ((PyObject*)__pyx_t_1);
    __pyx_t_1 = 0;

    /* "pysam/calignmentfile.pyx":195
 *     if "SQ" in new_header:
 *         seqs = []
 *         for fields in new_header["SQ"]:             # <<<<<<<<<<<<<<
 *             try:
 *                 seqs.append( (fields["SN"], fields["LN"] ) )
 */
    __pyx_t_1 = PyObject_GetItem(__pyx_v_new_header, __pyx_n_s_SQ); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 195, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (likely(PyList_CheckExact(__pyx_t_1)) || PyTuple_CheckExact(__pyx_t_1)) {
      __pyx_t_10 = __pyx_t_1; __Pyx_INCREF(__pyx_t_10); __pyx_t_3 = 0;
      __pyx_t_4 = NULL;
    } else {
      __pyx_t_3 = -1; __pyx_t_10 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 195, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_10);
      __pyx_t_4 = Py_TYPE(__pyx_t_10)->tp_iternext; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 195, __pyx_L1_error)
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    for (;;) {
      if (likely(!__pyx_t_4)) {
        if (likely(PyList_CheckExact(__pyx_t_10))) {
          if (__pyx_t_3 >= PyList_GET_SIZE(__pyx_t_10)) break;
          #if CYTHON_COMPILING_IN_CPYTHON
          __pyx_t_1 = PyList_GET_ITEM(__pyx_t_10, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 195, __pyx_L1_error)
          #else
          __pyx_t_1 = PySequence_ITEM(__pyx_t_10, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 195, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_1);
          #endif
        } else {
          if (__pyx_t_3 >= PyTuple_GET_SIZE(__pyx_t_10)) break;
          #if CYTHON_COMPILING_IN_CPYTHON
          __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_10, __pyx_t_3); __Pyx_INCREF(__pyx_t_1); __pyx_t_3++; if (unlikely(0 < 0)) __PYX_ERR(0, 195, __pyx_L1_error)
          #else
          __pyx_t_1 = PySequence_ITEM(__pyx_t_10, __pyx_t_3); __pyx_t_3++; if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 195, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_1);
          #endif
        }
      } else {
        __pyx_t_1 = __pyx_t_4(__pyx_t_10);
        if (unlikely(!__pyx_t_1)) {
          PyObject* exc_type = PyErr_Occurred();
          if (exc_type) {
            if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
            else __PYX_ERR(0, 195, __pyx_L1_error)
          }
          break;
        }
        __Pyx_GOTREF(__pyx_t_1);
      }
      __Pyx_XDECREF_SET(__pyx_v_fields, __pyx_t_1);
      __pyx_t_1 = 0;

      /* "pysam/calignmentfile.pyx":196
 *         seqs = []
 *         for fields in new_header["SQ"]:
 *             try:             # <<<<<<<<<<<<<<
 *                 seqs.append( (fields["SN"], fields["LN"] ) )
 *             except KeyError:
 */
      {
        __Pyx_PyThreadState_declare
        __Pyx_PyThreadState_assign
        __Pyx_ExceptionSave(&__pyx_t_17, &__pyx_t_18, &__pyx_t_19);
        __Pyx_XGOTREF(__pyx_t_17);
        __Pyx_XGOTREF(__pyx_t_18);
        __Pyx_XGOTREF(__pyx_t_19);
        /*try:*/ {

          /* "pysam/calignmentfile.pyx":197
 *         for fields in new_header["SQ"]:
 *             try:
 *                 seqs.append( (fields["SN"], fields["LN"] ) )             # <<<<<<<<<<<<<<
 *             except KeyError:
 *                 raise KeyError( "incomplete sequence information in '%s'" % str(fields))
 */
          __pyx_t_1 = PyObject_GetItem(__pyx_v_fields, __pyx_n_s_SN); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 197, __pyx_L22_error)
          __Pyx_GOTREF(__pyx_t_1);
          __pyx_t_2 = PyObject_GetItem(__pyx_v_fields, __pyx_n_s_LN); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 197, __pyx_L22_error)
          __Pyx_GOTREF(__pyx_t_2);
          __pyx_t_14 = PyTuple_New(2); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 197, __pyx_L22_error)
          __Pyx_GOTREF(__pyx_t_14);
          __Pyx_GIVEREF(__pyx_t_1);
          PyTuple_SET_ITEM(__pyx_t_14, 0, __pyx_t_1);
          __Pyx_GIVEREF(__pyx_t_2);
          PyTuple_SET_ITEM(__pyx_t_14, 1, __pyx_t_2);
          __pyx_t_1 = 0;
          __pyx_t_2 = 0;
          __pyx_t_11 = __Pyx_PyList_Append(__pyx_v_seqs, __pyx_t_14); if (unlikely(__pyx_t_11 == -1)) __PYX_ERR(0, 197, __pyx_L22_error)
          __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;

          /* "pysam/calignmentfile.pyx":196
 *         seqs = []
 *         for fields in new_header["SQ"]:
 *             try:             # <<<<<<<<<<<<<<
 *                 seqs.append( (fields["SN"], fields["LN"] ) )
 *             except KeyError:
 */
        }
        __Pyx_XDECREF(__pyx_t_17); __pyx_t_17 = 0;
        __Pyx_XDECREF(__pyx_t_18); __pyx_t_18 = 0;
        __Pyx_XDECREF(__pyx_t_19); __pyx_t_19 = 0;
        goto __pyx_L29_try_end;
        __pyx_L22_error:;
        __Pyx_PyThreadState_assign
        __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
        __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
        __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_XDECREF(__pyx_t_14); __pyx_t_14 = 0;

        /* "pysam/calignmentfile.pyx":198
 *             try:
 *                 seqs.append( (fields["SN"], fields["LN"] ) )
 *             except KeyError:             # <<<<<<<<<<<<<<
 *                 raise KeyError( "incomplete sequence information in '%s'" % str(fields))
 * 
 */
        __pyx_t_20 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_KeyError);
        if (__pyx_t_20) {
          __Pyx_AddTraceback("pysam.calignmentfile.build_header", __pyx_clineno, __pyx_lineno, __pyx_filename);
          if (__Pyx_GetException(&__pyx_t_14, &__pyx_t_2, &__pyx_t_1) < 0) __PYX_ERR(0, 198, __pyx_L24_except_error)
          __Pyx_GOTREF(__pyx_t_14);
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_GOTREF(__pyx_t_1);

          /* "pysam/calignmentfile.pyx":199
 *                 seqs.append( (fields["SN"], fields["LN"] ) )
 *             except KeyError:
 *                 raise KeyError( "incomplete sequence information in '%s'" % str(fields))             # <<<<<<<<<<<<<<
 * 
 *         dest.n_targets = len(seqs)
 */
          __pyx_t_8 = PyTuple_New(1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 199, __pyx_L24_except_error)
          __Pyx_GOTREF(__pyx_t_8);
          __Pyx_INCREF(__pyx_v_fields);
          __Pyx_GIVEREF(__pyx_v_fields);
          PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_v_fields);
          __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)(&PyString_Type)), __pyx_t_8, NULL); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 199, __pyx_L24_except_error)
          __Pyx_GOTREF(__pyx_t_7);
          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
          __pyx_t_8 = __Pyx_PyString_Format(__pyx_kp_s_incomplete_sequence_information, __pyx_t_7); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 199, __pyx_L24_except_error)
          __Pyx_GOTREF(__pyx_t_8);
          __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
          __pyx_t_7 = PyTuple_New(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 199, __pyx_L24_except_error)
          __Pyx_GOTREF(__pyx_t_7);
          __Pyx_GIVEREF(__pyx_t_8);
          PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_8);
          __pyx_t_8 = 0;
          __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_KeyError, __pyx_t_7, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 199, __pyx_L24_except_error)
          __Pyx_GOTREF(__pyx_t_8);
          __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
          __Pyx_Raise(__pyx_t_8, 0, 0, 0);
          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
          __PYX_ERR(0, 199, __pyx_L24_except_error)
        }
        goto __pyx_L24_except_error;
        __pyx_L24_except_error:;

        /* "pysam/calignmentfile.pyx":196
 *         seqs = []
 *         for fields in new_header["SQ"]:
 *             try:             # <<<<<<<<<<<<<<
 *                 seqs.append( (fields["SN"], fields["LN"] ) )
 *             except KeyError:
 */
        __Pyx_PyThreadState_assign
        __Pyx_XGIVEREF(__pyx_t_17);
        __Pyx_XGIVEREF(__pyx_t_18);
        __Pyx_XGIVEREF(__pyx_t_19);
        __Pyx_ExceptionReset(__pyx_t_17, __pyx_t_18, __pyx_t_19);
        goto __pyx_L1_error;
        __pyx_L29_try_end:;
      }

      /* "pysam/calignmentfile.pyx":195
 *     if "SQ" in new_header:
 *         seqs = []
 *         for fields in new_header["SQ"]:             # <<<<<<<<<<<<<<
 *             try:
 *                 seqs.append( (fields["SN"], fields["LN"] ) )
 */
    }
    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;

    /* "pysam/calignmentfile.pyx":201
 *                 raise KeyError( "incomplete sequence information in '%s'" % str(fields))
 * 
 *         dest.n_targets = len(seqs)             # <<<<<<<<<<<<<<
 *         dest.target_name = <char**>calloc(dest.n_targets, sizeof(char*))
 *         dest.target_len = <uint32_t*>calloc(dest.n_targets, sizeof(uint32_t))
 */
    __pyx_t_3 = PyList_GET_SIZE(__pyx_v_seqs); if (unlikely(__pyx_t_3 == -1)) __PYX_ERR(0, 201, __pyx_L1_error)
    __pyx_v_dest->n_targets = __pyx_t_3;

    /* "pysam/calignmentfile.pyx":202
 * 
 *         dest.n_targets = len(seqs)
 *         dest.target_name = <char**>calloc(dest.n_targets, sizeof(char*))             # <<<<<<<<<<<<<<
 *         dest.target_len = <uint32_t*>calloc(dest.n_targets, sizeof(uint32_t))
 * 
 */
    __pyx_v_dest->target_name = ((char **)calloc(__pyx_v_dest->n_targets, (sizeof(char *))));

    /* "pysam/calignmentfile.pyx":203
 *         dest.n_targets = len(seqs)
 *         dest.target_name = <char**>calloc(dest.n_targets, sizeof(char*))
 *         dest.target_len = <uint32_t*>calloc(dest.n_targets, sizeof(uint32_t))             # <<<<<<<<<<<<<<
 * 
 *         for x from 0 <= x < dest.n_targets:
 */
    __pyx_v_dest->target_len = ((uint32_t *)calloc(__pyx_v_dest->n_targets, (sizeof(uint32_t))));

    /* "pysam/calignmentfile.pyx":205
 *         dest.target_len = <uint32_t*>calloc(dest.n_targets, sizeof(uint32_t))
 * 
 *         for x from 0 <= x < dest.n_targets:             # <<<<<<<<<<<<<<
 *             seqname, seqlen = seqs[x]
 *             dest.target_name[x] = <char*>calloc(
 */
    __pyx_t_21 = __pyx_v_dest->n_targets;
    for (__pyx_v_x = 0; __pyx_v_x < __pyx_t_21; __pyx_v_x++) {

      /* "pysam/calignmentfile.pyx":206
 * 
 *         for x from 0 <= x < dest.n_targets:
 *             seqname, seqlen = seqs[x]             # <<<<<<<<<<<<<<
 *             dest.target_name[x] = <char*>calloc(
 *                 len(seqname) + 1, sizeof(char))
 */
      __pyx_t_10 = __Pyx_GetItemInt_List(__pyx_v_seqs, __pyx_v_x, long, 1, __Pyx_PyInt_From_long, 1, 1, 1); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 206, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_10);
      if ((likely(PyTuple_CheckExact(__pyx_t_10))) || (PyList_CheckExact(__pyx_t_10))) {
        PyObject* sequence = __pyx_t_10;
        #if CYTHON_COMPILING_IN_CPYTHON
        Py_ssize_t size = Py_SIZE(sequence);
        #else
        Py_ssize_t size = PySequence_Size(sequence);
        #endif
        if (unlikely(size != 2)) {
          if (size > 2) __Pyx_RaiseTooManyValuesError(2);
          else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
          __PYX_ERR(0, 206, __pyx_L1_error)
        }
        #if CYTHON_COMPILING_IN_CPYTHON
        if (likely(PyTuple_CheckExact(sequence))) {
          __pyx_t_1 = PyTuple_GET_ITEM(sequence, 0); 
          __pyx_t_2 = PyTuple_GET_ITEM(sequence, 1); 
        } else {
          __pyx_t_1 = PyList_GET_ITEM(sequence, 0); 
          __pyx_t_2 = PyList_GET_ITEM(sequence, 1); 
        }
        __Pyx_INCREF(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_2);
        #else
        __pyx_t_1 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 206, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_2 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 206, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        #endif
        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
      } else {
        Py_ssize_t index = -1;
        __pyx_t_14 = PyObject_GetIter(__pyx_t_10); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 206, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_14);
        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
        __pyx_t_15 = Py_TYPE(__pyx_t_14)->tp_iternext;
        index = 0; __pyx_t_1 = __pyx_t_15(__pyx_t_14); if (unlikely(!__pyx_t_1)) goto __pyx_L34_unpacking_failed;
        __Pyx_GOTREF(__pyx_t_1);
        index = 1; __pyx_t_2 = __pyx_t_15(__pyx_t_14); if (unlikely(!__pyx_t_2)) goto __pyx_L34_unpacking_failed;
        __Pyx_GOTREF(__pyx_t_2);
        if (__Pyx_IternextUnpackEndCheck(__pyx_t_15(__pyx_t_14), 2) < 0) __PYX_ERR(0, 206, __pyx_L1_error)
        __pyx_t_15 = NULL;
        __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
        goto __pyx_L35_unpacking_done;
        __pyx_L34_unpacking_failed:;
        __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
        __pyx_t_15 = NULL;
        if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
        __PYX_ERR(0, 206, __pyx_L1_error)
        __pyx_L35_unpacking_done:;
      }
      __Pyx_XDECREF_SET(__pyx_v_seqname, __pyx_t_1);
      __pyx_t_1 = 0;
      __Pyx_XDECREF_SET(__pyx_v_seqlen, __pyx_t_2);
      __pyx_t_2 = 0;

      /* "pysam/calignmentfile.pyx":208
 *             seqname, seqlen = seqs[x]
 *             dest.target_name[x] = <char*>calloc(
 *                 len(seqname) + 1, sizeof(char))             # <<<<<<<<<<<<<<
 *             bseqname = seqname.encode('ascii')
 *             strncpy(dest.target_name[x], bseqname,
 */
      __pyx_t_3 = PyObject_Length(__pyx_v_seqname); if (unlikely(__pyx_t_3 == -1)) __PYX_ERR(0, 208, __pyx_L1_error)

      /* "pysam/calignmentfile.pyx":207
 *         for x from 0 <= x < dest.n_targets:
 *             seqname, seqlen = seqs[x]
 *             dest.target_name[x] = <char*>calloc(             # <<<<<<<<<<<<<<
 *                 len(seqname) + 1, sizeof(char))
 *             bseqname = seqname.encode('ascii')
 */
      (__pyx_v_dest->target_name[__pyx_v_x]) = ((char *)calloc((__pyx_t_3 + 1), (sizeof(char))));

      /* "pysam/calignmentfile.pyx":209
 *             dest.target_name[x] = <char*>calloc(
 *                 len(seqname) + 1, sizeof(char))
 *             bseqname = seqname.encode('ascii')             # <<<<<<<<<<<<<<
 *             strncpy(dest.target_name[x], bseqname,
 *                     len(seqname) + 1)
 */
      __pyx_t_10 = __Pyx_PyObject_GetAttrStr(__pyx_v_seqname, __pyx_n_s_encode); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 209, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_10);
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_10, __pyx_tuple__5, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 209, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
      if (!(likely(PyBytes_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 209, __pyx_L1_error)
      __Pyx_XDECREF_SET(__pyx_v_bseqname, ((PyObject*)__pyx_t_2));
      __pyx_t_2 = 0;

      /* "pysam/calignmentfile.pyx":210
 *                 len(seqname) + 1, sizeof(char))
 *             bseqname = seqname.encode('ascii')
 *             strncpy(dest.target_name[x], bseqname,             # <<<<<<<<<<<<<<
 *                     len(seqname) + 1)
 *             dest.target_len[x] = seqlen
 */
      __pyx_t_16 = __Pyx_PyObject_AsString(__pyx_v_bseqname); if (unlikely((!__pyx_t_16) && PyErr_Occurred())) __PYX_ERR(0, 210, __pyx_L1_error)

      /* "pysam/calignmentfile.pyx":211
 *             bseqname = seqname.encode('ascii')
 *             strncpy(dest.target_name[x], bseqname,
 *                     len(seqname) + 1)             # <<<<<<<<<<<<<<
 *             dest.target_len[x] = seqlen
 * 
 */
      __pyx_t_3 = PyObject_Length(__pyx_v_seqname); if (unlikely(__pyx_t_3 == -1)) __PYX_ERR(0, 211, __pyx_L1_error)

      /* "pysam/calignmentfile.pyx":210
 *                 len(seqname) + 1, sizeof(char))
 *             bseqname = seqname.encode('ascii')
 *             strncpy(dest.target_name[x], bseqname,             # <<<<<<<<<<<<<<
 *                     len(seqname) + 1)
 *             dest.target_len[x] = seqlen
 */
      strncpy((__pyx_v_dest->target_name[__pyx_v_x]), __pyx_t_16, (__pyx_t_3 + 1));

      /* "pysam/calignmentfile.pyx":212
 *             strncpy(dest.target_name[x], bseqname,
 *                     len(seqname) + 1)
 *             dest.target_len[x] = seqlen             # <<<<<<<<<<<<<<
 * 
 *     return dest
 */
      __pyx_t_22 = __Pyx_PyInt_As_uint32_t(__pyx_v_seqlen); if (unlikely((__pyx_t_22 == (uint32_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 212, __pyx_L1_error)
      (__pyx_v_dest->target_len[__pyx_v_x]) = __pyx_t_22;
    }

    /* "pysam/calignmentfile.pyx":193
 *     cdef bytes bseqname
 *     # collect targets
 *     if "SQ" in new_header:             # <<<<<<<<<<<<<<
 *         seqs = []
 *         for fields in new_header["SQ"]:
 */
  }

  /* "pysam/calignmentfile.pyx":214
 *             dest.target_len[x] = seqlen
 * 
 *     return dest             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_r = __pyx_v_dest;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":145
 *     return "\t".join(line)
 * 
 * cdef bam_hdr_t * build_header(new_header):             # <<<<<<<<<<<<<<
 *     '''return a new header built from a dictionary in `new_header`.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_XDECREF(__pyx_t_14);
  __Pyx_WriteUnraisable("pysam.calignmentfile.build_header", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_lines);
  __Pyx_XDECREF(__pyx_v_record);
  __Pyx_XDECREF(__pyx_v_ttype);
  __Pyx_XDECREF(__pyx_v_data);
  __Pyx_XDECREF(__pyx_v_fields);
  __Pyx_XDECREF(__pyx_v_text);
  __Pyx_XDECREF(__pyx_v_btext);
  __Pyx_XDECREF(__pyx_v_bseqname);
  __Pyx_XDECREF(__pyx_v_seqs);
  __Pyx_XDECREF(__pyx_v_seqname);
  __Pyx_XDECREF(__pyx_v_seqlen);
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":320
 *     """
 * 
 *     def __cinit__(self, *args, **kwargs):             # <<<<<<<<<<<<<<
 * 
 *         self.htsfile = NULL
 */

/* Python wrapper */
static int __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_args = 0;
  PyObject *__pyx_v_kwargs = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  if (unlikely(__pyx_kwds) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__cinit__", 1))) return -1;
  __pyx_v_kwargs = (__pyx_kwds) ? PyDict_Copy(__pyx_kwds) : PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return -1;
  __Pyx_GOTREF(__pyx_v_kwargs);
  __Pyx_INCREF(__pyx_args);
  __pyx_v_args = __pyx_args;
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile___cinit__(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self), __pyx_v_args, __pyx_v_kwargs);

  /* function exit code */
  __Pyx_XDECREF(__pyx_v_args);
  __Pyx_XDECREF(__pyx_v_kwargs);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_5pysam_14calignmentfile_13AlignmentFile___cinit__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_args, PyObject *__pyx_v_kwargs) {
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("__cinit__", 0);
  __Pyx_TraceCall("__cinit__", __pyx_f[0], 320, 0, __PYX_ERR(0, 320, __pyx_L1_error));
  __Pyx_INCREF(__pyx_v_args);

  /* "pysam/calignmentfile.pyx":322
 *     def __cinit__(self, *args, **kwargs):
 * 
 *         self.htsfile = NULL             # <<<<<<<<<<<<<<
 *         self._filename = None
 *         self.is_bam = False
 */
  __pyx_v_self->htsfile = NULL;

  /* "pysam/calignmentfile.pyx":323
 * 
 *         self.htsfile = NULL
 *         self._filename = None             # <<<<<<<<<<<<<<
 *         self.is_bam = False
 *         self.is_stream = False
 */
  __Pyx_INCREF(Py_None);
  __Pyx_GIVEREF(Py_None);
  __Pyx_GOTREF(__pyx_v_self->_filename);
  __Pyx_DECREF(__pyx_v_self->_filename);
  __pyx_v_self->_filename = Py_None;

  /* "pysam/calignmentfile.pyx":324
 *         self.htsfile = NULL
 *         self._filename = None
 *         self.is_bam = False             # <<<<<<<<<<<<<<
 *         self.is_stream = False
 *         self.is_cram = False
 */
  __pyx_v_self->is_bam = 0;

  /* "pysam/calignmentfile.pyx":325
 *         self._filename = None
 *         self.is_bam = False
 *         self.is_stream = False             # <<<<<<<<<<<<<<
 *         self.is_cram = False
 *         self.is_remote = False
 */
  __pyx_v_self->is_stream = 0;

  /* "pysam/calignmentfile.pyx":326
 *         self.is_bam = False
 *         self.is_stream = False
 *         self.is_cram = False             # <<<<<<<<<<<<<<
 *         self.is_remote = False
 * 
 */
  __pyx_v_self->is_cram = 0;

  /* "pysam/calignmentfile.pyx":327
 *         self.is_stream = False
 *         self.is_cram = False
 *         self.is_remote = False             # <<<<<<<<<<<<<<
 * 
 *         if "filename" in kwargs:
 */
  __pyx_v_self->is_remote = 0;

  /* "pysam/calignmentfile.pyx":329
 *         self.is_remote = False
 * 
 *         if "filename" in kwargs:             # <<<<<<<<<<<<<<
 *             args = [kwargs["filename"]]
 *             del kwargs["filename"]
 */
  __pyx_t_1 = (__Pyx_PyDict_ContainsTF(__pyx_n_s_filename, __pyx_v_kwargs, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 329, __pyx_L1_error)
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pysam/calignmentfile.pyx":330
 * 
 *         if "filename" in kwargs:
 *             args = [kwargs["filename"]]             # <<<<<<<<<<<<<<
 *             del kwargs["filename"]
 * 
 */
    __pyx_t_3 = __Pyx_PyDict_GetItem(__pyx_v_kwargs, __pyx_n_s_filename); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 330, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = PyList_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 330, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_3);
    PyList_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
    __pyx_t_3 = 0;
    __Pyx_DECREF_SET(__pyx_v_args, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "pysam/calignmentfile.pyx":331
 *         if "filename" in kwargs:
 *             args = [kwargs["filename"]]
 *             del kwargs["filename"]             # <<<<<<<<<<<<<<
 * 
 *         self._open(*args, **kwargs)
 */
    if (unlikely(PyDict_DelItem(__pyx_v_kwargs, __pyx_n_s_filename) < 0)) __PYX_ERR(0, 331, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":329
 *         self.is_remote = False
 * 
 *         if "filename" in kwargs:             # <<<<<<<<<<<<<<
 *             args = [kwargs["filename"]]
 *             del kwargs["filename"]
 */
  }

  /* "pysam/calignmentfile.pyx":333
 *             del kwargs["filename"]
 * 
 *         self._open(*args, **kwargs)             # <<<<<<<<<<<<<<
 * 
 *         # allocate memory for iterator
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_open); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 333, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_3 = PySequence_Tuple(__pyx_v_args); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 333, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_4, __pyx_t_3, __pyx_v_kwargs); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 333, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

  /* "pysam/calignmentfile.pyx":336
 * 
 *         # allocate memory for iterator
 *         self.b = <bam1_t*>calloc(1, sizeof(bam1_t))             # <<<<<<<<<<<<<<
 * 
 *     def is_open(self):
 */
  __pyx_v_self->b = ((bam1_t *)calloc(1, (sizeof(bam1_t))));

  /* "pysam/calignmentfile.pyx":320
 *     """
 * 
 *     def __cinit__(self, *args, **kwargs):             # <<<<<<<<<<<<<<
 * 
 *         self.htsfile = NULL
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_args);
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":338
 *         self.b = <bam1_t*>calloc(1, sizeof(bam1_t))
 * 
 *     def is_open(self):             # <<<<<<<<<<<<<<
 *         '''return true if htsfile has been opened.'''
 *         return self.htsfile != NULL
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_3is_open(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_2is_open[] = "AlignmentFile.is_open(self)\nreturn true if htsfile has been opened.";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_3is_open(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("is_open (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_2is_open(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_2is_open(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("is_open", 0);
  __Pyx_TraceCall("is_open", __pyx_f[0], 338, 0, __PYX_ERR(0, 338, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":340
 *     def is_open(self):
 *         '''return true if htsfile has been opened.'''
 *         return self.htsfile != NULL             # <<<<<<<<<<<<<<
 * 
 *     def has_index(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong((__pyx_v_self->htsfile != NULL)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 340, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":338
 *         self.b = <bam1_t*>calloc(1, sizeof(bam1_t))
 * 
 *     def is_open(self):             # <<<<<<<<<<<<<<
 *         '''return true if htsfile has been opened.'''
 *         return self.htsfile != NULL
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.is_open", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":342
 *         return self.htsfile != NULL
 * 
 *     def has_index(self):             # <<<<<<<<<<<<<<
 *         """return true if htsfile has an existing (and opened) index.
 *         """
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_5has_index(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_4has_index[] = "AlignmentFile.has_index(self)\nreturn true if htsfile has an existing (and opened) index.\n        ";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_5has_index(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("has_index (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_4has_index(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_4has_index(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("has_index", 0);
  __Pyx_TraceCall("has_index", __pyx_f[0], 342, 0, __PYX_ERR(0, 342, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":345
 *         """return true if htsfile has an existing (and opened) index.
 *         """
 *         return self.index != NULL             # <<<<<<<<<<<<<<
 * 
 *     def check_index(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong((__pyx_v_self->index != NULL)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 345, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":342
 *         return self.htsfile != NULL
 * 
 *     def has_index(self):             # <<<<<<<<<<<<<<
 *         """return true if htsfile has an existing (and opened) index.
 *         """
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.has_index", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":347
 *         return self.index != NULL
 * 
 *     def check_index(self):             # <<<<<<<<<<<<<<
 *         """return True if index is present.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_7check_index(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_6check_index[] = "AlignmentFile.check_index(self)\nreturn True if index is present.\n\n        Raises\n        ------\n\n        AttributeError\n            if htsfile is :term:`SAM` formatted and thus has no index.\n\n        ValueError\n            if htsfile is closed or index could not be opened.\n        ";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_7check_index(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("check_index (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_6check_index(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_6check_index(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("check_index", 0);
  __Pyx_TraceCall("check_index", __pyx_f[0], 347, 0, __PYX_ERR(0, 347, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":360
 *         """
 * 
 *         if not self.is_open():             # <<<<<<<<<<<<<<
 *             raise ValueError("I/O operation on closed file")
 *         if not self.is_bam and not self.is_cram:
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_open); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 360, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 360, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 360, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 360, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = ((!__pyx_t_4) != 0);
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":361
 * 
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")             # <<<<<<<<<<<<<<
 *         if not self.is_bam and not self.is_cram:
 *             raise AttributeError(
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 361, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 361, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":360
 *         """
 * 
 *         if not self.is_open():             # <<<<<<<<<<<<<<
 *             raise ValueError("I/O operation on closed file")
 *         if not self.is_bam and not self.is_cram:
 */
  }

  /* "pysam/calignmentfile.pyx":362
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")
 *         if not self.is_bam and not self.is_cram:             # <<<<<<<<<<<<<<
 *             raise AttributeError(
 *                 "AlignmentFile.mapped only available in bam files")
 */
  __pyx_t_4 = ((!(__pyx_v_self->is_bam != 0)) != 0);
  if (__pyx_t_4) {
  } else {
    __pyx_t_5 = __pyx_t_4;
    goto __pyx_L5_bool_binop_done;
  }
  __pyx_t_4 = ((!(__pyx_v_self->is_cram != 0)) != 0);
  __pyx_t_5 = __pyx_t_4;
  __pyx_L5_bool_binop_done:;
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":363
 *             raise ValueError("I/O operation on closed file")
 *         if not self.is_bam and not self.is_cram:
 *             raise AttributeError(             # <<<<<<<<<<<<<<
 *                 "AlignmentFile.mapped only available in bam files")
 *         if self.index == NULL:
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_AttributeError, __pyx_tuple__7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 363, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 363, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":362
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")
 *         if not self.is_bam and not self.is_cram:             # <<<<<<<<<<<<<<
 *             raise AttributeError(
 *                 "AlignmentFile.mapped only available in bam files")
 */
  }

  /* "pysam/calignmentfile.pyx":365
 *             raise AttributeError(
 *                 "AlignmentFile.mapped only available in bam files")
 *         if self.index == NULL:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 "mapping information not recorded in index "
 */
  __pyx_t_5 = ((__pyx_v_self->index == NULL) != 0);
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":366
 *                 "AlignmentFile.mapped only available in bam files")
 *         if self.index == NULL:
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 "mapping information not recorded in index "
 *                 "or index not available")
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 366, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 366, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":365
 *             raise AttributeError(
 *                 "AlignmentFile.mapped only available in bam files")
 *         if self.index == NULL:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 "mapping information not recorded in index "
 */
  }

  /* "pysam/calignmentfile.pyx":369
 *                 "mapping information not recorded in index "
 *                 "or index not available")
 *         return True             # <<<<<<<<<<<<<<
 * 
 *     def _open(self,
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_True);
  __pyx_r = Py_True;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":347
 *         return self.index != NULL
 * 
 *     def check_index(self):             # <<<<<<<<<<<<<<
 *         """return True if index is present.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.check_index", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":371
 *         return True
 * 
 *     def _open(self,             # <<<<<<<<<<<<<<
 *               filepath_or_object,
 *               mode=None,
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_9_open(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_8_open[] = "AlignmentFile._open(self, filepath_or_object, mode=None, AlignmentFile template=None, reference_names=None, reference_lengths=None, reference_filename=None, text=None, header=None, port=None, add_sq_text=True, check_header=True, check_sq=True, filepath_index=None, referencenames=None, referencelengths=None)\nopen a sam, bam or cram formatted file.\n\n        If _open is called on an existing file, the current file\n        will be closed and a new file will be opened.\n        ";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_9_open(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_filepath_or_object = 0;
  PyObject *__pyx_v_mode = 0;
  struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_template = 0;
  PyObject *__pyx_v_reference_names = 0;
  PyObject *__pyx_v_reference_lengths = 0;
  PyObject *__pyx_v_reference_filename = 0;
  PyObject *__pyx_v_text = 0;
  PyObject *__pyx_v_header = 0;
  CYTHON_UNUSED PyObject *__pyx_v_port = 0;
  PyObject *__pyx_v_add_sq_text = 0;
  PyObject *__pyx_v_check_header = 0;
  PyObject *__pyx_v_check_sq = 0;
  PyObject *__pyx_v_filepath_index = 0;
  PyObject *__pyx_v_referencenames = 0;
  PyObject *__pyx_v_referencelengths = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("_open (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_filepath_or_object,&__pyx_n_s_mode,&__pyx_n_s_template,&__pyx_n_s_reference_names,&__pyx_n_s_reference_lengths,&__pyx_n_s_reference_filename,&__pyx_n_s_text,&__pyx_n_s_header,&__pyx_n_s_port,&__pyx_n_s_add_sq_text,&__pyx_n_s_check_header,&__pyx_n_s_check_sq,&__pyx_n_s_filepath_index,&__pyx_n_s_referencenames,&__pyx_n_s_referencelengths,0};
    PyObject* values[15] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

    /* "pysam/calignmentfile.pyx":373
 *     def _open(self,
 *               filepath_or_object,
 *               mode=None,             # <<<<<<<<<<<<<<
 *               AlignmentFile template=None,
 *               reference_names=None,
 */
    values[1] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":374
 *               filepath_or_object,
 *               mode=None,
 *               AlignmentFile template=None,             # <<<<<<<<<<<<<<
 *               reference_names=None,
 *               reference_lengths=None,
 */
    values[2] = (PyObject *)((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)Py_None);

    /* "pysam/calignmentfile.pyx":375
 *               mode=None,
 *               AlignmentFile template=None,
 *               reference_names=None,             # <<<<<<<<<<<<<<
 *               reference_lengths=None,
 *               reference_filename=None,
 */
    values[3] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":376
 *               AlignmentFile template=None,
 *               reference_names=None,
 *               reference_lengths=None,             # <<<<<<<<<<<<<<
 *               reference_filename=None,
 *               text=None,
 */
    values[4] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":377
 *               reference_names=None,
 *               reference_lengths=None,
 *               reference_filename=None,             # <<<<<<<<<<<<<<
 *               text=None,
 *               header=None,
 */
    values[5] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":378
 *               reference_lengths=None,
 *               reference_filename=None,
 *               text=None,             # <<<<<<<<<<<<<<
 *               header=None,
 *               port=None,
 */
    values[6] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":379
 *               reference_filename=None,
 *               text=None,
 *               header=None,             # <<<<<<<<<<<<<<
 *               port=None,
 *               add_sq_text=True,
 */
    values[7] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":380
 *               text=None,
 *               header=None,
 *               port=None,             # <<<<<<<<<<<<<<
 *               add_sq_text=True,
 *               check_header=True,
 */
    values[8] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":381
 *               header=None,
 *               port=None,
 *               add_sq_text=True,             # <<<<<<<<<<<<<<
 *               check_header=True,
 *               check_sq=True,
 */
    values[9] = ((PyObject *)Py_True);

    /* "pysam/calignmentfile.pyx":382
 *               port=None,
 *               add_sq_text=True,
 *               check_header=True,             # <<<<<<<<<<<<<<
 *               check_sq=True,
 *               filepath_index=None,
 */
    values[10] = ((PyObject *)Py_True);

    /* "pysam/calignmentfile.pyx":383
 *               add_sq_text=True,
 *               check_header=True,
 *               check_sq=True,             # <<<<<<<<<<<<<<
 *               filepath_index=None,
 *               referencenames=None,
 */
    values[11] = ((PyObject *)Py_True);

    /* "pysam/calignmentfile.pyx":384
 *               check_header=True,
 *               check_sq=True,
 *               filepath_index=None,             # <<<<<<<<<<<<<<
 *               referencenames=None,
 *               referencelengths=None):
 */
    values[12] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":385
 *               check_sq=True,
 *               filepath_index=None,
 *               referencenames=None,             # <<<<<<<<<<<<<<
 *               referencelengths=None):
 *         '''open a sam, bam or cram formatted file.
 */
    values[13] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":386
 *               filepath_index=None,
 *               referencenames=None,
 *               referencelengths=None):             # <<<<<<<<<<<<<<
 *         '''open a sam, bam or cram formatted file.
 * 
 */
    values[14] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case 15: values[14] = PyTuple_GET_ITEM(__pyx_args, 14);
        case 14: values[13] = PyTuple_GET_ITEM(__pyx_args, 13);
        case 13: values[12] = PyTuple_GET_ITEM(__pyx_args, 12);
        case 12: values[11] = PyTuple_GET_ITEM(__pyx_args, 11);
        case 11: values[10] = PyTuple_GET_ITEM(__pyx_args, 10);
        case 10: values[9] = PyTuple_GET_ITEM(__pyx_args, 9);
        case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_filepath_or_object)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_mode);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_template);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_reference_names);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_reference_lengths);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_reference_filename);
          if (value) { values[5] = value; kw_args--; }
        }
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_text);
          if (value) { values[6] = value; kw_args--; }
        }
        case  7:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_header);
          if (value) { values[7] = value; kw_args--; }
        }
        case  8:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_port);
          if (value) { values[8] = value; kw_args--; }
        }
        case  9:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_add_sq_text);
          if (value) { values[9] = value; kw_args--; }
        }
        case 10:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_check_header);
          if (value) { values[10] = value; kw_args--; }
        }
        case 11:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_check_sq);
          if (value) { values[11] = value; kw_args--; }
        }
        case 12:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_filepath_index);
          if (value) { values[12] = value; kw_args--; }
        }
        case 13:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_referencenames);
          if (value) { values[13] = value; kw_args--; }
        }
        case 14:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_referencelengths);
          if (value) { values[14] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "_open") < 0)) __PYX_ERR(0, 371, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case 15: values[14] = PyTuple_GET_ITEM(__pyx_args, 14);
        case 14: values[13] = PyTuple_GET_ITEM(__pyx_args, 13);
        case 13: values[12] = PyTuple_GET_ITEM(__pyx_args, 12);
        case 12: values[11] = PyTuple_GET_ITEM(__pyx_args, 11);
        case 11: values[10] = PyTuple_GET_ITEM(__pyx_args, 10);
        case 10: values[9] = PyTuple_GET_ITEM(__pyx_args, 9);
        case  9: values[8] = PyTuple_GET_ITEM(__pyx_args, 8);
        case  8: values[7] = PyTuple_GET_ITEM(__pyx_args, 7);
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_filepath_or_object = values[0];
    __pyx_v_mode = values[1];
    __pyx_v_template = ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)values[2]);
    __pyx_v_reference_names = values[3];
    __pyx_v_reference_lengths = values[4];
    __pyx_v_reference_filename = values[5];
    __pyx_v_text = values[6];
    __pyx_v_header = values[7];
    __pyx_v_port = values[8];
    __pyx_v_add_sq_text = values[9];
    __pyx_v_check_header = values[10];
    __pyx_v_check_sq = values[11];
    __pyx_v_filepath_index = values[12];
    __pyx_v_referencenames = values[13];
    __pyx_v_referencelengths = values[14];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("_open", 0, 1, 15, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 371, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile._open", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_template), __pyx_ptype_5pysam_14calignmentfile_AlignmentFile, 1, "template", 0))) __PYX_ERR(0, 374, __pyx_L1_error)
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_8_open(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self), __pyx_v_filepath_or_object, __pyx_v_mode, __pyx_v_template, __pyx_v_reference_names, __pyx_v_reference_lengths, __pyx_v_reference_filename, __pyx_v_text, __pyx_v_header, __pyx_v_port, __pyx_v_add_sq_text, __pyx_v_check_header, __pyx_v_check_sq, __pyx_v_filepath_index, __pyx_v_referencenames, __pyx_v_referencelengths);

  /* "pysam/calignmentfile.pyx":371
 *         return True
 * 
 *     def _open(self,             # <<<<<<<<<<<<<<
 *               filepath_or_object,
 *               mode=None,
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_8_open(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_filepath_or_object, PyObject *__pyx_v_mode, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_template, PyObject *__pyx_v_reference_names, PyObject *__pyx_v_reference_lengths, PyObject *__pyx_v_reference_filename, PyObject *__pyx_v_text, PyObject *__pyx_v_header, CYTHON_UNUSED PyObject *__pyx_v_port, PyObject *__pyx_v_add_sq_text, PyObject *__pyx_v_check_header, PyObject *__pyx_v_check_sq, PyObject *__pyx_v_filepath_index, PyObject *__pyx_v_referencenames, PyObject *__pyx_v_referencelengths) {
  char *__pyx_v_cfilename;
  char *__pyx_v_cindexname;
  char *__pyx_v_cmode;
  PyObject *__pyx_v_filename = NULL;
  PyObject *__pyx_v_bmode = 0;
  char *__pyx_v_ctext;
  hFILE *__pyx_v_fp;
  PyObject *__pyx_v_n = NULL;
  PyObject *__pyx_v_x = NULL;
  PyObject *__pyx_v_name = NULL;
  PyObject *__pyx_v_fn = NULL;
  int __pyx_v_format_index;
  int __pyx_v_has_index;
  PyObject *__pyx_v_ref = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  char const *__pyx_t_6;
  Py_ssize_t __pyx_t_7;
  Py_ssize_t __pyx_t_8;
  PyObject *(*__pyx_t_9)(PyObject *);
  size_t __pyx_t_10;
  int32_t __pyx_t_11;
  long __pyx_t_12;
  uint32_t __pyx_t_13;
  char const *__pyx_t_14;
  int __pyx_t_15;
  int __pyx_t_16;
  char *__pyx_t_17;
  char *__pyx_t_18;
  int __pyx_t_19;
  char const *__pyx_t_20;
  PyObject *__pyx_t_21 = NULL;
  PyObject *__pyx_t_22 = NULL;
  int64_t __pyx_t_23;
  __Pyx_RefNannySetupContext("_open", 0);
  __Pyx_TraceCall("_open", __pyx_f[0], 371, 0, __PYX_ERR(0, 371, __pyx_L1_error));
  __Pyx_INCREF(__pyx_v_mode);
  __Pyx_INCREF(__pyx_v_reference_names);
  __Pyx_INCREF(__pyx_v_reference_lengths);
  __Pyx_INCREF(__pyx_v_text);
  __Pyx_INCREF(__pyx_v_filepath_index);

  /* "pysam/calignmentfile.pyx":397
 * 
 *         # for backwards compatibility:
 *         if referencenames is not None:             # <<<<<<<<<<<<<<
 *             reference_names = referencenames
 *         if referencelengths is not None:
 */
  __pyx_t_1 = (__pyx_v_referencenames != Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pysam/calignmentfile.pyx":398
 *         # for backwards compatibility:
 *         if referencenames is not None:
 *             reference_names = referencenames             # <<<<<<<<<<<<<<
 *         if referencelengths is not None:
 *             reference_lengths = referencelengths
 */
    __Pyx_INCREF(__pyx_v_referencenames);
    __Pyx_DECREF_SET(__pyx_v_reference_names, __pyx_v_referencenames);

    /* "pysam/calignmentfile.pyx":397
 * 
 *         # for backwards compatibility:
 *         if referencenames is not None:             # <<<<<<<<<<<<<<
 *             reference_names = referencenames
 *         if referencelengths is not None:
 */
  }

  /* "pysam/calignmentfile.pyx":399
 *         if referencenames is not None:
 *             reference_names = referencenames
 *         if referencelengths is not None:             # <<<<<<<<<<<<<<
 *             reference_lengths = referencelengths
 * 
 */
  __pyx_t_2 = (__pyx_v_referencelengths != Py_None);
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":400
 *             reference_names = referencenames
 *         if referencelengths is not None:
 *             reference_lengths = referencelengths             # <<<<<<<<<<<<<<
 * 
 *         # autodetection for read
 */
    __Pyx_INCREF(__pyx_v_referencelengths);
    __Pyx_DECREF_SET(__pyx_v_reference_lengths, __pyx_v_referencelengths);

    /* "pysam/calignmentfile.pyx":399
 *         if referencenames is not None:
 *             reference_names = referencenames
 *         if referencelengths is not None:             # <<<<<<<<<<<<<<
 *             reference_lengths = referencelengths
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":403
 * 
 *         # autodetection for read
 *         if mode is None:             # <<<<<<<<<<<<<<
 *             mode = "r"
 * 
 */
  __pyx_t_1 = (__pyx_v_mode == Py_None);
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pysam/calignmentfile.pyx":404
 *         # autodetection for read
 *         if mode is None:
 *             mode = "r"             # <<<<<<<<<<<<<<
 * 
 *         assert mode in ("r", "w", "rb", "wb", "wh",
 */
    __Pyx_INCREF(__pyx_n_s_r);
    __Pyx_DECREF_SET(__pyx_v_mode, __pyx_n_s_r);

    /* "pysam/calignmentfile.pyx":403
 * 
 *         # autodetection for read
 *         if mode is None:             # <<<<<<<<<<<<<<
 *             mode = "r"
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":406
 *             mode = "r"
 * 
 *         assert mode in ("r", "w", "rb", "wb", "wh",             # <<<<<<<<<<<<<<
 *                         "wbu", "rU", "wb0",
 *                         "rc", "wc"), \
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!Py_OptimizeFlag)) {
    __Pyx_INCREF(__pyx_v_mode);
    __pyx_t_3 = __pyx_v_mode;
    __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_t_3, __pyx_n_s_r, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 406, __pyx_L1_error)
    if (!__pyx_t_1) {
    } else {
      __pyx_t_2 = __pyx_t_1;
      goto __pyx_L6_bool_binop_done;
    }
    __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_t_3, __pyx_n_s_w, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 406, __pyx_L1_error)
    if (!__pyx_t_1) {
    } else {
      __pyx_t_2 = __pyx_t_1;
      goto __pyx_L6_bool_binop_done;
    }
    __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_t_3, __pyx_n_s_rb, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 406, __pyx_L1_error)
    if (!__pyx_t_1) {
    } else {
      __pyx_t_2 = __pyx_t_1;
      goto __pyx_L6_bool_binop_done;
    }
    __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_t_3, __pyx_n_s_wb, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 406, __pyx_L1_error)
    if (!__pyx_t_1) {
    } else {
      __pyx_t_2 = __pyx_t_1;
      goto __pyx_L6_bool_binop_done;
    }
    __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_t_3, __pyx_n_s_wh, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 406, __pyx_L1_error)
    if (!__pyx_t_1) {
    } else {
      __pyx_t_2 = __pyx_t_1;
      goto __pyx_L6_bool_binop_done;
    }
    __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_t_3, __pyx_n_s_wbu, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 406, __pyx_L1_error)
    if (!__pyx_t_1) {
    } else {
      __pyx_t_2 = __pyx_t_1;
      goto __pyx_L6_bool_binop_done;
    }
    __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_t_3, __pyx_n_s_rU, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 406, __pyx_L1_error)
    if (!__pyx_t_1) {
    } else {
      __pyx_t_2 = __pyx_t_1;
      goto __pyx_L6_bool_binop_done;
    }
    __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_t_3, __pyx_n_s_wb0, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 406, __pyx_L1_error)
    if (!__pyx_t_1) {
    } else {
      __pyx_t_2 = __pyx_t_1;
      goto __pyx_L6_bool_binop_done;
    }
    __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_t_3, __pyx_n_s_rc, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 406, __pyx_L1_error)
    if (!__pyx_t_1) {
    } else {
      __pyx_t_2 = __pyx_t_1;
      goto __pyx_L6_bool_binop_done;
    }
    __pyx_t_1 = (__Pyx_PyString_Equals(__pyx_t_3, __pyx_n_s_wc, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 406, __pyx_L1_error)
    __pyx_t_2 = __pyx_t_1;
    __pyx_L6_bool_binop_done:;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (unlikely(!(__pyx_t_2 != 0))) {

      /* "pysam/calignmentfile.pyx":409
 *                         "wbu", "rU", "wb0",
 *                         "rc", "wc"), \
 *             "invalid file opening mode `%s`" % mode             # <<<<<<<<<<<<<<
 * 
 *         # close a previously opened file
 */
      __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_invalid_file_opening_mode_s, __pyx_v_mode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 409, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      PyErr_SetObject(PyExc_AssertionError, __pyx_t_3);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __PYX_ERR(0, 406, __pyx_L1_error)
    }
  }
  #endif

  /* "pysam/calignmentfile.pyx":412
 * 
 *         # close a previously opened file
 *         if self.htsfile != NULL:             # <<<<<<<<<<<<<<
 *             self.close()
 * 
 */
  __pyx_t_2 = ((__pyx_v_self->htsfile != NULL) != 0);
  if (__pyx_t_2) {

    /* "pysam/calignmentfile.pyx":413
 *         # close a previously opened file
 *         if self.htsfile != NULL:
 *             self.close()             # <<<<<<<<<<<<<<
 * 
 *         # StringIO not supported
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_close); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 413, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    if (__pyx_t_5) {
      __pyx_t_3 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 413, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    } else {
      __pyx_t_3 = __Pyx_PyObject_CallNoArg(__pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 413, __pyx_L1_error)
    }
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "pysam/calignmentfile.pyx":412
 * 
 *         # close a previously opened file
 *         if self.htsfile != NULL:             # <<<<<<<<<<<<<<
 *             self.close()
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":416
 * 
 *         # StringIO not supported
 *         if isinstance(filepath_or_object, StringIO):             # <<<<<<<<<<<<<<
 *             filename = "stringio"
 *             raise NotImplementedError(
 */
  __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_StringIO); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 416, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyObject_IsInstance(__pyx_v_filepath_or_object, __pyx_t_3); if (unlikely(__pyx_t_2 == -1)) __PYX_ERR(0, 416, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_1 = (__pyx_t_2 != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":417
 *         # StringIO not supported
 *         if isinstance(filepath_or_object, StringIO):
 *             filename = "stringio"             # <<<<<<<<<<<<<<
 *             raise NotImplementedError(
 *                 "access from StringIO objects not supported")
 */
    __Pyx_INCREF(__pyx_n_s_stringio);
    __pyx_v_filename = __pyx_n_s_stringio;

    /* "pysam/calignmentfile.pyx":418
 *         if isinstance(filepath_or_object, StringIO):
 *             filename = "stringio"
 *             raise NotImplementedError(             # <<<<<<<<<<<<<<
 *                 "access from StringIO objects not supported")
 *             if filepath_or_object.closed:
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__9, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 418, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 418, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":416
 * 
 *         # StringIO not supported
 *         if isinstance(filepath_or_object, StringIO):             # <<<<<<<<<<<<<<
 *             filename = "stringio"
 *             raise NotImplementedError(
 */
  }

  /* "pysam/calignmentfile.pyx":423
 *                 raise ValueError('I/O operation on closed StringIO object')
 *         # check if we are working with a File object
 *         elif hasattr(filepath_or_object, "fileno"):             # <<<<<<<<<<<<<<
 *             filename = filepath_or_object.name
 *             if filepath_or_object.closed:
 */
  __pyx_t_1 = PyObject_HasAttr(__pyx_v_filepath_or_object, __pyx_n_s_fileno); if (unlikely(__pyx_t_1 == -1)) __PYX_ERR(0, 423, __pyx_L1_error)
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pysam/calignmentfile.pyx":424
 *         # check if we are working with a File object
 *         elif hasattr(filepath_or_object, "fileno"):
 *             filename = filepath_or_object.name             # <<<<<<<<<<<<<<
 *             if filepath_or_object.closed:
 *                 raise ValueError('I/O operation on closed file')
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_filepath_or_object, __pyx_n_s_name); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 424, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_v_filename = __pyx_t_3;
    __pyx_t_3 = 0;

    /* "pysam/calignmentfile.pyx":425
 *         elif hasattr(filepath_or_object, "fileno"):
 *             filename = filepath_or_object.name
 *             if filepath_or_object.closed:             # <<<<<<<<<<<<<<
 *                 raise ValueError('I/O operation on closed file')
 *         else:
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_filepath_or_object, __pyx_n_s_closed); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 425, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 425, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (__pyx_t_2) {

      /* "pysam/calignmentfile.pyx":426
 *             filename = filepath_or_object.name
 *             if filepath_or_object.closed:
 *                 raise ValueError('I/O operation on closed file')             # <<<<<<<<<<<<<<
 *         else:
 *             filename = filepath_or_object
 */
      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__10, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 426, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_Raise(__pyx_t_3, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __PYX_ERR(0, 426, __pyx_L1_error)

      /* "pysam/calignmentfile.pyx":425
 *         elif hasattr(filepath_or_object, "fileno"):
 *             filename = filepath_or_object.name
 *             if filepath_or_object.closed:             # <<<<<<<<<<<<<<
 *                 raise ValueError('I/O operation on closed file')
 *         else:
 */
    }

    /* "pysam/calignmentfile.pyx":423
 *                 raise ValueError('I/O operation on closed StringIO object')
 *         # check if we are working with a File object
 *         elif hasattr(filepath_or_object, "fileno"):             # <<<<<<<<<<<<<<
 *             filename = filepath_or_object.name
 *             if filepath_or_object.closed:
 */
    goto __pyx_L17;
  }

  /* "pysam/calignmentfile.pyx":428
 *                 raise ValueError('I/O operation on closed file')
 *         else:
 *             filename = filepath_or_object             # <<<<<<<<<<<<<<
 * 
 *         # for htslib, wbu seems to not work
 */
  /*else*/ {
    __Pyx_INCREF(__pyx_v_filepath_or_object);
    __pyx_v_filename = __pyx_v_filepath_or_object;
  }
  __pyx_L17:;

  /* "pysam/calignmentfile.pyx":431
 * 
 *         # for htslib, wbu seems to not work
 *         if mode == "wbu":             # <<<<<<<<<<<<<<
 *             mode = "wb0"
 * 
 */
  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_v_mode, __pyx_n_s_wbu, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 431, __pyx_L1_error)
  if (__pyx_t_2) {

    /* "pysam/calignmentfile.pyx":432
 *         # for htslib, wbu seems to not work
 *         if mode == "wbu":
 *             mode = "wb0"             # <<<<<<<<<<<<<<
 * 
 *         cdef bytes bmode = mode.encode('ascii')
 */
    __Pyx_INCREF(__pyx_n_s_wb0);
    __Pyx_DECREF_SET(__pyx_v_mode, __pyx_n_s_wb0);

    /* "pysam/calignmentfile.pyx":431
 * 
 *         # for htslib, wbu seems to not work
 *         if mode == "wbu":             # <<<<<<<<<<<<<<
 *             mode = "wb0"
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":434
 *             mode = "wb0"
 * 
 *         cdef bytes bmode = mode.encode('ascii')             # <<<<<<<<<<<<<<
 *         self._filename = filename = encode_filename(filename)
 * 
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_mode, __pyx_n_s_encode); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 434, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__11, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 434, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (!(likely(PyBytes_CheckExact(__pyx_t_4))||((__pyx_t_4) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "bytes", Py_TYPE(__pyx_t_4)->tp_name), 0))) __PYX_ERR(0, 434, __pyx_L1_error)
  __pyx_v_bmode = ((PyObject*)__pyx_t_4);
  __pyx_t_4 = 0;

  /* "pysam/calignmentfile.pyx":435
 * 
 *         cdef bytes bmode = mode.encode('ascii')
 *         self._filename = filename = encode_filename(filename)             # <<<<<<<<<<<<<<
 * 
 *         # FIXME: Use htsFormat when it is available
 */
  __pyx_t_4 = __pyx_f_5pysam_6cutils_encode_filename(__pyx_v_filename); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 435, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_INCREF(__pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_4);
  __Pyx_GOTREF(__pyx_v_self->_filename);
  __Pyx_DECREF(__pyx_v_self->_filename);
  __pyx_v_self->_filename = __pyx_t_4;
  __Pyx_INCREF(__pyx_t_4);
  __Pyx_DECREF_SET(__pyx_v_filename, __pyx_t_4);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pysam/calignmentfile.pyx":438
 * 
 *         # FIXME: Use htsFormat when it is available
 *         self.is_stream = filename == b"-"             # <<<<<<<<<<<<<<
 *         self.is_remote = hisremote(filename)
 * 
 */
  __pyx_t_4 = PyObject_RichCompare(__pyx_v_filename, __pyx_kp_b__12, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 438, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 438, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_v_self->is_stream = __pyx_t_2;

  /* "pysam/calignmentfile.pyx":439
 *         # FIXME: Use htsFormat when it is available
 *         self.is_stream = filename == b"-"
 *         self.is_remote = hisremote(filename)             # <<<<<<<<<<<<<<
 * 
 *         cdef char * ctext
 */
  __pyx_t_6 = __Pyx_PyObject_AsString(__pyx_v_filename); if (unlikely((!__pyx_t_6) && PyErr_Occurred())) __PYX_ERR(0, 439, __pyx_L1_error)
  __pyx_v_self->is_remote = hisremote(__pyx_t_6);

  /* "pysam/calignmentfile.pyx":443
 *         cdef char * ctext
 *         cdef hFILE * fp
 *         ctext = NULL             # <<<<<<<<<<<<<<
 * 
 *         if mode[0] == 'w':
 */
  __pyx_v_ctext = NULL;

  /* "pysam/calignmentfile.pyx":445
 *         ctext = NULL
 * 
 *         if mode[0] == 'w':             # <<<<<<<<<<<<<<
 *             # open file for writing
 * 
 */
  __pyx_t_4 = __Pyx_GetItemInt(__pyx_v_mode, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 445, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_t_4, __pyx_n_s_w, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 445, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (__pyx_t_2) {

    /* "pysam/calignmentfile.pyx":449
 * 
 *             # header structure (used for writing)
 *             if template:             # <<<<<<<<<<<<<<
 *                 self.header = bam_hdr_dup(template.header)
 *             elif header:
 */
    __pyx_t_2 = __Pyx_PyObject_IsTrue(((PyObject *)__pyx_v_template)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 449, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "pysam/calignmentfile.pyx":450
 *             # header structure (used for writing)
 *             if template:
 *                 self.header = bam_hdr_dup(template.header)             # <<<<<<<<<<<<<<
 *             elif header:
 *                 self.header = build_header(header)
 */
      __pyx_v_self->header = bam_hdr_dup(__pyx_v_template->header);

      /* "pysam/calignmentfile.pyx":449
 * 
 *             # header structure (used for writing)
 *             if template:             # <<<<<<<<<<<<<<
 *                 self.header = bam_hdr_dup(template.header)
 *             elif header:
 */
      goto __pyx_L21;
    }

    /* "pysam/calignmentfile.pyx":451
 *             if template:
 *                 self.header = bam_hdr_dup(template.header)
 *             elif header:             # <<<<<<<<<<<<<<
 *                 self.header = build_header(header)
 *             else:
 */
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_header); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 451, __pyx_L1_error)
    if (__pyx_t_2) {

      /* "pysam/calignmentfile.pyx":452
 *                 self.header = bam_hdr_dup(template.header)
 *             elif header:
 *                 self.header = build_header(header)             # <<<<<<<<<<<<<<
 *             else:
 *                 # build header from a target names and lengths
 */
      __pyx_v_self->header = __pyx_f_5pysam_14calignmentfile_build_header(__pyx_v_header);

      /* "pysam/calignmentfile.pyx":451
 *             if template:
 *                 self.header = bam_hdr_dup(template.header)
 *             elif header:             # <<<<<<<<<<<<<<
 *                 self.header = build_header(header)
 *             else:
 */
      goto __pyx_L21;
    }

    /* "pysam/calignmentfile.pyx":455
 *             else:
 *                 # build header from a target names and lengths
 *                 assert reference_names and reference_lengths, \             # <<<<<<<<<<<<<<
 *                     ("either supply options `template`, `header` "
 *                      "or  both `reference_names` and `reference_lengths` "
 */
    /*else*/ {
      #ifndef CYTHON_WITHOUT_ASSERTIONS
      if (unlikely(!Py_OptimizeFlag)) {
        __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_reference_names); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 455, __pyx_L1_error)
        if (__pyx_t_1) {
        } else {
          __pyx_t_2 = __pyx_t_1;
          goto __pyx_L22_bool_binop_done;
        }
        __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_reference_lengths); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 455, __pyx_L1_error)
        __pyx_t_2 = __pyx_t_1;
        __pyx_L22_bool_binop_done:;
        if (unlikely(!__pyx_t_2)) {
          PyErr_SetObject(PyExc_AssertionError, __pyx_kp_s_either_supply_options_template_h);
          __PYX_ERR(0, 455, __pyx_L1_error)
        }
      }
      #endif

      /* "pysam/calignmentfile.pyx":459
 *                      "or  both `reference_names` and `reference_lengths` "
 *                      "for writing")
 *                 assert len(reference_names) == len(reference_lengths), \             # <<<<<<<<<<<<<<
 *                     "unequal names and lengths of reference sequences"
 * 
 */
      #ifndef CYTHON_WITHOUT_ASSERTIONS
      if (unlikely(!Py_OptimizeFlag)) {
        __pyx_t_7 = PyObject_Length(__pyx_v_reference_names); if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 459, __pyx_L1_error)
        __pyx_t_8 = PyObject_Length(__pyx_v_reference_lengths); if (unlikely(__pyx_t_8 == -1)) __PYX_ERR(0, 459, __pyx_L1_error)
        if (unlikely(!((__pyx_t_7 == __pyx_t_8) != 0))) {
          PyErr_SetObject(PyExc_AssertionError, __pyx_kp_s_unequal_names_and_lengths_of_ref);
          __PYX_ERR(0, 459, __pyx_L1_error)
        }
      }
      #endif

      /* "pysam/calignmentfile.pyx":463
 * 
 *                 # allocate and fill header
 *                 reference_names = [force_bytes(ref) for ref in reference_names]             # <<<<<<<<<<<<<<
 *                 self.header = bam_hdr_init()
 *                 self.header.n_targets = len(reference_names)
 */
      __pyx_t_4 = PyList_New(0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 463, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      if (likely(PyList_CheckExact(__pyx_v_reference_names)) || PyTuple_CheckExact(__pyx_v_reference_names)) {
        __pyx_t_3 = __pyx_v_reference_names; __Pyx_INCREF(__pyx_t_3); __pyx_t_8 = 0;
        __pyx_t_9 = NULL;
      } else {
        __pyx_t_8 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_v_reference_names); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 463, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_9 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 463, __pyx_L1_error)
      }
      for (;;) {
        if (likely(!__pyx_t_9)) {
          if (likely(PyList_CheckExact(__pyx_t_3))) {
            if (__pyx_t_8 >= PyList_GET_SIZE(__pyx_t_3)) break;
            #if CYTHON_COMPILING_IN_CPYTHON
            __pyx_t_5 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_8); __Pyx_INCREF(__pyx_t_5); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 463, __pyx_L1_error)
            #else
            __pyx_t_5 = PySequence_ITEM(__pyx_t_3, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 463, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_5);
            #endif
          } else {
            if (__pyx_t_8 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
            #if CYTHON_COMPILING_IN_CPYTHON
            __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_8); __Pyx_INCREF(__pyx_t_5); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 463, __pyx_L1_error)
            #else
            __pyx_t_5 = PySequence_ITEM(__pyx_t_3, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 463, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_5);
            #endif
          }
        } else {
          __pyx_t_5 = __pyx_t_9(__pyx_t_3);
          if (unlikely(!__pyx_t_5)) {
            PyObject* exc_type = PyErr_Occurred();
            if (exc_type) {
              if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
              else __PYX_ERR(0, 463, __pyx_L1_error)
            }
            break;
          }
          __Pyx_GOTREF(__pyx_t_5);
        }
        __Pyx_XDECREF_SET(__pyx_v_ref, __pyx_t_5);
        __pyx_t_5 = 0;
        __pyx_t_5 = __pyx_f_5pysam_6cutils_force_bytes(__pyx_v_ref, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 463, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        if (unlikely(__Pyx_ListComp_Append(__pyx_t_4, (PyObject*)__pyx_t_5))) __PYX_ERR(0, 463, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      }
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF_SET(__pyx_v_reference_names, __pyx_t_4);
      __pyx_t_4 = 0;

      /* "pysam/calignmentfile.pyx":464
 *                 # allocate and fill header
 *                 reference_names = [force_bytes(ref) for ref in reference_names]
 *                 self.header = bam_hdr_init()             # <<<<<<<<<<<<<<
 *                 self.header.n_targets = len(reference_names)
 *                 n = 0
 */
      __pyx_v_self->header = bam_hdr_init();

      /* "pysam/calignmentfile.pyx":465
 *                 reference_names = [force_bytes(ref) for ref in reference_names]
 *                 self.header = bam_hdr_init()
 *                 self.header.n_targets = len(reference_names)             # <<<<<<<<<<<<<<
 *                 n = 0
 *                 for x in reference_names:
 */
      __pyx_t_8 = PyObject_Length(__pyx_v_reference_names); if (unlikely(__pyx_t_8 == -1)) __PYX_ERR(0, 465, __pyx_L1_error)
      __pyx_v_self->header->n_targets = __pyx_t_8;

      /* "pysam/calignmentfile.pyx":466
 *                 self.header = bam_hdr_init()
 *                 self.header.n_targets = len(reference_names)
 *                 n = 0             # <<<<<<<<<<<<<<
 *                 for x in reference_names:
 *                     n += len(x) + 1
 */
      __Pyx_INCREF(__pyx_int_0);
      __pyx_v_n = __pyx_int_0;

      /* "pysam/calignmentfile.pyx":467
 *                 self.header.n_targets = len(reference_names)
 *                 n = 0
 *                 for x in reference_names:             # <<<<<<<<<<<<<<
 *                     n += len(x) + 1
 *                 self.header.target_name = <char**>calloc(
 */
      if (likely(PyList_CheckExact(__pyx_v_reference_names)) || PyTuple_CheckExact(__pyx_v_reference_names)) {
        __pyx_t_4 = __pyx_v_reference_names; __Pyx_INCREF(__pyx_t_4); __pyx_t_8 = 0;
        __pyx_t_9 = NULL;
      } else {
        __pyx_t_8 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_reference_names); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 467, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __pyx_t_9 = Py_TYPE(__pyx_t_4)->tp_iternext; if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 467, __pyx_L1_error)
      }
      for (;;) {
        if (likely(!__pyx_t_9)) {
          if (likely(PyList_CheckExact(__pyx_t_4))) {
            if (__pyx_t_8 >= PyList_GET_SIZE(__pyx_t_4)) break;
            #if CYTHON_COMPILING_IN_CPYTHON
            __pyx_t_3 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_8); __Pyx_INCREF(__pyx_t_3); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 467, __pyx_L1_error)
            #else
            __pyx_t_3 = PySequence_ITEM(__pyx_t_4, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 467, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_3);
            #endif
          } else {
            if (__pyx_t_8 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
            #if CYTHON_COMPILING_IN_CPYTHON
            __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_8); __Pyx_INCREF(__pyx_t_3); __pyx_t_8++; if (unlikely(0 < 0)) __PYX_ERR(0, 467, __pyx_L1_error)
            #else
            __pyx_t_3 = PySequence_ITEM(__pyx_t_4, __pyx_t_8); __pyx_t_8++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 467, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_3);
            #endif
          }
        } else {
          __pyx_t_3 = __pyx_t_9(__pyx_t_4);
          if (unlikely(!__pyx_t_3)) {
            PyObject* exc_type = PyErr_Occurred();
            if (exc_type) {
              if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
              else __PYX_ERR(0, 467, __pyx_L1_error)
            }
            break;
          }
          __Pyx_GOTREF(__pyx_t_3);
        }
        __Pyx_XDECREF_SET(__pyx_v_x, __pyx_t_3);
        __pyx_t_3 = 0;

        /* "pysam/calignmentfile.pyx":468
 *                 n = 0
 *                 for x in reference_names:
 *                     n += len(x) + 1             # <<<<<<<<<<<<<<
 *                 self.header.target_name = <char**>calloc(
 *                     n, sizeof(char*))
 */
        __pyx_t_7 = PyObject_Length(__pyx_v_x); if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 468, __pyx_L1_error)
        __pyx_t_3 = PyInt_FromSsize_t((__pyx_t_7 + 1)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 468, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_5 = PyNumber_InPlaceAdd(__pyx_v_n, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 468, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_DECREF_SET(__pyx_v_n, __pyx_t_5);
        __pyx_t_5 = 0;

        /* "pysam/calignmentfile.pyx":467
 *                 self.header.n_targets = len(reference_names)
 *                 n = 0
 *                 for x in reference_names:             # <<<<<<<<<<<<<<
 *                     n += len(x) + 1
 *                 self.header.target_name = <char**>calloc(
 */
      }
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

      /* "pysam/calignmentfile.pyx":470
 *                     n += len(x) + 1
 *                 self.header.target_name = <char**>calloc(
 *                     n, sizeof(char*))             # <<<<<<<<<<<<<<
 *                 self.header.target_len = <uint32_t*>calloc(
 *                     n, sizeof(uint32_t))
 */
      __pyx_t_10 = __Pyx_PyInt_As_size_t(__pyx_v_n); if (unlikely((__pyx_t_10 == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 470, __pyx_L1_error)

      /* "pysam/calignmentfile.pyx":469
 *                 for x in reference_names:
 *                     n += len(x) + 1
 *                 self.header.target_name = <char**>calloc(             # <<<<<<<<<<<<<<
 *                     n, sizeof(char*))
 *                 self.header.target_len = <uint32_t*>calloc(
 */
      __pyx_v_self->header->target_name = ((char **)calloc(__pyx_t_10, (sizeof(char *))));

      /* "pysam/calignmentfile.pyx":472
 *                     n, sizeof(char*))
 *                 self.header.target_len = <uint32_t*>calloc(
 *                     n, sizeof(uint32_t))             # <<<<<<<<<<<<<<
 *                 for x from 0 <= x < self.header.n_targets:
 *                     self.header.target_len[x] = reference_lengths[x]
 */
      __pyx_t_10 = __Pyx_PyInt_As_size_t(__pyx_v_n); if (unlikely((__pyx_t_10 == (size_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 472, __pyx_L1_error)

      /* "pysam/calignmentfile.pyx":471
 *                 self.header.target_name = <char**>calloc(
 *                     n, sizeof(char*))
 *                 self.header.target_len = <uint32_t*>calloc(             # <<<<<<<<<<<<<<
 *                     n, sizeof(uint32_t))
 *                 for x from 0 <= x < self.header.n_targets:
 */
      __pyx_v_self->header->target_len = ((uint32_t *)calloc(__pyx_t_10, (sizeof(uint32_t))));

      /* "pysam/calignmentfile.pyx":473
 *                 self.header.target_len = <uint32_t*>calloc(
 *                     n, sizeof(uint32_t))
 *                 for x from 0 <= x < self.header.n_targets:             # <<<<<<<<<<<<<<
 *                     self.header.target_len[x] = reference_lengths[x]
 *                     name = reference_names[x]
 */
      __pyx_t_11 = __pyx_v_self->header->n_targets;
      for (__pyx_t_12 = 0; __pyx_t_12 < __pyx_t_11; __pyx_t_12++) {
        __pyx_t_4 = __Pyx_PyInt_From_long(__pyx_t_12); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 473, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_XDECREF_SET(__pyx_v_x, __pyx_t_4);
        __pyx_t_4 = 0;

        /* "pysam/calignmentfile.pyx":474
 *                     n, sizeof(uint32_t))
 *                 for x from 0 <= x < self.header.n_targets:
 *                     self.header.target_len[x] = reference_lengths[x]             # <<<<<<<<<<<<<<
 *                     name = reference_names[x]
 *                     self.header.target_name[x] = <char*>calloc(
 */
        __pyx_t_4 = PyObject_GetItem(__pyx_v_reference_lengths, __pyx_v_x); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 474, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __pyx_t_13 = __Pyx_PyInt_As_uint32_t(__pyx_t_4); if (unlikely((__pyx_t_13 == (uint32_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 474, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __pyx_t_8 = __Pyx_PyIndex_AsSsize_t(__pyx_v_x); if (unlikely((__pyx_t_8 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 474, __pyx_L1_error)
        (__pyx_v_self->header->target_len[__pyx_t_8]) = __pyx_t_13;

        /* "pysam/calignmentfile.pyx":475
 *                 for x from 0 <= x < self.header.n_targets:
 *                     self.header.target_len[x] = reference_lengths[x]
 *                     name = reference_names[x]             # <<<<<<<<<<<<<<
 *                     self.header.target_name[x] = <char*>calloc(
 *                         len(name) + 1, sizeof(char))
 */
        __pyx_t_4 = PyObject_GetItem(__pyx_v_reference_names, __pyx_v_x); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 475, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_XDECREF_SET(__pyx_v_name, __pyx_t_4);
        __pyx_t_4 = 0;

        /* "pysam/calignmentfile.pyx":477
 *                     name = reference_names[x]
 *                     self.header.target_name[x] = <char*>calloc(
 *                         len(name) + 1, sizeof(char))             # <<<<<<<<<<<<<<
 *                     strncpy(self.header.target_name[x], name, len(name))
 * 
 */
        __pyx_t_8 = PyObject_Length(__pyx_v_name); if (unlikely(__pyx_t_8 == -1)) __PYX_ERR(0, 477, __pyx_L1_error)

        /* "pysam/calignmentfile.pyx":476
 *                     self.header.target_len[x] = reference_lengths[x]
 *                     name = reference_names[x]
 *                     self.header.target_name[x] = <char*>calloc(             # <<<<<<<<<<<<<<
 *                         len(name) + 1, sizeof(char))
 *                     strncpy(self.header.target_name[x], name, len(name))
 */
        __pyx_t_7 = __Pyx_PyIndex_AsSsize_t(__pyx_v_x); if (unlikely((__pyx_t_7 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 476, __pyx_L1_error)
        (__pyx_v_self->header->target_name[__pyx_t_7]) = ((char *)calloc((__pyx_t_8 + 1), (sizeof(char))));

        /* "pysam/calignmentfile.pyx":478
 *                     self.header.target_name[x] = <char*>calloc(
 *                         len(name) + 1, sizeof(char))
 *                     strncpy(self.header.target_name[x], name, len(name))             # <<<<<<<<<<<<<<
 * 
 *                 # Optionally, if there is no text, add a SAM
 */
        __pyx_t_8 = __Pyx_PyIndex_AsSsize_t(__pyx_v_x); if (unlikely((__pyx_t_8 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 478, __pyx_L1_error)
        __pyx_t_14 = __Pyx_PyObject_AsString(__pyx_v_name); if (unlikely((!__pyx_t_14) && PyErr_Occurred())) __PYX_ERR(0, 478, __pyx_L1_error)
        __pyx_t_7 = PyObject_Length(__pyx_v_name); if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 478, __pyx_L1_error)
        strncpy((__pyx_v_self->header->target_name[__pyx_t_8]), __pyx_t_14, __pyx_t_7);
        __pyx_t_12 = __Pyx_PyInt_As_long(__pyx_v_x); if (unlikely((__pyx_t_12 == (long)-1) && PyErr_Occurred())) __PYX_ERR(0, 473, __pyx_L1_error)
      }

      /* "pysam/calignmentfile.pyx":473
 *                 self.header.target_len = <uint32_t*>calloc(
 *                     n, sizeof(uint32_t))
 *                 for x from 0 <= x < self.header.n_targets:             # <<<<<<<<<<<<<<
 *                     self.header.target_len[x] = reference_lengths[x]
 *                     name = reference_names[x]
 */
      __pyx_t_4 = __Pyx_PyInt_From_long(__pyx_t_12); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 473, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_XDECREF_SET(__pyx_v_x, __pyx_t_4);
      __pyx_t_4 = 0;

      /* "pysam/calignmentfile.pyx":482
 *                 # Optionally, if there is no text, add a SAM
 *                 # compatible header to output file.
 *                 if text is None and add_sq_text:             # <<<<<<<<<<<<<<
 *                     text = []
 *                     for x from 0 <= x < self.header.n_targets:
 */
      __pyx_t_1 = (__pyx_v_text == Py_None);
      __pyx_t_15 = (__pyx_t_1 != 0);
      if (__pyx_t_15) {
      } else {
        __pyx_t_2 = __pyx_t_15;
        goto __pyx_L31_bool_binop_done;
      }
      __pyx_t_15 = __Pyx_PyObject_IsTrue(__pyx_v_add_sq_text); if (unlikely(__pyx_t_15 < 0)) __PYX_ERR(0, 482, __pyx_L1_error)
      __pyx_t_2 = __pyx_t_15;
      __pyx_L31_bool_binop_done:;
      if (__pyx_t_2) {

        /* "pysam/calignmentfile.pyx":483
 *                 # compatible header to output file.
 *                 if text is None and add_sq_text:
 *                     text = []             # <<<<<<<<<<<<<<
 *                     for x from 0 <= x < self.header.n_targets:
 *                         text.append("@SQ\tSN:%s\tLN:%s\n" % \
 */
        __pyx_t_4 = PyList_New(0); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 483, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF_SET(__pyx_v_text, __pyx_t_4);
        __pyx_t_4 = 0;

        /* "pysam/calignmentfile.pyx":484
 *                 if text is None and add_sq_text:
 *                     text = []
 *                     for x from 0 <= x < self.header.n_targets:             # <<<<<<<<<<<<<<
 *                         text.append("@SQ\tSN:%s\tLN:%s\n" % \
 *                                     (force_str(reference_names[x]),
 */
        __pyx_t_11 = __pyx_v_self->header->n_targets;
        for (__pyx_t_12 = 0; __pyx_t_12 < __pyx_t_11; __pyx_t_12++) {
          __pyx_t_4 = __Pyx_PyInt_From_long(__pyx_t_12); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 484, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_4);
          __Pyx_XDECREF_SET(__pyx_v_x, __pyx_t_4);
          __pyx_t_4 = 0;

          /* "pysam/calignmentfile.pyx":486
 *                     for x from 0 <= x < self.header.n_targets:
 *                         text.append("@SQ\tSN:%s\tLN:%s\n" % \
 *                                     (force_str(reference_names[x]),             # <<<<<<<<<<<<<<
 *                                      reference_lengths[x]))
 *                     text = ''.join(text)
 */
          __pyx_t_4 = PyObject_GetItem(__pyx_v_reference_names, __pyx_v_x); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 486, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_4);
          __pyx_t_5 = __pyx_f_5pysam_6cutils_force_str(__pyx_t_4, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 486, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_5);
          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

          /* "pysam/calignmentfile.pyx":487
 *                         text.append("@SQ\tSN:%s\tLN:%s\n" % \
 *                                     (force_str(reference_names[x]),
 *                                      reference_lengths[x]))             # <<<<<<<<<<<<<<
 *                     text = ''.join(text)
 * 
 */
          __pyx_t_4 = PyObject_GetItem(__pyx_v_reference_lengths, __pyx_v_x); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 487, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_4);

          /* "pysam/calignmentfile.pyx":486
 *                     for x from 0 <= x < self.header.n_targets:
 *                         text.append("@SQ\tSN:%s\tLN:%s\n" % \
 *                                     (force_str(reference_names[x]),             # <<<<<<<<<<<<<<
 *                                      reference_lengths[x]))
 *                     text = ''.join(text)
 */
          __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 486, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_3);
          __Pyx_GIVEREF(__pyx_t_5);
          PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_5);
          __Pyx_GIVEREF(__pyx_t_4);
          PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_4);
          __pyx_t_5 = 0;
          __pyx_t_4 = 0;

          /* "pysam/calignmentfile.pyx":485
 *                     text = []
 *                     for x from 0 <= x < self.header.n_targets:
 *                         text.append("@SQ\tSN:%s\tLN:%s\n" % \             # <<<<<<<<<<<<<<
 *                                     (force_str(reference_names[x]),
 *                                      reference_lengths[x]))
 */
          __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_SQ_SN_s_LN_s, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 485, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_4);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          __pyx_t_16 = __Pyx_PyObject_Append(__pyx_v_text, __pyx_t_4); if (unlikely(__pyx_t_16 == -1)) __PYX_ERR(0, 485, __pyx_L1_error)
          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
          __pyx_t_12 = __Pyx_PyInt_As_long(__pyx_v_x); if (unlikely((__pyx_t_12 == (long)-1) && PyErr_Occurred())) __PYX_ERR(0, 484, __pyx_L1_error)
        }

        /* "pysam/calignmentfile.pyx":484
 *                 if text is None and add_sq_text:
 *                     text = []
 *                     for x from 0 <= x < self.header.n_targets:             # <<<<<<<<<<<<<<
 *                         text.append("@SQ\tSN:%s\tLN:%s\n" % \
 *                                     (force_str(reference_names[x]),
 */
        __pyx_t_4 = __Pyx_PyInt_From_long(__pyx_t_12); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 484, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_XDECREF_SET(__pyx_v_x, __pyx_t_4);
        __pyx_t_4 = 0;

        /* "pysam/calignmentfile.pyx":488
 *                                     (force_str(reference_names[x]),
 *                                      reference_lengths[x]))
 *                     text = ''.join(text)             # <<<<<<<<<<<<<<
 * 
 *                 if text is not None:
 */
        __pyx_t_4 = __Pyx_PyString_Join(__pyx_kp_s__13, __pyx_v_text); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 488, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF_SET(__pyx_v_text, __pyx_t_4);
        __pyx_t_4 = 0;

        /* "pysam/calignmentfile.pyx":482
 *                 # Optionally, if there is no text, add a SAM
 *                 # compatible header to output file.
 *                 if text is None and add_sq_text:             # <<<<<<<<<<<<<<
 *                     text = []
 *                     for x from 0 <= x < self.header.n_targets:
 */
      }

      /* "pysam/calignmentfile.pyx":490
 *                     text = ''.join(text)
 * 
 *                 if text is not None:             # <<<<<<<<<<<<<<
 *                     # copy without \0
 *                     text = force_bytes(text)
 */
      __pyx_t_2 = (__pyx_v_text != Py_None);
      __pyx_t_15 = (__pyx_t_2 != 0);
      if (__pyx_t_15) {

        /* "pysam/calignmentfile.pyx":492
 *                 if text is not None:
 *                     # copy without \0
 *                     text = force_bytes(text)             # <<<<<<<<<<<<<<
 *                     ctext = text
 *                     self.header.l_text = strlen(ctext)
 */
        __pyx_t_4 = __pyx_f_5pysam_6cutils_force_bytes(__pyx_v_text, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 492, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF_SET(__pyx_v_text, __pyx_t_4);
        __pyx_t_4 = 0;

        /* "pysam/calignmentfile.pyx":493
 *                     # copy without \0
 *                     text = force_bytes(text)
 *                     ctext = text             # <<<<<<<<<<<<<<
 *                     self.header.l_text = strlen(ctext)
 *                     self.header.text = <char*>calloc(
 */
        __pyx_t_17 = __Pyx_PyObject_AsString(__pyx_v_text); if (unlikely((!__pyx_t_17) && PyErr_Occurred())) __PYX_ERR(0, 493, __pyx_L1_error)
        __pyx_v_ctext = __pyx_t_17;

        /* "pysam/calignmentfile.pyx":494
 *                     text = force_bytes(text)
 *                     ctext = text
 *                     self.header.l_text = strlen(ctext)             # <<<<<<<<<<<<<<
 *                     self.header.text = <char*>calloc(
 *                         strlen(ctext), sizeof(char))
 */
        __pyx_v_self->header->l_text = strlen(__pyx_v_ctext);

        /* "pysam/calignmentfile.pyx":495
 *                     ctext = text
 *                     self.header.l_text = strlen(ctext)
 *                     self.header.text = <char*>calloc(             # <<<<<<<<<<<<<<
 *                         strlen(ctext), sizeof(char))
 *                     memcpy(self.header.text, ctext, strlen(ctext))
 */
        __pyx_v_self->header->text = ((char *)calloc(strlen(__pyx_v_ctext), (sizeof(char))));

        /* "pysam/calignmentfile.pyx":497
 *                     self.header.text = <char*>calloc(
 *                         strlen(ctext), sizeof(char))
 *                     memcpy(self.header.text, ctext, strlen(ctext))             # <<<<<<<<<<<<<<
 * 
 *             # open file (hts_open is synonym with sam_open)
 */
        memcpy(__pyx_v_self->header->text, __pyx_v_ctext, strlen(__pyx_v_ctext));

        /* "pysam/calignmentfile.pyx":490
 *                     text = ''.join(text)
 * 
 *                 if text is not None:             # <<<<<<<<<<<<<<
 *                     # copy without \0
 *                     text = force_bytes(text)
 */
      }
    }
    __pyx_L21:;

    /* "pysam/calignmentfile.pyx":500
 * 
 *             # open file (hts_open is synonym with sam_open)
 *             cfilename, cmode = filename, bmode             # <<<<<<<<<<<<<<
 *             if hasattr(filepath_or_object, "fileno"):
 *                 fp = hdopen(filepath_or_object.fileno(), cmode)
 */
    __pyx_t_17 = __Pyx_PyObject_AsString(__pyx_v_filename); if (unlikely((!__pyx_t_17) && PyErr_Occurred())) __PYX_ERR(0, 500, __pyx_L1_error)
    __pyx_t_18 = __Pyx_PyObject_AsString(__pyx_v_bmode); if (unlikely((!__pyx_t_18) && PyErr_Occurred())) __PYX_ERR(0, 500, __pyx_L1_error)
    __pyx_v_cfilename = __pyx_t_17;
    __pyx_v_cmode = __pyx_t_18;

    /* "pysam/calignmentfile.pyx":501
 *             # open file (hts_open is synonym with sam_open)
 *             cfilename, cmode = filename, bmode
 *             if hasattr(filepath_or_object, "fileno"):             # <<<<<<<<<<<<<<
 *                 fp = hdopen(filepath_or_object.fileno(), cmode)
 *                 with nogil:
 */
    __pyx_t_15 = PyObject_HasAttr(__pyx_v_filepath_or_object, __pyx_n_s_fileno); if (unlikely(__pyx_t_15 == -1)) __PYX_ERR(0, 501, __pyx_L1_error)
    __pyx_t_2 = (__pyx_t_15 != 0);
    if (__pyx_t_2) {

      /* "pysam/calignmentfile.pyx":502
 *             cfilename, cmode = filename, bmode
 *             if hasattr(filepath_or_object, "fileno"):
 *                 fp = hdopen(filepath_or_object.fileno(), cmode)             # <<<<<<<<<<<<<<
 *                 with nogil:
 *                     self.htsfile = hts_hopen(fp, cfilename, cmode)
 */
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_filepath_or_object, __pyx_n_s_fileno); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 502, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_5 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_5)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_5);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (__pyx_t_5) {
        __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 502, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      } else {
        __pyx_t_4 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 502, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_19 = __Pyx_PyInt_As_int(__pyx_t_4); if (unlikely((__pyx_t_19 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 502, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_v_fp = hdopen(__pyx_t_19, __pyx_v_cmode);

      /* "pysam/calignmentfile.pyx":503
 *             if hasattr(filepath_or_object, "fileno"):
 *                 fp = hdopen(filepath_or_object.fileno(), cmode)
 *                 with nogil:             # <<<<<<<<<<<<<<
 *                     self.htsfile = hts_hopen(fp, cfilename, cmode)
 *             else:
 */
      {
          #ifdef WITH_THREAD
          PyThreadState *_save;
          Py_UNBLOCK_THREADS
          #endif
          /*try:*/ {

            /* "pysam/calignmentfile.pyx":504
 *                 fp = hdopen(filepath_or_object.fileno(), cmode)
 *                 with nogil:
 *                     self.htsfile = hts_hopen(fp, cfilename, cmode)             # <<<<<<<<<<<<<<
 *             else:
 *                 with nogil:
 */
            __pyx_v_self->htsfile = hts_hopen(__pyx_v_fp, __pyx_v_cfilename, __pyx_v_cmode);
          }

          /* "pysam/calignmentfile.pyx":503
 *             if hasattr(filepath_or_object, "fileno"):
 *                 fp = hdopen(filepath_or_object.fileno(), cmode)
 *                 with nogil:             # <<<<<<<<<<<<<<
 *                     self.htsfile = hts_hopen(fp, cfilename, cmode)
 *             else:
 */
          /*finally:*/ {
            /*normal exit:*/{
              #ifdef WITH_THREAD
              Py_BLOCK_THREADS
              #endif
              goto __pyx_L39;
            }
            __pyx_L39:;
          }
      }

      /* "pysam/calignmentfile.pyx":501
 *             # open file (hts_open is synonym with sam_open)
 *             cfilename, cmode = filename, bmode
 *             if hasattr(filepath_or_object, "fileno"):             # <<<<<<<<<<<<<<
 *                 fp = hdopen(filepath_or_object.fileno(), cmode)
 *                 with nogil:
 */
      goto __pyx_L36;
    }

    /* "pysam/calignmentfile.pyx":506
 *                     self.htsfile = hts_hopen(fp, cfilename, cmode)
 *             else:
 *                 with nogil:             # <<<<<<<<<<<<<<
 *                     self.htsfile = hts_open(cfilename, cmode)
 * 
 */
    /*else*/ {
      {
          #ifdef WITH_THREAD
          PyThreadState *_save;
          Py_UNBLOCK_THREADS
          #endif
          /*try:*/ {

            /* "pysam/calignmentfile.pyx":507
 *             else:
 *                 with nogil:
 *                     self.htsfile = hts_open(cfilename, cmode)             # <<<<<<<<<<<<<<
 * 
 *             # htsfile.format does not get set until writing, so use
 */
            __pyx_v_self->htsfile = hts_open(__pyx_v_cfilename, __pyx_v_cmode);
          }

          /* "pysam/calignmentfile.pyx":506
 *                     self.htsfile = hts_hopen(fp, cfilename, cmode)
 *             else:
 *                 with nogil:             # <<<<<<<<<<<<<<
 *                     self.htsfile = hts_open(cfilename, cmode)
 * 
 */
          /*finally:*/ {
            /*normal exit:*/{
              #ifdef WITH_THREAD
              Py_BLOCK_THREADS
              #endif
              goto __pyx_L42;
            }
            __pyx_L42:;
          }
      }
    }
    __pyx_L36:;

    /* "pysam/calignmentfile.pyx":511
 *             # htsfile.format does not get set until writing, so use
 *             # the format specifier explicitely given by the user.
 *             self.is_bam = "b" in mode             # <<<<<<<<<<<<<<
 *             self.is_cram = "c" in mode
 * 
 */
    __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_b, __pyx_v_mode, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 511, __pyx_L1_error)
    __pyx_v_self->is_bam = __pyx_t_2;

    /* "pysam/calignmentfile.pyx":512
 *             # the format specifier explicitely given by the user.
 *             self.is_bam = "b" in mode
 *             self.is_cram = "c" in mode             # <<<<<<<<<<<<<<
 * 
 *             # set filename with reference sequences. If no filename
 */
    __pyx_t_2 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_c, __pyx_v_mode, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 512, __pyx_L1_error)
    __pyx_v_self->is_cram = __pyx_t_2;

    /* "pysam/calignmentfile.pyx":517
 *             # is given, the CRAM reference arrays will be built from
 *             # the @SQ header in the header
 *             if self.is_cram and reference_filename:             # <<<<<<<<<<<<<<
 *                 # note that fn_aux takes ownership, so create
 *                 # a copy
 */
    __pyx_t_15 = (__pyx_v_self->is_cram != 0);
    if (__pyx_t_15) {
    } else {
      __pyx_t_2 = __pyx_t_15;
      goto __pyx_L44_bool_binop_done;
    }
    __pyx_t_15 = __Pyx_PyObject_IsTrue(__pyx_v_reference_filename); if (unlikely(__pyx_t_15 < 0)) __PYX_ERR(0, 517, __pyx_L1_error)
    __pyx_t_2 = __pyx_t_15;
    __pyx_L44_bool_binop_done:;
    if (__pyx_t_2) {

      /* "pysam/calignmentfile.pyx":520
 *                 # note that fn_aux takes ownership, so create
 *                 # a copy
 *                 fn = encode_filename(reference_filename)             # <<<<<<<<<<<<<<
 *                 self.htsfile.fn_aux = strdup(fn)
 * 
 */
      __pyx_t_4 = __pyx_f_5pysam_6cutils_encode_filename(__pyx_v_reference_filename); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 520, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_v_fn = ((PyObject*)__pyx_t_4);
      __pyx_t_4 = 0;

      /* "pysam/calignmentfile.pyx":521
 *                 # a copy
 *                 fn = encode_filename(reference_filename)
 *                 self.htsfile.fn_aux = strdup(fn)             # <<<<<<<<<<<<<<
 * 
 *             # write header to htsfile
 */
      __pyx_t_20 = __Pyx_PyObject_AsString(__pyx_v_fn); if (unlikely((!__pyx_t_20) && PyErr_Occurred())) __PYX_ERR(0, 521, __pyx_L1_error)
      __pyx_v_self->htsfile->fn_aux = strdup(__pyx_t_20);

      /* "pysam/calignmentfile.pyx":517
 *             # is given, the CRAM reference arrays will be built from
 *             # the @SQ header in the header
 *             if self.is_cram and reference_filename:             # <<<<<<<<<<<<<<
 *                 # note that fn_aux takes ownership, so create
 *                 # a copy
 */
    }

    /* "pysam/calignmentfile.pyx":524
 * 
 *             # write header to htsfile
 *             if self.is_bam or self.is_cram or "h" in mode:             # <<<<<<<<<<<<<<
 *                 with nogil:
 *                     sam_hdr_write(self.htsfile, self.header)
 */
    __pyx_t_15 = (__pyx_v_self->is_bam != 0);
    if (!__pyx_t_15) {
    } else {
      __pyx_t_2 = __pyx_t_15;
      goto __pyx_L47_bool_binop_done;
    }
    __pyx_t_15 = (__pyx_v_self->is_cram != 0);
    if (!__pyx_t_15) {
    } else {
      __pyx_t_2 = __pyx_t_15;
      goto __pyx_L47_bool_binop_done;
    }
    __pyx_t_15 = (__Pyx_PySequence_ContainsTF(__pyx_n_s_h, __pyx_v_mode, Py_EQ)); if (unlikely(__pyx_t_15 < 0)) __PYX_ERR(0, 524, __pyx_L1_error)
    __pyx_t_1 = (__pyx_t_15 != 0);
    __pyx_t_2 = __pyx_t_1;
    __pyx_L47_bool_binop_done:;
    if (__pyx_t_2) {

      /* "pysam/calignmentfile.pyx":525
 *             # write header to htsfile
 *             if self.is_bam or self.is_cram or "h" in mode:
 *                 with nogil:             # <<<<<<<<<<<<<<
 *                     sam_hdr_write(self.htsfile, self.header)
 * 
 */
      {
          #ifdef WITH_THREAD
          PyThreadState *_save;
          Py_UNBLOCK_THREADS
          #endif
          /*try:*/ {

            /* "pysam/calignmentfile.pyx":526
 *             if self.is_bam or self.is_cram or "h" in mode:
 *                 with nogil:
 *                     sam_hdr_write(self.htsfile, self.header)             # <<<<<<<<<<<<<<
 * 
 *         elif mode[0] == "r":
 */
            sam_hdr_write(__pyx_v_self->htsfile, __pyx_v_self->header);
          }

          /* "pysam/calignmentfile.pyx":525
 *             # write header to htsfile
 *             if self.is_bam or self.is_cram or "h" in mode:
 *                 with nogil:             # <<<<<<<<<<<<<<
 *                     sam_hdr_write(self.htsfile, self.header)
 * 
 */
          /*finally:*/ {
            /*normal exit:*/{
              #ifdef WITH_THREAD
              Py_BLOCK_THREADS
              #endif
              goto __pyx_L52;
            }
            __pyx_L52:;
          }
      }

      /* "pysam/calignmentfile.pyx":524
 * 
 *             # write header to htsfile
 *             if self.is_bam or self.is_cram or "h" in mode:             # <<<<<<<<<<<<<<
 *                 with nogil:
 *                     sam_hdr_write(self.htsfile, self.header)
 */
    }

    /* "pysam/calignmentfile.pyx":445
 *         ctext = NULL
 * 
 *         if mode[0] == 'w':             # <<<<<<<<<<<<<<
 *             # open file for writing
 * 
 */
    goto __pyx_L20;
  }

  /* "pysam/calignmentfile.pyx":528
 *                     sam_hdr_write(self.htsfile, self.header)
 * 
 *         elif mode[0] == "r":             # <<<<<<<<<<<<<<
 *             # open file for reading
 *             if (filename != b"-"
 */
  __pyx_t_4 = __Pyx_GetItemInt(__pyx_v_mode, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 528, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_t_4, __pyx_n_s_r, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 528, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (__pyx_t_2) {

    /* "pysam/calignmentfile.pyx":530
 *         elif mode[0] == "r":
 *             # open file for reading
 *             if (filename != b"-"             # <<<<<<<<<<<<<<
 *                 and not self.is_remote
 *                 and not os.path.exists(filename)):
 */
    __pyx_t_1 = (__Pyx_PyBytes_Equals(__pyx_v_filename, __pyx_kp_b__12, Py_NE)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 530, __pyx_L1_error)
    if (__pyx_t_1) {
    } else {
      __pyx_t_2 = __pyx_t_1;
      goto __pyx_L54_bool_binop_done;
    }

    /* "pysam/calignmentfile.pyx":531
 *             # open file for reading
 *             if (filename != b"-"
 *                 and not self.is_remote             # <<<<<<<<<<<<<<
 *                 and not os.path.exists(filename)):
 *                 raise IOError("file `%s` not found" % filename)
 */
    __pyx_t_1 = ((!(__pyx_v_self->is_remote != 0)) != 0);
    if (__pyx_t_1) {
    } else {
      __pyx_t_2 = __pyx_t_1;
      goto __pyx_L54_bool_binop_done;
    }

    /* "pysam/calignmentfile.pyx":532
 *             if (filename != b"-"
 *                 and not self.is_remote
 *                 and not os.path.exists(filename)):             # <<<<<<<<<<<<<<
 *                 raise IOError("file `%s` not found" % filename)
 * 
 */
    __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 532, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_path); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 532, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_exists); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 532, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_3))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_3);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_3, function);
      }
    }
    if (!__pyx_t_5) {
      __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_v_filename); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 532, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
    } else {
      __pyx_t_21 = PyTuple_New(1+1); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 532, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_21);
      __Pyx_GIVEREF(__pyx_t_5); PyTuple_SET_ITEM(__pyx_t_21, 0, __pyx_t_5); __pyx_t_5 = NULL;
      __Pyx_INCREF(__pyx_v_filename);
      __Pyx_GIVEREF(__pyx_v_filename);
      PyTuple_SET_ITEM(__pyx_t_21, 0+1, __pyx_v_filename);
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_21, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 532, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_21); __pyx_t_21 = 0;
    }
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 532, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_15 = ((!__pyx_t_1) != 0);
    __pyx_t_2 = __pyx_t_15;
    __pyx_L54_bool_binop_done:;

    /* "pysam/calignmentfile.pyx":530
 *         elif mode[0] == "r":
 *             # open file for reading
 *             if (filename != b"-"             # <<<<<<<<<<<<<<
 *                 and not self.is_remote
 *                 and not os.path.exists(filename)):
 */
    if (__pyx_t_2) {

      /* "pysam/calignmentfile.pyx":533
 *                 and not self.is_remote
 *                 and not os.path.exists(filename)):
 *                 raise IOError("file `%s` not found" % filename)             # <<<<<<<<<<<<<<
 * 
 *             # open file (hts_open is synonym with sam_open)
 */
      __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_file_s_not_found, __pyx_v_filename); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 533, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 533, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_GIVEREF(__pyx_t_4);
      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
      __pyx_t_4 = 0;
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_IOError, __pyx_t_3, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 533, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __PYX_ERR(0, 533, __pyx_L1_error)

      /* "pysam/calignmentfile.pyx":530
 *         elif mode[0] == "r":
 *             # open file for reading
 *             if (filename != b"-"             # <<<<<<<<<<<<<<
 *                 and not self.is_remote
 *                 and not os.path.exists(filename)):
 */
    }

    /* "pysam/calignmentfile.pyx":536
 * 
 *             # open file (hts_open is synonym with sam_open)
 *             cfilename, cmode = filename, bmode             # <<<<<<<<<<<<<<
 *             if hasattr(filepath_or_object, "fileno"):
 *                 fp = hdopen(filepath_or_object.fileno(), cmode)
 */
    __pyx_t_18 = __Pyx_PyObject_AsString(__pyx_v_filename); if (unlikely((!__pyx_t_18) && PyErr_Occurred())) __PYX_ERR(0, 536, __pyx_L1_error)
    __pyx_t_17 = __Pyx_PyObject_AsString(__pyx_v_bmode); if (unlikely((!__pyx_t_17) && PyErr_Occurred())) __PYX_ERR(0, 536, __pyx_L1_error)
    __pyx_v_cfilename = __pyx_t_18;
    __pyx_v_cmode = __pyx_t_17;

    /* "pysam/calignmentfile.pyx":537
 *             # open file (hts_open is synonym with sam_open)
 *             cfilename, cmode = filename, bmode
 *             if hasattr(filepath_or_object, "fileno"):             # <<<<<<<<<<<<<<
 *                 fp = hdopen(filepath_or_object.fileno(), cmode)
 *                 with nogil:
 */
    __pyx_t_2 = PyObject_HasAttr(__pyx_v_filepath_or_object, __pyx_n_s_fileno); if (unlikely(__pyx_t_2 == -1)) __PYX_ERR(0, 537, __pyx_L1_error)
    __pyx_t_15 = (__pyx_t_2 != 0);
    if (__pyx_t_15) {

      /* "pysam/calignmentfile.pyx":538
 *             cfilename, cmode = filename, bmode
 *             if hasattr(filepath_or_object, "fileno"):
 *                 fp = hdopen(filepath_or_object.fileno(), cmode)             # <<<<<<<<<<<<<<
 *                 with nogil:
 *                     self.htsfile = hts_hopen(fp, cfilename, cmode)
 */
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_filepath_or_object, __pyx_n_s_fileno); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 538, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_21 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_21 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_21)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_21);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (__pyx_t_21) {
        __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_21); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 538, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_21); __pyx_t_21 = 0;
      } else {
        __pyx_t_4 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 538, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_19 = __Pyx_PyInt_As_int(__pyx_t_4); if (unlikely((__pyx_t_19 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 538, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_v_fp = hdopen(__pyx_t_19, __pyx_v_cmode);

      /* "pysam/calignmentfile.pyx":539
 *             if hasattr(filepath_or_object, "fileno"):
 *                 fp = hdopen(filepath_or_object.fileno(), cmode)
 *                 with nogil:             # <<<<<<<<<<<<<<
 *                     self.htsfile = hts_hopen(fp, cfilename, cmode)
 *             else:
 */
      {
          #ifdef WITH_THREAD
          PyThreadState *_save;
          Py_UNBLOCK_THREADS
          #endif
          /*try:*/ {

            /* "pysam/calignmentfile.pyx":540
 *                 fp = hdopen(filepath_or_object.fileno(), cmode)
 *                 with nogil:
 *                     self.htsfile = hts_hopen(fp, cfilename, cmode)             # <<<<<<<<<<<<<<
 *             else:
 *                 with nogil:
 */
            __pyx_v_self->htsfile = hts_hopen(__pyx_v_fp, __pyx_v_cfilename, __pyx_v_cmode);
          }

          /* "pysam/calignmentfile.pyx":539
 *             if hasattr(filepath_or_object, "fileno"):
 *                 fp = hdopen(filepath_or_object.fileno(), cmode)
 *                 with nogil:             # <<<<<<<<<<<<<<
 *                     self.htsfile = hts_hopen(fp, cfilename, cmode)
 *             else:
 */
          /*finally:*/ {
            /*normal exit:*/{
              #ifdef WITH_THREAD
              Py_BLOCK_THREADS
              #endif
              goto __pyx_L60;
            }
            __pyx_L60:;
          }
      }

      /* "pysam/calignmentfile.pyx":537
 *             # open file (hts_open is synonym with sam_open)
 *             cfilename, cmode = filename, bmode
 *             if hasattr(filepath_or_object, "fileno"):             # <<<<<<<<<<<<<<
 *                 fp = hdopen(filepath_or_object.fileno(), cmode)
 *                 with nogil:
 */
      goto __pyx_L57;
    }

    /* "pysam/calignmentfile.pyx":542
 *                     self.htsfile = hts_hopen(fp, cfilename, cmode)
 *             else:
 *                 with nogil:             # <<<<<<<<<<<<<<
 *                     self.htsfile = hts_open(cfilename, cmode)
 * 
 */
    /*else*/ {
      {
          #ifdef WITH_THREAD
          PyThreadState *_save;
          Py_UNBLOCK_THREADS
          #endif
          /*try:*/ {

            /* "pysam/calignmentfile.pyx":543
 *             else:
 *                 with nogil:
 *                     self.htsfile = hts_open(cfilename, cmode)             # <<<<<<<<<<<<<<
 * 
 *             if self.htsfile == NULL:
 */
            __pyx_v_self->htsfile = hts_open(__pyx_v_cfilename, __pyx_v_cmode);
          }

          /* "pysam/calignmentfile.pyx":542
 *                     self.htsfile = hts_hopen(fp, cfilename, cmode)
 *             else:
 *                 with nogil:             # <<<<<<<<<<<<<<
 *                     self.htsfile = hts_open(cfilename, cmode)
 * 
 */
          /*finally:*/ {
            /*normal exit:*/{
              #ifdef WITH_THREAD
              Py_BLOCK_THREADS
              #endif
              goto __pyx_L63;
            }
            __pyx_L63:;
          }
      }
    }
    __pyx_L57:;

    /* "pysam/calignmentfile.pyx":545
 *                     self.htsfile = hts_open(cfilename, cmode)
 * 
 *             if self.htsfile == NULL:             # <<<<<<<<<<<<<<
 *                 raise ValueError(
 *                     "could not open file (mode='%s') - "
 */
    __pyx_t_15 = ((__pyx_v_self->htsfile == NULL) != 0);
    if (__pyx_t_15) {

      /* "pysam/calignmentfile.pyx":548
 *                 raise ValueError(
 *                     "could not open file (mode='%s') - "
 *                     "is it SAM/BAM format?" % mode)             # <<<<<<<<<<<<<<
 * 
 *             self.is_bam = self.htsfile.format.format == bam
 */
      __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_could_not_open_file_mode_s_is_it, __pyx_v_mode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 548, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);

      /* "pysam/calignmentfile.pyx":546
 * 
 *             if self.htsfile == NULL:
 *                 raise ValueError(             # <<<<<<<<<<<<<<
 *                     "could not open file (mode='%s') - "
 *                     "is it SAM/BAM format?" % mode)
 */
      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 546, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_GIVEREF(__pyx_t_4);
      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
      __pyx_t_4 = 0;
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_3, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 546, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __PYX_ERR(0, 546, __pyx_L1_error)

      /* "pysam/calignmentfile.pyx":545
 *                     self.htsfile = hts_open(cfilename, cmode)
 * 
 *             if self.htsfile == NULL:             # <<<<<<<<<<<<<<
 *                 raise ValueError(
 *                     "could not open file (mode='%s') - "
 */
    }

    /* "pysam/calignmentfile.pyx":550
 *                     "is it SAM/BAM format?" % mode)
 * 
 *             self.is_bam = self.htsfile.format.format == bam             # <<<<<<<<<<<<<<
 *             self.is_cram = self.htsfile.format.format == cram
 * 
 */
    __pyx_v_self->is_bam = (__pyx_v_self->htsfile->format.format == bam);

    /* "pysam/calignmentfile.pyx":551
 * 
 *             self.is_bam = self.htsfile.format.format == bam
 *             self.is_cram = self.htsfile.format.format == cram             # <<<<<<<<<<<<<<
 * 
 *             # bam files require a valid header
 */
    __pyx_v_self->is_cram = (__pyx_v_self->htsfile->format.format == cram);

    /* "pysam/calignmentfile.pyx":554
 * 
 *             # bam files require a valid header
 *             if self.is_bam or self.is_cram:             # <<<<<<<<<<<<<<
 *                 with nogil:
 *                     self.header = sam_hdr_read(self.htsfile)
 */
    __pyx_t_2 = (__pyx_v_self->is_bam != 0);
    if (!__pyx_t_2) {
    } else {
      __pyx_t_15 = __pyx_t_2;
      goto __pyx_L66_bool_binop_done;
    }
    __pyx_t_2 = (__pyx_v_self->is_cram != 0);
    __pyx_t_15 = __pyx_t_2;
    __pyx_L66_bool_binop_done:;
    if (__pyx_t_15) {

      /* "pysam/calignmentfile.pyx":555
 *             # bam files require a valid header
 *             if self.is_bam or self.is_cram:
 *                 with nogil:             # <<<<<<<<<<<<<<
 *                     self.header = sam_hdr_read(self.htsfile)
 *                 if self.header == NULL:
 */
      {
          #ifdef WITH_THREAD
          PyThreadState *_save;
          Py_UNBLOCK_THREADS
          #endif
          /*try:*/ {

            /* "pysam/calignmentfile.pyx":556
 *             if self.is_bam or self.is_cram:
 *                 with nogil:
 *                     self.header = sam_hdr_read(self.htsfile)             # <<<<<<<<<<<<<<
 *                 if self.header == NULL:
 *                     raise ValueError(
 */
            __pyx_v_self->header = sam_hdr_read(__pyx_v_self->htsfile);
          }

          /* "pysam/calignmentfile.pyx":555
 *             # bam files require a valid header
 *             if self.is_bam or self.is_cram:
 *                 with nogil:             # <<<<<<<<<<<<<<
 *                     self.header = sam_hdr_read(self.htsfile)
 *                 if self.header == NULL:
 */
          /*finally:*/ {
            /*normal exit:*/{
              #ifdef WITH_THREAD
              Py_BLOCK_THREADS
              #endif
              goto __pyx_L70;
            }
            __pyx_L70:;
          }
      }

      /* "pysam/calignmentfile.pyx":557
 *                 with nogil:
 *                     self.header = sam_hdr_read(self.htsfile)
 *                 if self.header == NULL:             # <<<<<<<<<<<<<<
 *                     raise ValueError(
 *                         "file does not have valid header (mode='%s') "
 */
      __pyx_t_15 = ((__pyx_v_self->header == NULL) != 0);
      if (__pyx_t_15) {

        /* "pysam/calignmentfile.pyx":560
 *                     raise ValueError(
 *                         "file does not have valid header (mode='%s') "
 *                         "- is it BAM format?" % mode )             # <<<<<<<<<<<<<<
 *             else:
 *                 # in sam files it is optional (htsfile full of
 */
        __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_file_does_not_have_valid_header, __pyx_v_mode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 560, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);

        /* "pysam/calignmentfile.pyx":558
 *                     self.header = sam_hdr_read(self.htsfile)
 *                 if self.header == NULL:
 *                     raise ValueError(             # <<<<<<<<<<<<<<
 *                         "file does not have valid header (mode='%s') "
 *                         "- is it BAM format?" % mode )
 */
        __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 558, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_GIVEREF(__pyx_t_4);
        PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
        __pyx_t_4 = 0;
        __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_3, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 558, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_Raise(__pyx_t_4, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __PYX_ERR(0, 558, __pyx_L1_error)

        /* "pysam/calignmentfile.pyx":557
 *                 with nogil:
 *                     self.header = sam_hdr_read(self.htsfile)
 *                 if self.header == NULL:             # <<<<<<<<<<<<<<
 *                     raise ValueError(
 *                         "file does not have valid header (mode='%s') "
 */
      }

      /* "pysam/calignmentfile.pyx":554
 * 
 *             # bam files require a valid header
 *             if self.is_bam or self.is_cram:             # <<<<<<<<<<<<<<
 *                 with nogil:
 *                     self.header = sam_hdr_read(self.htsfile)
 */
      goto __pyx_L65;
    }

    /* "pysam/calignmentfile.pyx":564
 *                 # in sam files it is optional (htsfile full of
 *                 # unmapped reads)
 *                 if check_header:             # <<<<<<<<<<<<<<
 *                     with nogil:
 *                         self.header = sam_hdr_read(self.htsfile)
 */
    /*else*/ {
      __pyx_t_15 = __Pyx_PyObject_IsTrue(__pyx_v_check_header); if (unlikely(__pyx_t_15 < 0)) __PYX_ERR(0, 564, __pyx_L1_error)
      if (__pyx_t_15) {

        /* "pysam/calignmentfile.pyx":565
 *                 # unmapped reads)
 *                 if check_header:
 *                     with nogil:             # <<<<<<<<<<<<<<
 *                         self.header = sam_hdr_read(self.htsfile)
 *                     if self.header == NULL:
 */
        {
            #ifdef WITH_THREAD
            PyThreadState *_save;
            Py_UNBLOCK_THREADS
            #endif
            /*try:*/ {

              /* "pysam/calignmentfile.pyx":566
 *                 if check_header:
 *                     with nogil:
 *                         self.header = sam_hdr_read(self.htsfile)             # <<<<<<<<<<<<<<
 *                     if self.header == NULL:
 *                         raise ValueError(
 */
              __pyx_v_self->header = sam_hdr_read(__pyx_v_self->htsfile);
            }

            /* "pysam/calignmentfile.pyx":565
 *                 # unmapped reads)
 *                 if check_header:
 *                     with nogil:             # <<<<<<<<<<<<<<
 *                         self.header = sam_hdr_read(self.htsfile)
 *                     if self.header == NULL:
 */
            /*finally:*/ {
              /*normal exit:*/{
                #ifdef WITH_THREAD
                Py_BLOCK_THREADS
                #endif
                goto __pyx_L75;
              }
              __pyx_L75:;
            }
        }

        /* "pysam/calignmentfile.pyx":567
 *                     with nogil:
 *                         self.header = sam_hdr_read(self.htsfile)
 *                     if self.header == NULL:             # <<<<<<<<<<<<<<
 *                         raise ValueError(
 *                             "file does not have valid header (mode='%s') "
 */
        __pyx_t_15 = ((__pyx_v_self->header == NULL) != 0);
        if (__pyx_t_15) {

          /* "pysam/calignmentfile.pyx":570
 *                         raise ValueError(
 *                             "file does not have valid header (mode='%s') "
 *                             "- is it SAM format?" % mode )             # <<<<<<<<<<<<<<
 *                     # self.header.ignore_sam_err = True
 * 
 */
          __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_file_does_not_have_valid_header_2, __pyx_v_mode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 570, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_4);

          /* "pysam/calignmentfile.pyx":568
 *                         self.header = sam_hdr_read(self.htsfile)
 *                     if self.header == NULL:
 *                         raise ValueError(             # <<<<<<<<<<<<<<
 *                             "file does not have valid header (mode='%s') "
 *                             "- is it SAM format?" % mode )
 */
          __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 568, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_3);
          __Pyx_GIVEREF(__pyx_t_4);
          PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
          __pyx_t_4 = 0;
          __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_3, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 568, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_4);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          __Pyx_Raise(__pyx_t_4, 0, 0, 0);
          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
          __PYX_ERR(0, 568, __pyx_L1_error)

          /* "pysam/calignmentfile.pyx":567
 *                     with nogil:
 *                         self.header = sam_hdr_read(self.htsfile)
 *                     if self.header == NULL:             # <<<<<<<<<<<<<<
 *                         raise ValueError(
 *                             "file does not have valid header (mode='%s') "
 */
        }

        /* "pysam/calignmentfile.pyx":564
 *                 # in sam files it is optional (htsfile full of
 *                 # unmapped reads)
 *                 if check_header:             # <<<<<<<<<<<<<<
 *                     with nogil:
 *                         self.header = sam_hdr_read(self.htsfile)
 */
      }
    }
    __pyx_L65:;

    /* "pysam/calignmentfile.pyx":573
 *                     # self.header.ignore_sam_err = True
 * 
 *             if check_sq and self.header.n_targets == 0:             # <<<<<<<<<<<<<<
 *                 raise ValueError(
 *                     ("file has no sequences defined (mode='%s') - "
 */
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_check_sq); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 573, __pyx_L1_error)
    if (__pyx_t_2) {
    } else {
      __pyx_t_15 = __pyx_t_2;
      goto __pyx_L78_bool_binop_done;
    }
    __pyx_t_2 = ((__pyx_v_self->header->n_targets == 0) != 0);
    __pyx_t_15 = __pyx_t_2;
    __pyx_L78_bool_binop_done:;
    if (__pyx_t_15) {

      /* "pysam/calignmentfile.pyx":577
 *                     ("file has no sequences defined (mode='%s') - "
 *                      "is it SAM/BAM format? Consider opening with "
 *                      "check_seq=True") % mode)             # <<<<<<<<<<<<<<
 * 
 *         if self.htsfile == NULL:
 */
      __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_file_has_no_sequences_defined_mo, __pyx_v_mode); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 577, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);

      /* "pysam/calignmentfile.pyx":574
 * 
 *             if check_sq and self.header.n_targets == 0:
 *                 raise ValueError(             # <<<<<<<<<<<<<<
 *                     ("file has no sequences defined (mode='%s') - "
 *                      "is it SAM/BAM format? Consider opening with "
 */
      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 574, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_GIVEREF(__pyx_t_4);
      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
      __pyx_t_4 = 0;
      __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_3, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 574, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_Raise(__pyx_t_4, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __PYX_ERR(0, 574, __pyx_L1_error)

      /* "pysam/calignmentfile.pyx":573
 *                     # self.header.ignore_sam_err = True
 * 
 *             if check_sq and self.header.n_targets == 0:             # <<<<<<<<<<<<<<
 *                 raise ValueError(
 *                     ("file has no sequences defined (mode='%s') - "
 */
    }

    /* "pysam/calignmentfile.pyx":528
 *                     sam_hdr_write(self.htsfile, self.header)
 * 
 *         elif mode[0] == "r":             # <<<<<<<<<<<<<<
 *             # open file for reading
 *             if (filename != b"-"
 */
  }
  __pyx_L20:;

  /* "pysam/calignmentfile.pyx":579
 *                      "check_seq=True") % mode)
 * 
 *         if self.htsfile == NULL:             # <<<<<<<<<<<<<<
 *             raise IOError("could not open file `%s`" % filename )
 * 
 */
  __pyx_t_15 = ((__pyx_v_self->htsfile == NULL) != 0);
  if (__pyx_t_15) {

    /* "pysam/calignmentfile.pyx":580
 * 
 *         if self.htsfile == NULL:
 *             raise IOError("could not open file `%s`" % filename )             # <<<<<<<<<<<<<<
 * 
 *         # check for index and open if present
 */
    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_could_not_open_file_s, __pyx_v_filename); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 580, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 580, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
    __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_IOError, __pyx_t_3, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 580, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 580, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":579
 *                      "check_seq=True") % mode)
 * 
 *         if self.htsfile == NULL:             # <<<<<<<<<<<<<<
 *             raise IOError("could not open file `%s`" % filename )
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":583
 * 
 *         # check for index and open if present
 *         cdef int format_index = -1             # <<<<<<<<<<<<<<
 *         if self.is_bam:
 *             format_index = HTS_FMT_BAI
 */
  __pyx_v_format_index = -1;

  /* "pysam/calignmentfile.pyx":584
 *         # check for index and open if present
 *         cdef int format_index = -1
 *         if self.is_bam:             # <<<<<<<<<<<<<<
 *             format_index = HTS_FMT_BAI
 *         elif self.is_cram:
 */
  __pyx_t_15 = (__pyx_v_self->is_bam != 0);
  if (__pyx_t_15) {

    /* "pysam/calignmentfile.pyx":585
 *         cdef int format_index = -1
 *         if self.is_bam:
 *             format_index = HTS_FMT_BAI             # <<<<<<<<<<<<<<
 *         elif self.is_cram:
 *             format_index = HTS_FMT_CRAI
 */
    __pyx_v_format_index = HTS_FMT_BAI;

    /* "pysam/calignmentfile.pyx":584
 *         # check for index and open if present
 *         cdef int format_index = -1
 *         if self.is_bam:             # <<<<<<<<<<<<<<
 *             format_index = HTS_FMT_BAI
 *         elif self.is_cram:
 */
    goto __pyx_L81;
  }

  /* "pysam/calignmentfile.pyx":586
 *         if self.is_bam:
 *             format_index = HTS_FMT_BAI
 *         elif self.is_cram:             # <<<<<<<<<<<<<<
 *             format_index = HTS_FMT_CRAI
 * 
 */
  __pyx_t_15 = (__pyx_v_self->is_cram != 0);
  if (__pyx_t_15) {

    /* "pysam/calignmentfile.pyx":587
 *             format_index = HTS_FMT_BAI
 *         elif self.is_cram:
 *             format_index = HTS_FMT_CRAI             # <<<<<<<<<<<<<<
 * 
 *         if mode[0] == "r" and (self.is_bam or self.is_cram):
 */
    __pyx_v_format_index = HTS_FMT_CRAI;

    /* "pysam/calignmentfile.pyx":586
 *         if self.is_bam:
 *             format_index = HTS_FMT_BAI
 *         elif self.is_cram:             # <<<<<<<<<<<<<<
 *             format_index = HTS_FMT_CRAI
 * 
 */
  }
  __pyx_L81:;

  /* "pysam/calignmentfile.pyx":589
 *             format_index = HTS_FMT_CRAI
 * 
 *         if mode[0] == "r" and (self.is_bam or self.is_cram):             # <<<<<<<<<<<<<<
 * 
 *             # open index for remote files
 */
  __pyx_t_4 = __Pyx_GetItemInt(__pyx_v_mode, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 589, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_2 = (__Pyx_PyString_Equals(__pyx_t_4, __pyx_n_s_r, Py_EQ)); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 589, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  if (__pyx_t_2) {
  } else {
    __pyx_t_15 = __pyx_t_2;
    goto __pyx_L83_bool_binop_done;
  }
  __pyx_t_2 = (__pyx_v_self->is_bam != 0);
  if (!__pyx_t_2) {
  } else {
    __pyx_t_15 = __pyx_t_2;
    goto __pyx_L83_bool_binop_done;
  }
  __pyx_t_2 = (__pyx_v_self->is_cram != 0);
  __pyx_t_15 = __pyx_t_2;
  __pyx_L83_bool_binop_done:;
  if (__pyx_t_15) {

    /* "pysam/calignmentfile.pyx":592
 * 
 *             # open index for remote files
 *             if self.is_remote and not filepath_index:             # <<<<<<<<<<<<<<
 *                 cfilename = filename
 * 
 */
    __pyx_t_2 = (__pyx_v_self->is_remote != 0);
    if (__pyx_t_2) {
    } else {
      __pyx_t_15 = __pyx_t_2;
      goto __pyx_L87_bool_binop_done;
    }
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_filepath_index); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 592, __pyx_L1_error)
    __pyx_t_1 = ((!__pyx_t_2) != 0);
    __pyx_t_15 = __pyx_t_1;
    __pyx_L87_bool_binop_done:;
    if (__pyx_t_15) {

      /* "pysam/calignmentfile.pyx":593
 *             # open index for remote files
 *             if self.is_remote and not filepath_index:
 *                 cfilename = filename             # <<<<<<<<<<<<<<
 * 
 *                 with nogil:
 */
      __pyx_t_17 = __Pyx_PyObject_AsString(__pyx_v_filename); if (unlikely((!__pyx_t_17) && PyErr_Occurred())) __PYX_ERR(0, 593, __pyx_L1_error)
      __pyx_v_cfilename = __pyx_t_17;

      /* "pysam/calignmentfile.pyx":595
 *                 cfilename = filename
 * 
 *                 with nogil:             # <<<<<<<<<<<<<<
 *                     self.index = hts_idx_load(cfilename, format_index)
 *                 if self.index == NULL:
 */
      {
          #ifdef WITH_THREAD
          PyThreadState *_save;
          Py_UNBLOCK_THREADS
          #endif
          /*try:*/ {

            /* "pysam/calignmentfile.pyx":596
 * 
 *                 with nogil:
 *                     self.index = hts_idx_load(cfilename, format_index)             # <<<<<<<<<<<<<<
 *                 if self.index == NULL:
 *                     warnings.warn(
 */
            __pyx_v_self->index = hts_idx_load(__pyx_v_cfilename, __pyx_v_format_index);
          }

          /* "pysam/calignmentfile.pyx":595
 *                 cfilename = filename
 * 
 *                 with nogil:             # <<<<<<<<<<<<<<
 *                     self.index = hts_idx_load(cfilename, format_index)
 *                 if self.index == NULL:
 */
          /*finally:*/ {
            /*normal exit:*/{
              #ifdef WITH_THREAD
              Py_BLOCK_THREADS
              #endif
              goto __pyx_L91;
            }
            __pyx_L91:;
          }
      }

      /* "pysam/calignmentfile.pyx":597
 *                 with nogil:
 *                     self.index = hts_idx_load(cfilename, format_index)
 *                 if self.index == NULL:             # <<<<<<<<<<<<<<
 *                     warnings.warn(
 *                         "unable to open remote index for '%s'" % cfilename)
 */
      __pyx_t_15 = ((__pyx_v_self->index == NULL) != 0);
      if (__pyx_t_15) {

        /* "pysam/calignmentfile.pyx":598
 *                     self.index = hts_idx_load(cfilename, format_index)
 *                 if self.index == NULL:
 *                     warnings.warn(             # <<<<<<<<<<<<<<
 *                         "unable to open remote index for '%s'" % cfilename)
 *             else:
 */
        __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_warnings); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 598, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_21 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_warn); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 598, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_21);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

        /* "pysam/calignmentfile.pyx":599
 *                 if self.index == NULL:
 *                     warnings.warn(
 *                         "unable to open remote index for '%s'" % cfilename)             # <<<<<<<<<<<<<<
 *             else:
 *                 has_index = True
 */
        __pyx_t_3 = __Pyx_PyBytes_FromString(__pyx_v_cfilename); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 599, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_5 = __Pyx_PyString_Format(__pyx_kp_s_unable_to_open_remote_index_for, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 599, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_3 = NULL;
        if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_21))) {
          __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_21);
          if (likely(__pyx_t_3)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_21);
            __Pyx_INCREF(__pyx_t_3);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_21, function);
          }
        }
        if (!__pyx_t_3) {
          __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_21, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 598, __pyx_L1_error)
          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_GOTREF(__pyx_t_4);
        } else {
          __pyx_t_22 = PyTuple_New(1+1); if (unlikely(!__pyx_t_22)) __PYX_ERR(0, 598, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_22);
          __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_22, 0, __pyx_t_3); __pyx_t_3 = NULL;
          __Pyx_GIVEREF(__pyx_t_5);
          PyTuple_SET_ITEM(__pyx_t_22, 0+1, __pyx_t_5);
          __pyx_t_5 = 0;
          __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_21, __pyx_t_22, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 598, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_4);
          __Pyx_DECREF(__pyx_t_22); __pyx_t_22 = 0;
        }
        __Pyx_DECREF(__pyx_t_21); __pyx_t_21 = 0;
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

        /* "pysam/calignmentfile.pyx":597
 *                 with nogil:
 *                     self.index = hts_idx_load(cfilename, format_index)
 *                 if self.index == NULL:             # <<<<<<<<<<<<<<
 *                     warnings.warn(
 *                         "unable to open remote index for '%s'" % cfilename)
 */
      }

      /* "pysam/calignmentfile.pyx":592
 * 
 *             # open index for remote files
 *             if self.is_remote and not filepath_index:             # <<<<<<<<<<<<<<
 *                 cfilename = filename
 * 
 */
      goto __pyx_L86;
    }

    /* "pysam/calignmentfile.pyx":601
 *                         "unable to open remote index for '%s'" % cfilename)
 *             else:
 *                 has_index = True             # <<<<<<<<<<<<<<
 *                 cfilename = filename
 *                 if filepath_index:
 */
    /*else*/ {
      __pyx_v_has_index = 1;

      /* "pysam/calignmentfile.pyx":602
 *             else:
 *                 has_index = True
 *                 cfilename = filename             # <<<<<<<<<<<<<<
 *                 if filepath_index:
 *                     if not os.path.exists(filepath_index):
 */
      __pyx_t_17 = __Pyx_PyObject_AsString(__pyx_v_filename); if (unlikely((!__pyx_t_17) && PyErr_Occurred())) __PYX_ERR(0, 602, __pyx_L1_error)
      __pyx_v_cfilename = __pyx_t_17;

      /* "pysam/calignmentfile.pyx":603
 *                 has_index = True
 *                 cfilename = filename
 *                 if filepath_index:             # <<<<<<<<<<<<<<
 *                     if not os.path.exists(filepath_index):
 *                         warnings.warn(
 */
      __pyx_t_15 = __Pyx_PyObject_IsTrue(__pyx_v_filepath_index); if (unlikely(__pyx_t_15 < 0)) __PYX_ERR(0, 603, __pyx_L1_error)
      if (__pyx_t_15) {

        /* "pysam/calignmentfile.pyx":604
 *                 cfilename = filename
 *                 if filepath_index:
 *                     if not os.path.exists(filepath_index):             # <<<<<<<<<<<<<<
 *                         warnings.warn(
 *                             "unable to open index at %s" % cfilename)
 */
        __pyx_t_21 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 604, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_21);
        __pyx_t_22 = __Pyx_PyObject_GetAttrStr(__pyx_t_21, __pyx_n_s_path); if (unlikely(!__pyx_t_22)) __PYX_ERR(0, 604, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_22);
        __Pyx_DECREF(__pyx_t_21); __pyx_t_21 = 0;
        __pyx_t_21 = __Pyx_PyObject_GetAttrStr(__pyx_t_22, __pyx_n_s_exists); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 604, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_21);
        __Pyx_DECREF(__pyx_t_22); __pyx_t_22 = 0;
        __pyx_t_22 = NULL;
        if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_21))) {
          __pyx_t_22 = PyMethod_GET_SELF(__pyx_t_21);
          if (likely(__pyx_t_22)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_21);
            __Pyx_INCREF(__pyx_t_22);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_21, function);
          }
        }
        if (!__pyx_t_22) {
          __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_21, __pyx_v_filepath_index); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 604, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_4);
        } else {
          __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 604, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_5);
          __Pyx_GIVEREF(__pyx_t_22); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_22); __pyx_t_22 = NULL;
          __Pyx_INCREF(__pyx_v_filepath_index);
          __Pyx_GIVEREF(__pyx_v_filepath_index);
          PyTuple_SET_ITEM(__pyx_t_5, 0+1, __pyx_v_filepath_index);
          __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_21, __pyx_t_5, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 604, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_4);
          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        }
        __Pyx_DECREF(__pyx_t_21); __pyx_t_21 = 0;
        __pyx_t_15 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_15 < 0)) __PYX_ERR(0, 604, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __pyx_t_1 = ((!__pyx_t_15) != 0);
        if (__pyx_t_1) {

          /* "pysam/calignmentfile.pyx":605
 *                 if filepath_index:
 *                     if not os.path.exists(filepath_index):
 *                         warnings.warn(             # <<<<<<<<<<<<<<
 *                             "unable to open index at %s" % cfilename)
 *                         self.index = NULL
 */
          __pyx_t_21 = __Pyx_GetModuleGlobalName(__pyx_n_s_warnings); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 605, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_21);
          __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_21, __pyx_n_s_warn); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 605, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_5);
          __Pyx_DECREF(__pyx_t_21); __pyx_t_21 = 0;

          /* "pysam/calignmentfile.pyx":606
 *                     if not os.path.exists(filepath_index):
 *                         warnings.warn(
 *                             "unable to open index at %s" % cfilename)             # <<<<<<<<<<<<<<
 *                         self.index = NULL
 *                         has_index = False
 */
          __pyx_t_21 = __Pyx_PyBytes_FromString(__pyx_v_cfilename); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 606, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_21);
          __pyx_t_22 = __Pyx_PyString_Format(__pyx_kp_s_unable_to_open_index_at_s, __pyx_t_21); if (unlikely(!__pyx_t_22)) __PYX_ERR(0, 606, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_22);
          __Pyx_DECREF(__pyx_t_21); __pyx_t_21 = 0;
          __pyx_t_21 = NULL;
          if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_5))) {
            __pyx_t_21 = PyMethod_GET_SELF(__pyx_t_5);
            if (likely(__pyx_t_21)) {
              PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
              __Pyx_INCREF(__pyx_t_21);
              __Pyx_INCREF(function);
              __Pyx_DECREF_SET(__pyx_t_5, function);
            }
          }
          if (!__pyx_t_21) {
            __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_22); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 605, __pyx_L1_error)
            __Pyx_DECREF(__pyx_t_22); __pyx_t_22 = 0;
            __Pyx_GOTREF(__pyx_t_4);
          } else {
            __pyx_t_3 = PyTuple_New(1+1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 605, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_3);
            __Pyx_GIVEREF(__pyx_t_21); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_21); __pyx_t_21 = NULL;
            __Pyx_GIVEREF(__pyx_t_22);
            PyTuple_SET_ITEM(__pyx_t_3, 0+1, __pyx_t_22);
            __pyx_t_22 = 0;
            __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_3, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 605, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_4);
            __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          }
          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

          /* "pysam/calignmentfile.pyx":607
 *                         warnings.warn(
 *                             "unable to open index at %s" % cfilename)
 *                         self.index = NULL             # <<<<<<<<<<<<<<
 *                         has_index = False
 *                 else:
 */
          __pyx_v_self->index = NULL;

          /* "pysam/calignmentfile.pyx":608
 *                             "unable to open index at %s" % cfilename)
 *                         self.index = NULL
 *                         has_index = False             # <<<<<<<<<<<<<<
 *                 else:
 *                     if self.is_bam \
 */
          __pyx_v_has_index = 0;

          /* "pysam/calignmentfile.pyx":604
 *                 cfilename = filename
 *                 if filepath_index:
 *                     if not os.path.exists(filepath_index):             # <<<<<<<<<<<<<<
 *                         warnings.warn(
 *                             "unable to open index at %s" % cfilename)
 */
        }

        /* "pysam/calignmentfile.pyx":603
 *                 has_index = True
 *                 cfilename = filename
 *                 if filepath_index:             # <<<<<<<<<<<<<<
 *                     if not os.path.exists(filepath_index):
 *                         warnings.warn(
 */
        goto __pyx_L93;
      }

      /* "pysam/calignmentfile.pyx":610
 *                         has_index = False
 *                 else:
 *                     if self.is_bam \             # <<<<<<<<<<<<<<
 *                             and not os.path.exists(filename + b".bai") \
 *                             and not os.path.exists(filename[:-4] + b".bai"):
 */
      /*else*/ {

        /* "pysam/calignmentfile.pyx":611
 *                 else:
 *                     if self.is_bam \
 *                             and not os.path.exists(filename + b".bai") \             # <<<<<<<<<<<<<<
 *                             and not os.path.exists(filename[:-4] + b".bai"):
 *                         self.index = NULL
 */
        __pyx_t_15 = (__pyx_v_self->is_bam != 0);
        if (__pyx_t_15) {
        } else {
          __pyx_t_1 = __pyx_t_15;
          goto __pyx_L96_bool_binop_done;
        }

        /* "pysam/calignmentfile.pyx":612
 *                     if self.is_bam \
 *                             and not os.path.exists(filename + b".bai") \
 *                             and not os.path.exists(filename[:-4] + b".bai"):             # <<<<<<<<<<<<<<
 *                         self.index = NULL
 *                         has_index = False
 */
        __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 611, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);

        /* "pysam/calignmentfile.pyx":611
 *                 else:
 *                     if self.is_bam \
 *                             and not os.path.exists(filename + b".bai") \             # <<<<<<<<<<<<<<
 *                             and not os.path.exists(filename[:-4] + b".bai"):
 *                         self.index = NULL
 */
        __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_path); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 611, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_exists); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 611, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_3 = PyNumber_Add(__pyx_v_filename, __pyx_kp_b_bai); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 611, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_22 = NULL;
        if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_5))) {
          __pyx_t_22 = PyMethod_GET_SELF(__pyx_t_5);
          if (likely(__pyx_t_22)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
            __Pyx_INCREF(__pyx_t_22);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_5, function);
          }
        }
        if (!__pyx_t_22) {
          __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 611, __pyx_L1_error)
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          __Pyx_GOTREF(__pyx_t_4);
        } else {
          __pyx_t_21 = PyTuple_New(1+1); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 611, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_21);
          __Pyx_GIVEREF(__pyx_t_22); PyTuple_SET_ITEM(__pyx_t_21, 0, __pyx_t_22); __pyx_t_22 = NULL;
          __Pyx_GIVEREF(__pyx_t_3);
          PyTuple_SET_ITEM(__pyx_t_21, 0+1, __pyx_t_3);
          __pyx_t_3 = 0;
          __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_21, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 611, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_4);
          __Pyx_DECREF(__pyx_t_21); __pyx_t_21 = 0;
        }
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __pyx_t_15 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_15 < 0)) __PYX_ERR(0, 611, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __pyx_t_2 = ((!__pyx_t_15) != 0);
        if (__pyx_t_2) {
        } else {
          __pyx_t_1 = __pyx_t_2;
          goto __pyx_L96_bool_binop_done;
        }

        /* "pysam/calignmentfile.pyx":612
 *                     if self.is_bam \
 *                             and not os.path.exists(filename + b".bai") \
 *                             and not os.path.exists(filename[:-4] + b".bai"):             # <<<<<<<<<<<<<<
 *                         self.index = NULL
 *                         has_index = False
 */
        __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 612, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __pyx_t_21 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_path); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 612, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_21);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_21, __pyx_n_s_exists); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 612, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_DECREF(__pyx_t_21); __pyx_t_21 = 0;
        __pyx_t_21 = __Pyx_PyObject_GetSlice(__pyx_v_filename, 0, -4L, NULL, NULL, &__pyx_slice__14, 0, 1, 1); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 612, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_21);
        __pyx_t_3 = PyNumber_Add(__pyx_t_21, __pyx_kp_b_bai); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 612, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_21); __pyx_t_21 = 0;
        __pyx_t_21 = NULL;
        if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_5))) {
          __pyx_t_21 = PyMethod_GET_SELF(__pyx_t_5);
          if (likely(__pyx_t_21)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
            __Pyx_INCREF(__pyx_t_21);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_5, function);
          }
        }
        if (!__pyx_t_21) {
          __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 612, __pyx_L1_error)
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          __Pyx_GOTREF(__pyx_t_4);
        } else {
          __pyx_t_22 = PyTuple_New(1+1); if (unlikely(!__pyx_t_22)) __PYX_ERR(0, 612, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_22);
          __Pyx_GIVEREF(__pyx_t_21); PyTuple_SET_ITEM(__pyx_t_22, 0, __pyx_t_21); __pyx_t_21 = NULL;
          __Pyx_GIVEREF(__pyx_t_3);
          PyTuple_SET_ITEM(__pyx_t_22, 0+1, __pyx_t_3);
          __pyx_t_3 = 0;
          __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_22, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 612, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_4);
          __Pyx_DECREF(__pyx_t_22); __pyx_t_22 = 0;
        }
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 612, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __pyx_t_15 = ((!__pyx_t_2) != 0);
        __pyx_t_1 = __pyx_t_15;
        __pyx_L96_bool_binop_done:;

        /* "pysam/calignmentfile.pyx":610
 *                         has_index = False
 *                 else:
 *                     if self.is_bam \             # <<<<<<<<<<<<<<
 *                             and not os.path.exists(filename + b".bai") \
 *                             and not os.path.exists(filename[:-4] + b".bai"):
 */
        if (__pyx_t_1) {

          /* "pysam/calignmentfile.pyx":613
 *                             and not os.path.exists(filename + b".bai") \
 *                             and not os.path.exists(filename[:-4] + b".bai"):
 *                         self.index = NULL             # <<<<<<<<<<<<<<
 *                         has_index = False
 *                     elif self.is_cram \
 */
          __pyx_v_self->index = NULL;

          /* "pysam/calignmentfile.pyx":614
 *                             and not os.path.exists(filename[:-4] + b".bai"):
 *                         self.index = NULL
 *                         has_index = False             # <<<<<<<<<<<<<<
 *                     elif self.is_cram \
 *                             and not os.path.exists(filename + b".crai") \
 */
          __pyx_v_has_index = 0;

          /* "pysam/calignmentfile.pyx":610
 *                         has_index = False
 *                 else:
 *                     if self.is_bam \             # <<<<<<<<<<<<<<
 *                             and not os.path.exists(filename + b".bai") \
 *                             and not os.path.exists(filename[:-4] + b".bai"):
 */
          goto __pyx_L95;
        }

        /* "pysam/calignmentfile.pyx":615
 *                         self.index = NULL
 *                         has_index = False
 *                     elif self.is_cram \             # <<<<<<<<<<<<<<
 *                             and not os.path.exists(filename + b".crai") \
 *                             and not os.path.exists(filename[:-5] + b".crai"):
 */
        __pyx_t_15 = (__pyx_v_self->is_cram != 0);
        if (__pyx_t_15) {
        } else {
          __pyx_t_1 = __pyx_t_15;
          goto __pyx_L99_bool_binop_done;
        }

        /* "pysam/calignmentfile.pyx":616
 *                         has_index = False
 *                     elif self.is_cram \
 *                             and not os.path.exists(filename + b".crai") \             # <<<<<<<<<<<<<<
 *                             and not os.path.exists(filename[:-5] + b".crai"):
 *                         self.index = NULL
 */
        __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 616, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __pyx_t_22 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_path); if (unlikely(!__pyx_t_22)) __PYX_ERR(0, 616, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_22);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_22, __pyx_n_s_exists); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 616, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_DECREF(__pyx_t_22); __pyx_t_22 = 0;
        __pyx_t_22 = PyNumber_Add(__pyx_v_filename, __pyx_kp_b_crai); if (unlikely(!__pyx_t_22)) __PYX_ERR(0, 616, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_22);
        __pyx_t_3 = NULL;
        if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_5))) {
          __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
          if (likely(__pyx_t_3)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
            __Pyx_INCREF(__pyx_t_3);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_5, function);
          }
        }
        if (!__pyx_t_3) {
          __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_22); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 616, __pyx_L1_error)
          __Pyx_DECREF(__pyx_t_22); __pyx_t_22 = 0;
          __Pyx_GOTREF(__pyx_t_4);
        } else {
          __pyx_t_21 = PyTuple_New(1+1); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 616, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_21);
          __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_21, 0, __pyx_t_3); __pyx_t_3 = NULL;
          __Pyx_GIVEREF(__pyx_t_22);
          PyTuple_SET_ITEM(__pyx_t_21, 0+1, __pyx_t_22);
          __pyx_t_22 = 0;
          __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_21, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 616, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_4);
          __Pyx_DECREF(__pyx_t_21); __pyx_t_21 = 0;
        }
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __pyx_t_15 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_15 < 0)) __PYX_ERR(0, 616, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __pyx_t_2 = ((!__pyx_t_15) != 0);
        if (__pyx_t_2) {
        } else {
          __pyx_t_1 = __pyx_t_2;
          goto __pyx_L99_bool_binop_done;
        }

        /* "pysam/calignmentfile.pyx":617
 *                     elif self.is_cram \
 *                             and not os.path.exists(filename + b".crai") \
 *                             and not os.path.exists(filename[:-5] + b".crai"):             # <<<<<<<<<<<<<<
 *                         self.index = NULL
 *                         has_index = False
 */
        __pyx_t_5 = __Pyx_GetModuleGlobalName(__pyx_n_s_os); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 617, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __pyx_t_21 = __Pyx_PyObject_GetAttrStr(__pyx_t_5, __pyx_n_s_path); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 617, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_21);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __pyx_t_5 = __Pyx_PyObject_GetAttrStr(__pyx_t_21, __pyx_n_s_exists); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 617, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_DECREF(__pyx_t_21); __pyx_t_21 = 0;
        __pyx_t_21 = __Pyx_PyObject_GetSlice(__pyx_v_filename, 0, -5L, NULL, NULL, &__pyx_slice__15, 0, 1, 1); if (unlikely(!__pyx_t_21)) __PYX_ERR(0, 617, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_21);
        __pyx_t_22 = PyNumber_Add(__pyx_t_21, __pyx_kp_b_crai); if (unlikely(!__pyx_t_22)) __PYX_ERR(0, 617, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_22);
        __Pyx_DECREF(__pyx_t_21); __pyx_t_21 = 0;
        __pyx_t_21 = NULL;
        if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_5))) {
          __pyx_t_21 = PyMethod_GET_SELF(__pyx_t_5);
          if (likely(__pyx_t_21)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
            __Pyx_INCREF(__pyx_t_21);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_5, function);
          }
        }
        if (!__pyx_t_21) {
          __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_22); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 617, __pyx_L1_error)
          __Pyx_DECREF(__pyx_t_22); __pyx_t_22 = 0;
          __Pyx_GOTREF(__pyx_t_4);
        } else {
          __pyx_t_3 = PyTuple_New(1+1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 617, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_3);
          __Pyx_GIVEREF(__pyx_t_21); PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_21); __pyx_t_21 = NULL;
          __Pyx_GIVEREF(__pyx_t_22);
          PyTuple_SET_ITEM(__pyx_t_3, 0+1, __pyx_t_22);
          __pyx_t_22 = 0;
          __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_3, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 617, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_4);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        }
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 617, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        __pyx_t_15 = ((!__pyx_t_2) != 0);
        __pyx_t_1 = __pyx_t_15;
        __pyx_L99_bool_binop_done:;

        /* "pysam/calignmentfile.pyx":615
 *                         self.index = NULL
 *                         has_index = False
 *                     elif self.is_cram \             # <<<<<<<<<<<<<<
 *                             and not os.path.exists(filename + b".crai") \
 *                             and not os.path.exists(filename[:-5] + b".crai"):
 */
        if (__pyx_t_1) {

          /* "pysam/calignmentfile.pyx":618
 *                             and not os.path.exists(filename + b".crai") \
 *                             and not os.path.exists(filename[:-5] + b".crai"):
 *                         self.index = NULL             # <<<<<<<<<<<<<<
 *                         has_index = False
 * 
 */
          __pyx_v_self->index = NULL;

          /* "pysam/calignmentfile.pyx":619
 *                             and not os.path.exists(filename[:-5] + b".crai"):
 *                         self.index = NULL
 *                         has_index = False             # <<<<<<<<<<<<<<
 * 
 *                 if has_index:
 */
          __pyx_v_has_index = 0;

          /* "pysam/calignmentfile.pyx":615
 *                         self.index = NULL
 *                         has_index = False
 *                     elif self.is_cram \             # <<<<<<<<<<<<<<
 *                             and not os.path.exists(filename + b".crai") \
 *                             and not os.path.exists(filename[:-5] + b".crai"):
 */
        }
        __pyx_L95:;
      }
      __pyx_L93:;

      /* "pysam/calignmentfile.pyx":621
 *                         has_index = False
 * 
 *                 if has_index:             # <<<<<<<<<<<<<<
 *                     # returns NULL if there is no index or index could
 *                     # not be opened
 */
      __pyx_t_1 = (__pyx_v_has_index != 0);
      if (__pyx_t_1) {

        /* "pysam/calignmentfile.pyx":624
 *                     # returns NULL if there is no index or index could
 *                     # not be opened
 *                     if filepath_index:             # <<<<<<<<<<<<<<
 *                         cindexname = filepath_index = encode_filename(filepath_index)
 *                         with nogil:
 */
        __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_filepath_index); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 624, __pyx_L1_error)
        if (__pyx_t_1) {

          /* "pysam/calignmentfile.pyx":625
 *                     # not be opened
 *                     if filepath_index:
 *                         cindexname = filepath_index = encode_filename(filepath_index)             # <<<<<<<<<<<<<<
 *                         with nogil:
 *                             self.index = sam_index_load2(self.htsfile,
 */
          __pyx_t_4 = __pyx_f_5pysam_6cutils_encode_filename(__pyx_v_filepath_index); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 625, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_4);
          __pyx_t_17 = __Pyx_PyObject_AsString(__pyx_t_4); if (unlikely((!__pyx_t_17) && PyErr_Occurred())) __PYX_ERR(0, 625, __pyx_L1_error)
          __pyx_v_cindexname = __pyx_t_17;
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_DECREF_SET(__pyx_v_filepath_index, __pyx_t_4);
          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

          /* "pysam/calignmentfile.pyx":626
 *                     if filepath_index:
 *                         cindexname = filepath_index = encode_filename(filepath_index)
 *                         with nogil:             # <<<<<<<<<<<<<<
 *                             self.index = sam_index_load2(self.htsfile,
 *                                                          cfilename,
 */
          {
              #ifdef WITH_THREAD
              PyThreadState *_save;
              Py_UNBLOCK_THREADS
              #endif
              /*try:*/ {

                /* "pysam/calignmentfile.pyx":627
 *                         cindexname = filepath_index = encode_filename(filepath_index)
 *                         with nogil:
 *                             self.index = sam_index_load2(self.htsfile,             # <<<<<<<<<<<<<<
 *                                                          cfilename,
 *                                                          cindexname)
 */
                __pyx_v_self->index = sam_index_load2(__pyx_v_self->htsfile, __pyx_v_cfilename, __pyx_v_cindexname);
              }

              /* "pysam/calignmentfile.pyx":626
 *                     if filepath_index:
 *                         cindexname = filepath_index = encode_filename(filepath_index)
 *                         with nogil:             # <<<<<<<<<<<<<<
 *                             self.index = sam_index_load2(self.htsfile,
 *                                                          cfilename,
 */
              /*finally:*/ {
                /*normal exit:*/{
                  #ifdef WITH_THREAD
                  Py_BLOCK_THREADS
                  #endif
                  goto __pyx_L106;
                }
                __pyx_L106:;
              }
          }

          /* "pysam/calignmentfile.pyx":624
 *                     # returns NULL if there is no index or index could
 *                     # not be opened
 *                     if filepath_index:             # <<<<<<<<<<<<<<
 *                         cindexname = filepath_index = encode_filename(filepath_index)
 *                         with nogil:
 */
          goto __pyx_L103;
        }

        /* "pysam/calignmentfile.pyx":632
 * 
 *                     else:
 *                         with nogil:             # <<<<<<<<<<<<<<
 *                             self.index = sam_index_load(self.htsfile,
 *                                                         cfilename)
 */
        /*else*/ {
          {
              #ifdef WITH_THREAD
              PyThreadState *_save;
              Py_UNBLOCK_THREADS
              #endif
              /*try:*/ {

                /* "pysam/calignmentfile.pyx":633
 *                     else:
 *                         with nogil:
 *                             self.index = sam_index_load(self.htsfile,             # <<<<<<<<<<<<<<
 *                                                         cfilename)
 *                     if self.index == NULL:
 */
                __pyx_v_self->index = sam_index_load(__pyx_v_self->htsfile, __pyx_v_cfilename);
              }

              /* "pysam/calignmentfile.pyx":632
 * 
 *                     else:
 *                         with nogil:             # <<<<<<<<<<<<<<
 *                             self.index = sam_index_load(self.htsfile,
 *                                                         cfilename)
 */
              /*finally:*/ {
                /*normal exit:*/{
                  #ifdef WITH_THREAD
                  Py_BLOCK_THREADS
                  #endif
                  goto __pyx_L109;
                }
                __pyx_L109:;
              }
          }
        }
        __pyx_L103:;

        /* "pysam/calignmentfile.pyx":635
 *                             self.index = sam_index_load(self.htsfile,
 *                                                         cfilename)
 *                     if self.index == NULL:             # <<<<<<<<<<<<<<
 *                         raise IOError(
 *                             "error while opening index for '%s'" %
 */
        __pyx_t_1 = ((__pyx_v_self->index == NULL) != 0);
        if (__pyx_t_1) {

          /* "pysam/calignmentfile.pyx":637
 *                     if self.index == NULL:
 *                         raise IOError(
 *                             "error while opening index for '%s'" %             # <<<<<<<<<<<<<<
 *                             filename)
 * 
 */
          __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_error_while_opening_index_for_s, __pyx_v_filename); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 637, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_4);

          /* "pysam/calignmentfile.pyx":636
 *                                                         cfilename)
 *                     if self.index == NULL:
 *                         raise IOError(             # <<<<<<<<<<<<<<
 *                             "error while opening index for '%s'" %
 *                             filename)
 */
          __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 636, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_5);
          __Pyx_GIVEREF(__pyx_t_4);
          PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
          __pyx_t_4 = 0;
          __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_IOError, __pyx_t_5, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 636, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_4);
          __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
          __Pyx_Raise(__pyx_t_4, 0, 0, 0);
          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
          __PYX_ERR(0, 636, __pyx_L1_error)

          /* "pysam/calignmentfile.pyx":635
 *                             self.index = sam_index_load(self.htsfile,
 *                                                         cfilename)
 *                     if self.index == NULL:             # <<<<<<<<<<<<<<
 *                         raise IOError(
 *                             "error while opening index for '%s'" %
 */
        }

        /* "pysam/calignmentfile.pyx":621
 *                         has_index = False
 * 
 *                 if has_index:             # <<<<<<<<<<<<<<
 *                     # returns NULL if there is no index or index could
 *                     # not be opened
 */
      }
    }
    __pyx_L86:;

    /* "pysam/calignmentfile.pyx":641
 * 
 *             # save start of data section
 *             if not self.is_stream:             # <<<<<<<<<<<<<<
 *                 self.start_offset = self.tell()
 * 
 */
    __pyx_t_1 = ((!(__pyx_v_self->is_stream != 0)) != 0);
    if (__pyx_t_1) {

      /* "pysam/calignmentfile.pyx":642
 *             # save start of data section
 *             if not self.is_stream:
 *                 self.start_offset = self.tell()             # <<<<<<<<<<<<<<
 * 
 *     def get_tid(self, reference):
 */
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_tell); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 642, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_3 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_5))) {
        __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_5);
        if (likely(__pyx_t_3)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
          __Pyx_INCREF(__pyx_t_3);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_5, function);
        }
      }
      if (__pyx_t_3) {
        __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_5, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 642, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      } else {
        __pyx_t_4 = __Pyx_PyObject_CallNoArg(__pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 642, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_23 = __Pyx_PyInt_As_int64_t(__pyx_t_4); if (unlikely((__pyx_t_23 == (int64_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 642, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __pyx_v_self->start_offset = __pyx_t_23;

      /* "pysam/calignmentfile.pyx":641
 * 
 *             # save start of data section
 *             if not self.is_stream:             # <<<<<<<<<<<<<<
 *                 self.start_offset = self.tell()
 * 
 */
    }

    /* "pysam/calignmentfile.pyx":589
 *             format_index = HTS_FMT_CRAI
 * 
 *         if mode[0] == "r" and (self.is_bam or self.is_cram):             # <<<<<<<<<<<<<<
 * 
 *             # open index for remote files
 */
  }

  /* "pysam/calignmentfile.pyx":371
 *         return True
 * 
 *     def _open(self,             # <<<<<<<<<<<<<<
 *               filepath_or_object,
 *               mode=None,
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_21);
  __Pyx_XDECREF(__pyx_t_22);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile._open", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_filename);
  __Pyx_XDECREF(__pyx_v_bmode);
  __Pyx_XDECREF(__pyx_v_n);
  __Pyx_XDECREF(__pyx_v_x);
  __Pyx_XDECREF(__pyx_v_name);
  __Pyx_XDECREF(__pyx_v_fn);
  __Pyx_XDECREF(__pyx_v_ref);
  __Pyx_XDECREF(__pyx_v_mode);
  __Pyx_XDECREF(__pyx_v_reference_names);
  __Pyx_XDECREF(__pyx_v_reference_lengths);
  __Pyx_XDECREF(__pyx_v_text);
  __Pyx_XDECREF(__pyx_v_filepath_index);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":644
 *                 self.start_offset = self.tell()
 * 
 *     def get_tid(self, reference):             # <<<<<<<<<<<<<<
 *         """
 *         return the numerical :term:`tid` corresponding to
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_11get_tid(PyObject *__pyx_v_self, PyObject *__pyx_v_reference); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_10get_tid[] = "AlignmentFile.get_tid(self, reference)\n\n        return the numerical :term:`tid` corresponding to\n        :term:`reference`\n\n        returns -1 if reference is not known.\n        ";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_11get_tid(PyObject *__pyx_v_self, PyObject *__pyx_v_reference) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_tid (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_10get_tid(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self), ((PyObject *)__pyx_v_reference));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_10get_tid(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_reference) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  char const *__pyx_t_6;
  __Pyx_RefNannySetupContext("get_tid", 0);
  __Pyx_TraceCall("get_tid", __pyx_f[0], 644, 0, __PYX_ERR(0, 644, __pyx_L1_error));
  __Pyx_INCREF(__pyx_v_reference);

  /* "pysam/calignmentfile.pyx":651
 *         returns -1 if reference is not known.
 *         """
 *         if not self.is_open():             # <<<<<<<<<<<<<<
 *             raise ValueError("I/O operation on closed file")
 *         reference = force_bytes(reference)
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_open); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 651, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 651, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 651, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 651, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = ((!__pyx_t_4) != 0);
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":652
 *         """
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")             # <<<<<<<<<<<<<<
 *         reference = force_bytes(reference)
 *         return bam_name2id(self.header, reference)
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__16, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 652, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 652, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":651
 *         returns -1 if reference is not known.
 *         """
 *         if not self.is_open():             # <<<<<<<<<<<<<<
 *             raise ValueError("I/O operation on closed file")
 *         reference = force_bytes(reference)
 */
  }

  /* "pysam/calignmentfile.pyx":653
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")
 *         reference = force_bytes(reference)             # <<<<<<<<<<<<<<
 *         return bam_name2id(self.header, reference)
 * 
 */
  __pyx_t_1 = __pyx_f_5pysam_6cutils_force_bytes(__pyx_v_reference, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 653, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF_SET(__pyx_v_reference, __pyx_t_1);
  __pyx_t_1 = 0;

  /* "pysam/calignmentfile.pyx":654
 *             raise ValueError("I/O operation on closed file")
 *         reference = force_bytes(reference)
 *         return bam_name2id(self.header, reference)             # <<<<<<<<<<<<<<
 * 
 *     def get_reference_name(self, tid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_6 = __Pyx_PyObject_AsString(__pyx_v_reference); if (unlikely((!__pyx_t_6) && PyErr_Occurred())) __PYX_ERR(0, 654, __pyx_L1_error)
  __pyx_t_1 = __Pyx_PyInt_From_int(bam_name2id(__pyx_v_self->header, __pyx_t_6)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 654, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":644
 *                 self.start_offset = self.tell()
 * 
 *     def get_tid(self, reference):             # <<<<<<<<<<<<<<
 *         """
 *         return the numerical :term:`tid` corresponding to
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.get_tid", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_reference);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":656
 *         return bam_name2id(self.header, reference)
 * 
 *     def get_reference_name(self, tid):             # <<<<<<<<<<<<<<
 *         """
 *         return :term:`reference` name corresponding to numerical :term:`tid`
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_13get_reference_name(PyObject *__pyx_v_self, PyObject *__pyx_v_tid); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_12get_reference_name[] = "AlignmentFile.get_reference_name(self, tid)\n\n        return :term:`reference` name corresponding to numerical :term:`tid`\n        ";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_13get_reference_name(PyObject *__pyx_v_self, PyObject *__pyx_v_tid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("get_reference_name (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_12get_reference_name(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self), ((PyObject *)__pyx_v_tid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_12get_reference_name(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_tid) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  Py_ssize_t __pyx_t_6;
  __Pyx_RefNannySetupContext("get_reference_name", 0);
  __Pyx_TraceCall("get_reference_name", __pyx_f[0], 656, 0, __PYX_ERR(0, 656, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":660
 *         return :term:`reference` name corresponding to numerical :term:`tid`
 *         """
 *         if not self.is_open():             # <<<<<<<<<<<<<<
 *             raise ValueError("I/O operation on closed file")
 *         if not 0 <= tid < self.header.n_targets:
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_open); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 660, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 660, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 660, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 660, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = ((!__pyx_t_4) != 0);
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":661
 *         """
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")             # <<<<<<<<<<<<<<
 *         if not 0 <= tid < self.header.n_targets:
 *             raise ValueError("reference_id %i out of range 0<=tid<%i" %
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__17, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 661, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 661, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":660
 *         return :term:`reference` name corresponding to numerical :term:`tid`
 *         """
 *         if not self.is_open():             # <<<<<<<<<<<<<<
 *             raise ValueError("I/O operation on closed file")
 *         if not 0 <= tid < self.header.n_targets:
 */
  }

  /* "pysam/calignmentfile.pyx":662
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")
 *         if not 0 <= tid < self.header.n_targets:             # <<<<<<<<<<<<<<
 *             raise ValueError("reference_id %i out of range 0<=tid<%i" %
 *                              (tid, self.header.n_targets))
 */
  __pyx_t_1 = PyObject_RichCompare(__pyx_int_0, __pyx_v_tid, Py_LE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 662, __pyx_L1_error)
  if (__Pyx_PyObject_IsTrue(__pyx_t_1)) {
    __Pyx_DECREF(__pyx_t_1);
    __pyx_t_2 = __Pyx_PyInt_From_int32_t(__pyx_v_self->header->n_targets); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 662, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = PyObject_RichCompare(__pyx_v_tid, __pyx_t_2, Py_LT); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 662, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  }
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 662, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_4 = ((!__pyx_t_5) != 0);
  if (__pyx_t_4) {

    /* "pysam/calignmentfile.pyx":664
 *         if not 0 <= tid < self.header.n_targets:
 *             raise ValueError("reference_id %i out of range 0<=tid<%i" %
 *                              (tid, self.header.n_targets))             # <<<<<<<<<<<<<<
 *         return charptr_to_str(self.header.target_name[tid])
 * 
 */
    __pyx_t_1 = __Pyx_PyInt_From_int32_t(__pyx_v_self->header->n_targets); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 664, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 664, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_INCREF(__pyx_v_tid);
    __Pyx_GIVEREF(__pyx_v_tid);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_tid);
    __Pyx_GIVEREF(__pyx_t_1);
    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "pysam/calignmentfile.pyx":663
 *             raise ValueError("I/O operation on closed file")
 *         if not 0 <= tid < self.header.n_targets:
 *             raise ValueError("reference_id %i out of range 0<=tid<%i" %             # <<<<<<<<<<<<<<
 *                              (tid, self.header.n_targets))
 *         return charptr_to_str(self.header.target_name[tid])
 */
    __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_reference_id_i_out_of_range_0_ti, __pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 663, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 663, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_GIVEREF(__pyx_t_1);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_1);
    __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 663, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 663, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":662
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")
 *         if not 0 <= tid < self.header.n_targets:             # <<<<<<<<<<<<<<
 *             raise ValueError("reference_id %i out of range 0<=tid<%i" %
 *                              (tid, self.header.n_targets))
 */
  }

  /* "pysam/calignmentfile.pyx":665
 *             raise ValueError("reference_id %i out of range 0<=tid<%i" %
 *                              (tid, self.header.n_targets))
 *         return charptr_to_str(self.header.target_name[tid])             # <<<<<<<<<<<<<<
 * 
 *     def reset(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_6 = __Pyx_PyIndex_AsSsize_t(__pyx_v_tid); if (unlikely((__pyx_t_6 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 665, __pyx_L1_error)
  __pyx_t_1 = __pyx_f_5pysam_6cutils_charptr_to_str((__pyx_v_self->header->target_name[__pyx_t_6]), NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 665, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":656
 *         return bam_name2id(self.header, reference)
 * 
 *     def get_reference_name(self, tid):             # <<<<<<<<<<<<<<
 *         """
 *         return :term:`reference` name corresponding to numerical :term:`tid`
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.get_reference_name", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":667
 *         return charptr_to_str(self.header.target_name[tid])
 * 
 *     def reset(self):             # <<<<<<<<<<<<<<
 *         """reset file position to beginning of file just after
 *         the header.
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_15reset(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_14reset[] = "AlignmentFile.reset(self)\nreset file position to beginning of file just after\n        the header.\n\n        Returns\n        -------\n\n        The file position after moving the file pointer.\n\n        ";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_15reset(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("reset (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_14reset(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_14reset(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  Py_ssize_t __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  __Pyx_RefNannySetupContext("reset", 0);
  __Pyx_TraceCall("reset", __pyx_f[0], 667, 0, __PYX_ERR(0, 667, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":677
 * 
 *         """
 *         return self.seek(self.start_offset, 0)             # <<<<<<<<<<<<<<
 * 
 *     def seek(self, uint64_t offset, int where=0):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_seek); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 677, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyInt_From_int64_t(__pyx_v_self->start_offset); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 677, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = NULL;
  __pyx_t_5 = 0;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_4)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_4);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
      __pyx_t_5 = 1;
    }
  }
  __pyx_t_6 = PyTuple_New(2+__pyx_t_5); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 677, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  if (__pyx_t_4) {
    __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4); __pyx_t_4 = NULL;
  }
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_6, 0+__pyx_t_5, __pyx_t_3);
  __Pyx_INCREF(__pyx_int_0);
  __Pyx_GIVEREF(__pyx_int_0);
  PyTuple_SET_ITEM(__pyx_t_6, 1+__pyx_t_5, __pyx_int_0);
  __pyx_t_3 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_6, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 677, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":667
 *         return charptr_to_str(self.header.target_name[tid])
 * 
 *     def reset(self):             # <<<<<<<<<<<<<<
 *         """reset file position to beginning of file just after
 *         the header.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.reset", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":679
 *         return self.seek(self.start_offset, 0)
 * 
 *     def seek(self, uint64_t offset, int where=0):             # <<<<<<<<<<<<<<
 *         """move file pointer to position `offset`, see
 *         :meth:`pysam.AlignmentFile.tell`.
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_17seek(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_16seek[] = "AlignmentFile.seek(self, uint64_t offset, int where=0)\nmove file pointer to position `offset`, see\n        :meth:`pysam.AlignmentFile.tell`.\n\n        Parameters\n        ----------\n        \n        offset : int\n\n        position of the read/write pointer within the file.\n\n        where : int\n    \n        optional and defaults to 0 which means absolute file\n        positioning, other values are 1 which means seek relative to\n        the current position and 2 means seek relative to the file's\n        end.\n        \n        Returns\n        -------\n        \n        the file position after moving the file pointer\n\n        ";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_17seek(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  uint64_t __pyx_v_offset;
  int __pyx_v_where;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("seek (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_offset,&__pyx_n_s_where,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_offset)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_where);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "seek") < 0)) __PYX_ERR(0, 679, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_offset = __Pyx_PyInt_As_uint64_t(values[0]); if (unlikely((__pyx_v_offset == (uint64_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 679, __pyx_L3_error)
    if (values[1]) {
      __pyx_v_where = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_where == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 679, __pyx_L3_error)
    } else {
      __pyx_v_where = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("seek", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 679, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.seek", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_16seek(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self), __pyx_v_offset, __pyx_v_where);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_16seek(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, uint64_t __pyx_v_offset, int __pyx_v_where) {
  uint64_t __pyx_v_pos;
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("seek", 0);
  __Pyx_TraceCall("seek", __pyx_f[0], 679, 0, __PYX_ERR(0, 679, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":704
 *         """
 * 
 *         if not self.is_open():             # <<<<<<<<<<<<<<
 *             raise ValueError("I/O operation on closed file")
 *         if not self.is_bam:
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_open); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 704, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 704, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 704, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 704, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = ((!__pyx_t_4) != 0);
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":705
 * 
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")             # <<<<<<<<<<<<<<
 *         if not self.is_bam:
 *             raise NotImplementedError(
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__18, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 705, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 705, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":704
 *         """
 * 
 *         if not self.is_open():             # <<<<<<<<<<<<<<
 *             raise ValueError("I/O operation on closed file")
 *         if not self.is_bam:
 */
  }

  /* "pysam/calignmentfile.pyx":706
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")
 *         if not self.is_bam:             # <<<<<<<<<<<<<<
 *             raise NotImplementedError(
 *                 "seek only available in bam files")
 */
  __pyx_t_5 = ((!(__pyx_v_self->is_bam != 0)) != 0);
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":707
 *             raise ValueError("I/O operation on closed file")
 *         if not self.is_bam:
 *             raise NotImplementedError(             # <<<<<<<<<<<<<<
 *                 "seek only available in bam files")
 *         if self.is_stream:
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__19, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 707, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 707, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":706
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")
 *         if not self.is_bam:             # <<<<<<<<<<<<<<
 *             raise NotImplementedError(
 *                 "seek only available in bam files")
 */
  }

  /* "pysam/calignmentfile.pyx":709
 *             raise NotImplementedError(
 *                 "seek only available in bam files")
 *         if self.is_stream:             # <<<<<<<<<<<<<<
 *             raise OSError("seek no available in streams")
 * 
 */
  __pyx_t_5 = (__pyx_v_self->is_stream != 0);
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":710
 *                 "seek only available in bam files")
 *         if self.is_stream:
 *             raise OSError("seek no available in streams")             # <<<<<<<<<<<<<<
 * 
 *         cdef uint64_t pos
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_OSError, __pyx_tuple__20, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 710, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 710, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":709
 *             raise NotImplementedError(
 *                 "seek only available in bam files")
 *         if self.is_stream:             # <<<<<<<<<<<<<<
 *             raise OSError("seek no available in streams")
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":713
 * 
 *         cdef uint64_t pos
 *         with nogil:             # <<<<<<<<<<<<<<
 *             pos = bgzf_seek(hts_get_bgzfp(self.htsfile), offset, where)
 *         return pos
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "pysam/calignmentfile.pyx":714
 *         cdef uint64_t pos
 *         with nogil:
 *             pos = bgzf_seek(hts_get_bgzfp(self.htsfile), offset, where)             # <<<<<<<<<<<<<<
 *         return pos
 * 
 */
        __pyx_v_pos = bgzf_seek(hts_get_bgzfp(__pyx_v_self->htsfile), __pyx_v_offset, __pyx_v_where);
      }

      /* "pysam/calignmentfile.pyx":713
 * 
 *         cdef uint64_t pos
 *         with nogil:             # <<<<<<<<<<<<<<
 *             pos = bgzf_seek(hts_get_bgzfp(self.htsfile), offset, where)
 *         return pos
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L8;
        }
        __pyx_L8:;
      }
  }

  /* "pysam/calignmentfile.pyx":715
 *         with nogil:
 *             pos = bgzf_seek(hts_get_bgzfp(self.htsfile), offset, where)
 *         return pos             # <<<<<<<<<<<<<<
 * 
 *     def tell(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(__pyx_v_pos); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 715, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":679
 *         return self.seek(self.start_offset, 0)
 * 
 *     def seek(self, uint64_t offset, int where=0):             # <<<<<<<<<<<<<<
 *         """move file pointer to position `offset`, see
 *         :meth:`pysam.AlignmentFile.tell`.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.seek", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":717
 *         return pos
 * 
 *     def tell(self):             # <<<<<<<<<<<<<<
 *         """
 *         return current file position.
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_19tell(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_18tell[] = "AlignmentFile.tell(self)\n\n        return current file position.\n        ";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_19tell(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("tell (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_18tell(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_18tell(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  uint64_t __pyx_v_pos;
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("tell", 0);
  __Pyx_TraceCall("tell", __pyx_f[0], 717, 0, __PYX_ERR(0, 717, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":721
 *         return current file position.
 *         """
 *         if not self.is_open():             # <<<<<<<<<<<<<<
 *             raise ValueError("I/O operation on closed file")
 *         if not (self.is_bam or self.is_cram):
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_open); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 721, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 721, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 721, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 721, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = ((!__pyx_t_4) != 0);
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":722
 *         """
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")             # <<<<<<<<<<<<<<
 *         if not (self.is_bam or self.is_cram):
 *             raise NotImplementedError(
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__21, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 722, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 722, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":721
 *         return current file position.
 *         """
 *         if not self.is_open():             # <<<<<<<<<<<<<<
 *             raise ValueError("I/O operation on closed file")
 *         if not (self.is_bam or self.is_cram):
 */
  }

  /* "pysam/calignmentfile.pyx":723
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")
 *         if not (self.is_bam or self.is_cram):             # <<<<<<<<<<<<<<
 *             raise NotImplementedError(
 *                 "seek only available in bam files")
 */
  __pyx_t_4 = (__pyx_v_self->is_bam != 0);
  if (!__pyx_t_4) {
  } else {
    __pyx_t_5 = __pyx_t_4;
    goto __pyx_L5_bool_binop_done;
  }
  __pyx_t_4 = (__pyx_v_self->is_cram != 0);
  __pyx_t_5 = __pyx_t_4;
  __pyx_L5_bool_binop_done:;
  __pyx_t_4 = ((!__pyx_t_5) != 0);
  if (__pyx_t_4) {

    /* "pysam/calignmentfile.pyx":724
 *             raise ValueError("I/O operation on closed file")
 *         if not (self.is_bam or self.is_cram):
 *             raise NotImplementedError(             # <<<<<<<<<<<<<<
 *                 "seek only available in bam files")
 * 
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__22, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 724, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 724, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":723
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")
 *         if not (self.is_bam or self.is_cram):             # <<<<<<<<<<<<<<
 *             raise NotImplementedError(
 *                 "seek only available in bam files")
 */
  }

  /* "pysam/calignmentfile.pyx":728
 * 
 *         cdef uint64_t pos
 *         with nogil:             # <<<<<<<<<<<<<<
 *             pos = bgzf_tell(hts_get_bgzfp(self.htsfile))
 *         return pos
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "pysam/calignmentfile.pyx":729
 *         cdef uint64_t pos
 *         with nogil:
 *             pos = bgzf_tell(hts_get_bgzfp(self.htsfile))             # <<<<<<<<<<<<<<
 *         return pos
 * 
 */
        __pyx_v_pos = bgzf_tell(hts_get_bgzfp(__pyx_v_self->htsfile));
      }

      /* "pysam/calignmentfile.pyx":728
 * 
 *         cdef uint64_t pos
 *         with nogil:             # <<<<<<<<<<<<<<
 *             pos = bgzf_tell(hts_get_bgzfp(self.htsfile))
 *         return pos
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L9;
        }
        __pyx_L9:;
      }
  }

  /* "pysam/calignmentfile.pyx":730
 *         with nogil:
 *             pos = bgzf_tell(hts_get_bgzfp(self.htsfile))
 *         return pos             # <<<<<<<<<<<<<<
 * 
 *     def parse_region(self,
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(__pyx_v_pos); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 730, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":717
 *         return pos
 * 
 *     def tell(self):             # <<<<<<<<<<<<<<
 *         """
 *         return current file position.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.tell", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":732
 *         return pos
 * 
 *     def parse_region(self,             # <<<<<<<<<<<<<<
 *                      reference=None,
 *                      start=None,
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_21parse_region(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_20parse_region[] = "AlignmentFile.parse_region(self, reference=None, start=None, end=None, region=None, tid=None)\nparse alternative ways to specify a genomic region. A region can\n        either be specified by :term:`reference`, `start` and\n        `end`. `start` and `end` denote 0-based, half-open\n        intervals.\n\n        Alternatively, a samtools :term:`region` string can be\n        supplied.\n        \n        If any of the coordinates are missing they will be replaced by the\n        minimum (`start`) or maximum (`end`) coordinate.\n\n        Note that region strings are 1-based, while `start` and `end` denote\n        an interval in python coordinates.\n\n        Returns\n        -------\n        \n        tuple :  a tuple of `flag`, :term:`tid`, `start` and `end`. The\n        flag indicates whether no coordinates were supplied and the\n        genomic region is the complete genomic space.\n\n        Raises\n        ------\n        \n        ValueError\n           for invalid or out of bounds regions.\n\n        ";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_21parse_region(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_reference = 0;
  PyObject *__pyx_v_start = 0;
  PyObject *__pyx_v_end = 0;
  PyObject *__pyx_v_region = 0;
  PyObject *__pyx_v_tid = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("parse_region (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_reference,&__pyx_n_s_start,&__pyx_n_s_end,&__pyx_n_s_region,&__pyx_n_s_tid,0};
    PyObject* values[5] = {0,0,0,0,0};

    /* "pysam/calignmentfile.pyx":733
 * 
 *     def parse_region(self,
 *                      reference=None,             # <<<<<<<<<<<<<<
 *                      start=None,
 *                      end=None,
 */
    values[0] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":734
 *     def parse_region(self,
 *                      reference=None,
 *                      start=None,             # <<<<<<<<<<<<<<
 *                      end=None,
 *                      region=None,
 */
    values[1] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":735
 *                      reference=None,
 *                      start=None,
 *                      end=None,             # <<<<<<<<<<<<<<
 *                      region=None,
 *                      tid=None):
 */
    values[2] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":736
 *                      start=None,
 *                      end=None,
 *                      region=None,             # <<<<<<<<<<<<<<
 *                      tid=None):
 *         """parse alternative ways to specify a genomic region. A region can
 */
    values[3] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":737
 *                      end=None,
 *                      region=None,
 *                      tid=None):             # <<<<<<<<<<<<<<
 *         """parse alternative ways to specify a genomic region. A region can
 *         either be specified by :term:`reference`, `start` and
 */
    values[4] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_reference);
          if (value) { values[0] = value; kw_args--; }
        }
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_start);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_end);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_region);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_tid);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "parse_region") < 0)) __PYX_ERR(0, 732, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_reference = values[0];
    __pyx_v_start = values[1];
    __pyx_v_end = values[2];
    __pyx_v_region = values[3];
    __pyx_v_tid = values[4];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("parse_region", 0, 0, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 732, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.parse_region", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_20parse_region(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self), __pyx_v_reference, __pyx_v_start, __pyx_v_end, __pyx_v_region, __pyx_v_tid);

  /* "pysam/calignmentfile.pyx":732
 *         return pos
 * 
 *     def parse_region(self,             # <<<<<<<<<<<<<<
 *                      reference=None,
 *                      start=None,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_20parse_region(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_reference, PyObject *__pyx_v_start, PyObject *__pyx_v_end, PyObject *__pyx_v_region, PyObject *__pyx_v_tid) {
  int __pyx_v_rtid;
  PY_LONG_LONG __pyx_v_rstart;
  PY_LONG_LONG __pyx_v_rend;
  PyObject *__pyx_v_parts = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PY_LONG_LONG __pyx_t_6;
  int __pyx_t_7;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *__pyx_t_10 = NULL;
  PyObject *__pyx_t_11 = NULL;
  Py_ssize_t __pyx_t_12;
  int __pyx_t_13;
  __Pyx_RefNannySetupContext("parse_region", 0);
  __Pyx_TraceCall("parse_region", __pyx_f[0], 732, 0, __PYX_ERR(0, 732, __pyx_L1_error));
  __Pyx_INCREF(__pyx_v_reference);
  __Pyx_INCREF(__pyx_v_region);

  /* "pysam/calignmentfile.pyx":770
 *         cdef long long rend
 * 
 *         rtid = -1             # <<<<<<<<<<<<<<
 *         rstart = 0
 *         rend = MAX_POS
 */
  __pyx_v_rtid = -1;

  /* "pysam/calignmentfile.pyx":771
 * 
 *         rtid = -1
 *         rstart = 0             # <<<<<<<<<<<<<<
 *         rend = MAX_POS
 *         if start != None:
 */
  __pyx_v_rstart = 0;

  /* "pysam/calignmentfile.pyx":772
 *         rtid = -1
 *         rstart = 0
 *         rend = MAX_POS             # <<<<<<<<<<<<<<
 *         if start != None:
 *             try:
 */
  __pyx_v_rend = __pyx_v_5pysam_14calignmentfile_MAX_POS;

  /* "pysam/calignmentfile.pyx":773
 *         rstart = 0
 *         rend = MAX_POS
 *         if start != None:             # <<<<<<<<<<<<<<
 *             try:
 *                 rstart = start
 */
  __pyx_t_1 = PyObject_RichCompare(__pyx_v_start, Py_None, Py_NE); __Pyx_XGOTREF(__pyx_t_1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 773, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 773, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  if (__pyx_t_2) {

    /* "pysam/calignmentfile.pyx":774
 *         rend = MAX_POS
 *         if start != None:
 *             try:             # <<<<<<<<<<<<<<
 *                 rstart = start
 *             except OverflowError:
 */
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_3, &__pyx_t_4, &__pyx_t_5);
      __Pyx_XGOTREF(__pyx_t_3);
      __Pyx_XGOTREF(__pyx_t_4);
      __Pyx_XGOTREF(__pyx_t_5);
      /*try:*/ {

        /* "pysam/calignmentfile.pyx":775
 *         if start != None:
 *             try:
 *                 rstart = start             # <<<<<<<<<<<<<<
 *             except OverflowError:
 *                 raise ValueError('start out of range (%i)' % start)
 */
        __pyx_t_6 = __Pyx_PyInt_As_PY_LONG_LONG(__pyx_v_start); if (unlikely((__pyx_t_6 == (PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 775, __pyx_L4_error)
        __pyx_v_rstart = __pyx_t_6;

        /* "pysam/calignmentfile.pyx":774
 *         rend = MAX_POS
 *         if start != None:
 *             try:             # <<<<<<<<<<<<<<
 *                 rstart = start
 *             except OverflowError:
 */
      }
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      goto __pyx_L11_try_end;
      __pyx_L4_error:;
      __Pyx_PyThreadState_assign
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;

      /* "pysam/calignmentfile.pyx":776
 *             try:
 *                 rstart = start
 *             except OverflowError:             # <<<<<<<<<<<<<<
 *                 raise ValueError('start out of range (%i)' % start)
 * 
 */
      __pyx_t_7 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_OverflowError);
      if (__pyx_t_7) {
        __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.parse_region", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_1, &__pyx_t_8, &__pyx_t_9) < 0) __PYX_ERR(0, 776, __pyx_L6_except_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_GOTREF(__pyx_t_8);
        __Pyx_GOTREF(__pyx_t_9);

        /* "pysam/calignmentfile.pyx":777
 *                 rstart = start
 *             except OverflowError:
 *                 raise ValueError('start out of range (%i)' % start)             # <<<<<<<<<<<<<<
 * 
 *         if end != None:
 */
        __pyx_t_10 = __Pyx_PyString_Format(__pyx_kp_s_start_out_of_range_i, __pyx_v_start); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 777, __pyx_L6_except_error)
        __Pyx_GOTREF(__pyx_t_10);
        __pyx_t_11 = PyTuple_New(1); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 777, __pyx_L6_except_error)
        __Pyx_GOTREF(__pyx_t_11);
        __Pyx_GIVEREF(__pyx_t_10);
        PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_10);
        __pyx_t_10 = 0;
        __pyx_t_10 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_11, NULL); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 777, __pyx_L6_except_error)
        __Pyx_GOTREF(__pyx_t_10);
        __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
        __Pyx_Raise(__pyx_t_10, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
        __PYX_ERR(0, 777, __pyx_L6_except_error)
      }
      goto __pyx_L6_except_error;
      __pyx_L6_except_error:;

      /* "pysam/calignmentfile.pyx":774
 *         rend = MAX_POS
 *         if start != None:
 *             try:             # <<<<<<<<<<<<<<
 *                 rstart = start
 *             except OverflowError:
 */
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_3);
      __Pyx_XGIVEREF(__pyx_t_4);
      __Pyx_XGIVEREF(__pyx_t_5);
      __Pyx_ExceptionReset(__pyx_t_3, __pyx_t_4, __pyx_t_5);
      goto __pyx_L1_error;
      __pyx_L11_try_end:;
    }

    /* "pysam/calignmentfile.pyx":773
 *         rstart = 0
 *         rend = MAX_POS
 *         if start != None:             # <<<<<<<<<<<<<<
 *             try:
 *                 rstart = start
 */
  }

  /* "pysam/calignmentfile.pyx":779
 *                 raise ValueError('start out of range (%i)' % start)
 * 
 *         if end != None:             # <<<<<<<<<<<<<<
 *             try:
 *                 rend = end
 */
  __pyx_t_9 = PyObject_RichCompare(__pyx_v_end, Py_None, Py_NE); __Pyx_XGOTREF(__pyx_t_9); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 779, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_9); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 779, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
  if (__pyx_t_2) {

    /* "pysam/calignmentfile.pyx":780
 * 
 *         if end != None:
 *             try:             # <<<<<<<<<<<<<<
 *                 rend = end
 *             except OverflowError:
 */
    {
      __Pyx_PyThreadState_declare
      __Pyx_PyThreadState_assign
      __Pyx_ExceptionSave(&__pyx_t_5, &__pyx_t_4, &__pyx_t_3);
      __Pyx_XGOTREF(__pyx_t_5);
      __Pyx_XGOTREF(__pyx_t_4);
      __Pyx_XGOTREF(__pyx_t_3);
      /*try:*/ {

        /* "pysam/calignmentfile.pyx":781
 *         if end != None:
 *             try:
 *                 rend = end             # <<<<<<<<<<<<<<
 *             except OverflowError:
 *                 raise ValueError('end out of range (%i)' % end)
 */
        __pyx_t_6 = __Pyx_PyInt_As_PY_LONG_LONG(__pyx_v_end); if (unlikely((__pyx_t_6 == (PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 781, __pyx_L15_error)
        __pyx_v_rend = __pyx_t_6;

        /* "pysam/calignmentfile.pyx":780
 * 
 *         if end != None:
 *             try:             # <<<<<<<<<<<<<<
 *                 rend = end
 *             except OverflowError:
 */
      }
      __Pyx_XDECREF(__pyx_t_5); __pyx_t_5 = 0;
      __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      goto __pyx_L22_try_end;
      __pyx_L15_error:;
      __Pyx_PyThreadState_assign
      __Pyx_XDECREF(__pyx_t_11); __pyx_t_11 = 0;
      __Pyx_XDECREF(__pyx_t_10); __pyx_t_10 = 0;
      __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_XDECREF(__pyx_t_8); __pyx_t_8 = 0;
      __Pyx_XDECREF(__pyx_t_9); __pyx_t_9 = 0;

      /* "pysam/calignmentfile.pyx":782
 *             try:
 *                 rend = end
 *             except OverflowError:             # <<<<<<<<<<<<<<
 *                 raise ValueError('end out of range (%i)' % end)
 * 
 */
      __pyx_t_7 = __Pyx_PyErr_ExceptionMatches(__pyx_builtin_OverflowError);
      if (__pyx_t_7) {
        __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.parse_region", __pyx_clineno, __pyx_lineno, __pyx_filename);
        if (__Pyx_GetException(&__pyx_t_9, &__pyx_t_8, &__pyx_t_1) < 0) __PYX_ERR(0, 782, __pyx_L17_except_error)
        __Pyx_GOTREF(__pyx_t_9);
        __Pyx_GOTREF(__pyx_t_8);
        __Pyx_GOTREF(__pyx_t_1);

        /* "pysam/calignmentfile.pyx":783
 *                 rend = end
 *             except OverflowError:
 *                 raise ValueError('end out of range (%i)' % end)             # <<<<<<<<<<<<<<
 * 
 *         if region:
 */
        __pyx_t_10 = __Pyx_PyString_Format(__pyx_kp_s_end_out_of_range_i, __pyx_v_end); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 783, __pyx_L17_except_error)
        __Pyx_GOTREF(__pyx_t_10);
        __pyx_t_11 = PyTuple_New(1); if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 783, __pyx_L17_except_error)
        __Pyx_GOTREF(__pyx_t_11);
        __Pyx_GIVEREF(__pyx_t_10);
        PyTuple_SET_ITEM(__pyx_t_11, 0, __pyx_t_10);
        __pyx_t_10 = 0;
        __pyx_t_10 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_11, NULL); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 783, __pyx_L17_except_error)
        __Pyx_GOTREF(__pyx_t_10);
        __Pyx_DECREF(__pyx_t_11); __pyx_t_11 = 0;
        __Pyx_Raise(__pyx_t_10, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
        __PYX_ERR(0, 783, __pyx_L17_except_error)
      }
      goto __pyx_L17_except_error;
      __pyx_L17_except_error:;

      /* "pysam/calignmentfile.pyx":780
 * 
 *         if end != None:
 *             try:             # <<<<<<<<<<<<<<
 *                 rend = end
 *             except OverflowError:
 */
      __Pyx_PyThreadState_assign
      __Pyx_XGIVEREF(__pyx_t_5);
      __Pyx_XGIVEREF(__pyx_t_4);
      __Pyx_XGIVEREF(__pyx_t_3);
      __Pyx_ExceptionReset(__pyx_t_5, __pyx_t_4, __pyx_t_3);
      goto __pyx_L1_error;
      __pyx_L22_try_end:;
    }

    /* "pysam/calignmentfile.pyx":779
 *                 raise ValueError('start out of range (%i)' % start)
 * 
 *         if end != None:             # <<<<<<<<<<<<<<
 *             try:
 *                 rend = end
 */
  }

  /* "pysam/calignmentfile.pyx":785
 *                 raise ValueError('end out of range (%i)' % end)
 * 
 *         if region:             # <<<<<<<<<<<<<<
 *             region = force_str(region)
 *             parts = re.split("[:-]", region)
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_region); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 785, __pyx_L1_error)
  if (__pyx_t_2) {

    /* "pysam/calignmentfile.pyx":786
 * 
 *         if region:
 *             region = force_str(region)             # <<<<<<<<<<<<<<
 *             parts = re.split("[:-]", region)
 *             reference = parts[0]
 */
    __pyx_t_1 = __pyx_f_5pysam_6cutils_force_str(__pyx_v_region, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 786, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF_SET(__pyx_v_region, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "pysam/calignmentfile.pyx":787
 *         if region:
 *             region = force_str(region)
 *             parts = re.split("[:-]", region)             # <<<<<<<<<<<<<<
 *             reference = parts[0]
 *             if len(parts) >= 2:
 */
    __pyx_t_8 = __Pyx_GetModuleGlobalName(__pyx_n_s_re); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 787, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_9 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_split); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 787, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_8 = NULL;
    __pyx_t_12 = 0;
    if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_9))) {
      __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_9);
      if (likely(__pyx_t_8)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_9);
        __Pyx_INCREF(__pyx_t_8);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_9, function);
        __pyx_t_12 = 1;
      }
    }
    __pyx_t_10 = PyTuple_New(2+__pyx_t_12); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 787, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_10);
    if (__pyx_t_8) {
      __Pyx_GIVEREF(__pyx_t_8); PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_t_8); __pyx_t_8 = NULL;
    }
    __Pyx_INCREF(__pyx_kp_s__23);
    __Pyx_GIVEREF(__pyx_kp_s__23);
    PyTuple_SET_ITEM(__pyx_t_10, 0+__pyx_t_12, __pyx_kp_s__23);
    __Pyx_INCREF(__pyx_v_region);
    __Pyx_GIVEREF(__pyx_v_region);
    PyTuple_SET_ITEM(__pyx_t_10, 1+__pyx_t_12, __pyx_v_region);
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_9, __pyx_t_10, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 787, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_10); __pyx_t_10 = 0;
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __pyx_v_parts = __pyx_t_1;
    __pyx_t_1 = 0;

    /* "pysam/calignmentfile.pyx":788
 *             region = force_str(region)
 *             parts = re.split("[:-]", region)
 *             reference = parts[0]             # <<<<<<<<<<<<<<
 *             if len(parts) >= 2:
 *                 rstart = int(parts[1]) - 1
 */
    __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_parts, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 788, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF_SET(__pyx_v_reference, __pyx_t_1);
    __pyx_t_1 = 0;

    /* "pysam/calignmentfile.pyx":789
 *             parts = re.split("[:-]", region)
 *             reference = parts[0]
 *             if len(parts) >= 2:             # <<<<<<<<<<<<<<
 *                 rstart = int(parts[1]) - 1
 *             if len(parts) >= 3:
 */
    __pyx_t_12 = PyObject_Length(__pyx_v_parts); if (unlikely(__pyx_t_12 == -1)) __PYX_ERR(0, 789, __pyx_L1_error)
    __pyx_t_2 = ((__pyx_t_12 >= 2) != 0);
    if (__pyx_t_2) {

      /* "pysam/calignmentfile.pyx":790
 *             reference = parts[0]
 *             if len(parts) >= 2:
 *                 rstart = int(parts[1]) - 1             # <<<<<<<<<<<<<<
 *             if len(parts) >= 3:
 *                 rend = int(parts[2])
 */
      __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_parts, 1, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 790, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_9 = __Pyx_PyNumber_Int(__pyx_t_1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 790, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_1 = __Pyx_PyInt_SubtractObjC(__pyx_t_9, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 790, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      __pyx_t_6 = __Pyx_PyInt_As_PY_LONG_LONG(__pyx_t_1); if (unlikely((__pyx_t_6 == (PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 790, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_v_rstart = __pyx_t_6;

      /* "pysam/calignmentfile.pyx":789
 *             parts = re.split("[:-]", region)
 *             reference = parts[0]
 *             if len(parts) >= 2:             # <<<<<<<<<<<<<<
 *                 rstart = int(parts[1]) - 1
 *             if len(parts) >= 3:
 */
    }

    /* "pysam/calignmentfile.pyx":791
 *             if len(parts) >= 2:
 *                 rstart = int(parts[1]) - 1
 *             if len(parts) >= 3:             # <<<<<<<<<<<<<<
 *                 rend = int(parts[2])
 * 
 */
    __pyx_t_12 = PyObject_Length(__pyx_v_parts); if (unlikely(__pyx_t_12 == -1)) __PYX_ERR(0, 791, __pyx_L1_error)
    __pyx_t_2 = ((__pyx_t_12 >= 3) != 0);
    if (__pyx_t_2) {

      /* "pysam/calignmentfile.pyx":792
 *                 rstart = int(parts[1]) - 1
 *             if len(parts) >= 3:
 *                 rend = int(parts[2])             # <<<<<<<<<<<<<<
 * 
 *         if not reference:
 */
      __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_parts, 2, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 792, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_9 = __Pyx_PyNumber_Int(__pyx_t_1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 792, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_6 = __Pyx_PyInt_As_PY_LONG_LONG(__pyx_t_9); if (unlikely((__pyx_t_6 == (PY_LONG_LONG)-1) && PyErr_Occurred())) __PYX_ERR(0, 792, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      __pyx_v_rend = __pyx_t_6;

      /* "pysam/calignmentfile.pyx":791
 *             if len(parts) >= 2:
 *                 rstart = int(parts[1]) - 1
 *             if len(parts) >= 3:             # <<<<<<<<<<<<<<
 *                 rend = int(parts[2])
 * 
 */
    }

    /* "pysam/calignmentfile.pyx":785
 *                 raise ValueError('end out of range (%i)' % end)
 * 
 *         if region:             # <<<<<<<<<<<<<<
 *             region = force_str(region)
 *             parts = re.split("[:-]", region)
 */
  }

  /* "pysam/calignmentfile.pyx":794
 *                 rend = int(parts[2])
 * 
 *         if not reference:             # <<<<<<<<<<<<<<
 *             return 0, 0, 0, 0
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_v_reference); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 794, __pyx_L1_error)
  __pyx_t_13 = ((!__pyx_t_2) != 0);
  if (__pyx_t_13) {

    /* "pysam/calignmentfile.pyx":795
 * 
 *         if not reference:
 *             return 0, 0, 0, 0             # <<<<<<<<<<<<<<
 * 
 *         if tid is not None:
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_tuple__24);
    __pyx_r = __pyx_tuple__24;
    goto __pyx_L0;

    /* "pysam/calignmentfile.pyx":794
 *                 rend = int(parts[2])
 * 
 *         if not reference:             # <<<<<<<<<<<<<<
 *             return 0, 0, 0, 0
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":797
 *             return 0, 0, 0, 0
 * 
 *         if tid is not None:             # <<<<<<<<<<<<<<
 *             rtid = tid
 *         else:
 */
  __pyx_t_13 = (__pyx_v_tid != Py_None);
  __pyx_t_2 = (__pyx_t_13 != 0);
  if (__pyx_t_2) {

    /* "pysam/calignmentfile.pyx":798
 * 
 *         if tid is not None:
 *             rtid = tid             # <<<<<<<<<<<<<<
 *         else:
 *             rtid = self.gettid(reference)
 */
    __pyx_t_7 = __Pyx_PyInt_As_int(__pyx_v_tid); if (unlikely((__pyx_t_7 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 798, __pyx_L1_error)
    __pyx_v_rtid = __pyx_t_7;

    /* "pysam/calignmentfile.pyx":797
 *             return 0, 0, 0, 0
 * 
 *         if tid is not None:             # <<<<<<<<<<<<<<
 *             rtid = tid
 *         else:
 */
    goto __pyx_L29;
  }

  /* "pysam/calignmentfile.pyx":800
 *             rtid = tid
 *         else:
 *             rtid = self.gettid(reference)             # <<<<<<<<<<<<<<
 * 
 *         if rtid < 0:
 */
  /*else*/ {
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_gettid); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 800, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_10 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_1))) {
      __pyx_t_10 = PyMethod_GET_SELF(__pyx_t_1);
      if (likely(__pyx_t_10)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_1);
        __Pyx_INCREF(__pyx_t_10);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_1, function);
      }
    }
    if (!__pyx_t_10) {
      __pyx_t_9 = __Pyx_PyObject_CallOneArg(__pyx_t_1, __pyx_v_reference); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 800, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
    } else {
      __pyx_t_8 = PyTuple_New(1+1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 800, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_GIVEREF(__pyx_t_10); PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_10); __pyx_t_10 = NULL;
      __Pyx_INCREF(__pyx_v_reference);
      __Pyx_GIVEREF(__pyx_v_reference);
      PyTuple_SET_ITEM(__pyx_t_8, 0+1, __pyx_v_reference);
      __pyx_t_9 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_8, NULL); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 800, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_9);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_7 = __Pyx_PyInt_As_int(__pyx_t_9); if (unlikely((__pyx_t_7 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 800, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __pyx_v_rtid = __pyx_t_7;
  }
  __pyx_L29:;

  /* "pysam/calignmentfile.pyx":802
 *             rtid = self.gettid(reference)
 * 
 *         if rtid < 0:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 "invalid reference `%s`" % reference)
 */
  __pyx_t_2 = ((__pyx_v_rtid < 0) != 0);
  if (__pyx_t_2) {

    /* "pysam/calignmentfile.pyx":804
 *         if rtid < 0:
 *             raise ValueError(
 *                 "invalid reference `%s`" % reference)             # <<<<<<<<<<<<<<
 *         if rstart > rend:
 *             raise ValueError(
 */
    __pyx_t_9 = __Pyx_PyString_Format(__pyx_kp_s_invalid_reference_s, __pyx_v_reference); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 804, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);

    /* "pysam/calignmentfile.pyx":803
 * 
 *         if rtid < 0:
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 "invalid reference `%s`" % reference)
 *         if rstart > rend:
 */
    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 803, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_GIVEREF(__pyx_t_9);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_9);
    __pyx_t_9 = 0;
    __pyx_t_9 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_1, NULL); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 803, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_Raise(__pyx_t_9, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __PYX_ERR(0, 803, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":802
 *             rtid = self.gettid(reference)
 * 
 *         if rtid < 0:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 "invalid reference `%s`" % reference)
 */
  }

  /* "pysam/calignmentfile.pyx":805
 *             raise ValueError(
 *                 "invalid reference `%s`" % reference)
 *         if rstart > rend:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 'invalid coordinates: start (%i) > end (%i)' % (rstart, rend))
 */
  __pyx_t_2 = ((__pyx_v_rstart > __pyx_v_rend) != 0);
  if (__pyx_t_2) {

    /* "pysam/calignmentfile.pyx":807
 *         if rstart > rend:
 *             raise ValueError(
 *                 'invalid coordinates: start (%i) > end (%i)' % (rstart, rend))             # <<<<<<<<<<<<<<
 *         if not 0 <= rstart < MAX_POS:
 *             raise ValueError('start out of range (%i)' % rstart)
 */
    __pyx_t_9 = __Pyx_PyInt_From_PY_LONG_LONG(__pyx_v_rstart); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 807, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __pyx_t_1 = __Pyx_PyInt_From_PY_LONG_LONG(__pyx_v_rend); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 807, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_8 = PyTuple_New(2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 807, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_GIVEREF(__pyx_t_9);
    PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_9);
    __Pyx_GIVEREF(__pyx_t_1);
    PyTuple_SET_ITEM(__pyx_t_8, 1, __pyx_t_1);
    __pyx_t_9 = 0;
    __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_invalid_coordinates_start_i_end, __pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 807, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;

    /* "pysam/calignmentfile.pyx":806
 *                 "invalid reference `%s`" % reference)
 *         if rstart > rend:
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 'invalid coordinates: start (%i) > end (%i)' % (rstart, rend))
 *         if not 0 <= rstart < MAX_POS:
 */
    __pyx_t_8 = PyTuple_New(1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 806, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_GIVEREF(__pyx_t_1);
    PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_1);
    __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 806, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 806, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":805
 *             raise ValueError(
 *                 "invalid reference `%s`" % reference)
 *         if rstart > rend:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 'invalid coordinates: start (%i) > end (%i)' % (rstart, rend))
 */
  }

  /* "pysam/calignmentfile.pyx":808
 *             raise ValueError(
 *                 'invalid coordinates: start (%i) > end (%i)' % (rstart, rend))
 *         if not 0 <= rstart < MAX_POS:             # <<<<<<<<<<<<<<
 *             raise ValueError('start out of range (%i)' % rstart)
 *         if not 0 <= rend <= MAX_POS:
 */
  __pyx_t_2 = (0 <= __pyx_v_rstart);
  if (__pyx_t_2) {
    __pyx_t_2 = (__pyx_v_rstart < __pyx_v_5pysam_14calignmentfile_MAX_POS);
  }
  __pyx_t_13 = ((!(__pyx_t_2 != 0)) != 0);
  if (__pyx_t_13) {

    /* "pysam/calignmentfile.pyx":809
 *                 'invalid coordinates: start (%i) > end (%i)' % (rstart, rend))
 *         if not 0 <= rstart < MAX_POS:
 *             raise ValueError('start out of range (%i)' % rstart)             # <<<<<<<<<<<<<<
 *         if not 0 <= rend <= MAX_POS:
 *             raise ValueError('end out of range (%i)' % rend)
 */
    __pyx_t_1 = __Pyx_PyInt_From_PY_LONG_LONG(__pyx_v_rstart); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 809, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_8 = __Pyx_PyString_Format(__pyx_kp_s_start_out_of_range_i, __pyx_t_1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 809, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 809, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_GIVEREF(__pyx_t_8);
    PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_8);
    __pyx_t_8 = 0;
    __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_1, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 809, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_Raise(__pyx_t_8, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __PYX_ERR(0, 809, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":808
 *             raise ValueError(
 *                 'invalid coordinates: start (%i) > end (%i)' % (rstart, rend))
 *         if not 0 <= rstart < MAX_POS:             # <<<<<<<<<<<<<<
 *             raise ValueError('start out of range (%i)' % rstart)
 *         if not 0 <= rend <= MAX_POS:
 */
  }

  /* "pysam/calignmentfile.pyx":810
 *         if not 0 <= rstart < MAX_POS:
 *             raise ValueError('start out of range (%i)' % rstart)
 *         if not 0 <= rend <= MAX_POS:             # <<<<<<<<<<<<<<
 *             raise ValueError('end out of range (%i)' % rend)
 * 
 */
  __pyx_t_13 = (0 <= __pyx_v_rend);
  if (__pyx_t_13) {
    __pyx_t_13 = (__pyx_v_rend <= __pyx_v_5pysam_14calignmentfile_MAX_POS);
  }
  __pyx_t_2 = ((!(__pyx_t_13 != 0)) != 0);
  if (__pyx_t_2) {

    /* "pysam/calignmentfile.pyx":811
 *             raise ValueError('start out of range (%i)' % rstart)
 *         if not 0 <= rend <= MAX_POS:
 *             raise ValueError('end out of range (%i)' % rend)             # <<<<<<<<<<<<<<
 * 
 *         return 1, rtid, rstart, rend
 */
    __pyx_t_8 = __Pyx_PyInt_From_PY_LONG_LONG(__pyx_v_rend); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 811, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_1 = __Pyx_PyString_Format(__pyx_kp_s_end_out_of_range_i, __pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 811, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_8 = PyTuple_New(1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 811, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_GIVEREF(__pyx_t_1);
    PyTuple_SET_ITEM(__pyx_t_8, 0, __pyx_t_1);
    __pyx_t_1 = 0;
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_8, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 811, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 811, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":810
 *         if not 0 <= rstart < MAX_POS:
 *             raise ValueError('start out of range (%i)' % rstart)
 *         if not 0 <= rend <= MAX_POS:             # <<<<<<<<<<<<<<
 *             raise ValueError('end out of range (%i)' % rend)
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":813
 *             raise ValueError('end out of range (%i)' % rend)
 * 
 *         return 1, rtid, rstart, rend             # <<<<<<<<<<<<<<
 * 
 *     def fetch(self,
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_rtid); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 813, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_8 = __Pyx_PyInt_From_PY_LONG_LONG(__pyx_v_rstart); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 813, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __pyx_t_9 = __Pyx_PyInt_From_PY_LONG_LONG(__pyx_v_rend); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 813, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_9);
  __pyx_t_10 = PyTuple_New(4); if (unlikely(!__pyx_t_10)) __PYX_ERR(0, 813, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_10);
  __Pyx_INCREF(__pyx_int_1);
  __Pyx_GIVEREF(__pyx_int_1);
  PyTuple_SET_ITEM(__pyx_t_10, 0, __pyx_int_1);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_10, 1, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_8);
  PyTuple_SET_ITEM(__pyx_t_10, 2, __pyx_t_8);
  __Pyx_GIVEREF(__pyx_t_9);
  PyTuple_SET_ITEM(__pyx_t_10, 3, __pyx_t_9);
  __pyx_t_1 = 0;
  __pyx_t_8 = 0;
  __pyx_t_9 = 0;
  __pyx_r = __pyx_t_10;
  __pyx_t_10 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":732
 *         return pos
 * 
 *     def parse_region(self,             # <<<<<<<<<<<<<<
 *                      reference=None,
 *                      start=None,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_XDECREF(__pyx_t_10);
  __Pyx_XDECREF(__pyx_t_11);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.parse_region", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_parts);
  __Pyx_XDECREF(__pyx_v_reference);
  __Pyx_XDECREF(__pyx_v_region);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":815
 *         return 1, rtid, rstart, rend
 * 
 *     def fetch(self,             # <<<<<<<<<<<<<<
 *               reference=None,
 *               start=None,
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_23fetch(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_22fetch[] = "AlignmentFile.fetch(self, reference=None, start=None, end=None, region=None, tid=None, until_eof=False, multiple_iterators=False)\nfetch reads aligned in a :term:`region`. \n\n        See :meth:`AlignmentFile.parse_region` for more information\n        on genomic regions.\n\n        Without a `reference` or `region` all mapped reads in the file\n        will be fetched. The reads will be returned ordered by reference\n        sequence, which will not necessarily be the order within the\n        file. This mode of iteration still requires an index. If there is\n        no index, use `until_eof=True`.\n\n        If only `reference` is set, all reads aligned to `reference`\n        will be fetched.\n\n        A :term:`SAM` file does not allow random access. If `region`\n        or `reference` are given, an exception is raised.\n\n        :class:`~pysam.FastaFile`\n        :class:`~pysam.IteratorRow`\n        :class:`~pysam.IteratorRow`\n        :class:`~IteratorRow`\n        :class:`IteratorRow`\n\n        Parameters\n        ----------\n        \n        until_eof : bool\n\n           If `until_eof` is True, all reads from the current file\n           position will be returned in order as they are within the\n           file. Using this option will also fetch unmapped reads.\n\n        multiple_iterators : bool\n           \n           If `multiple_iterators` is True (default) multiple\n           iterators on the same file can be used at the same time. The\n           iterator returned will receive its own copy of a filehandle to\n           the file effectively re-opening the file. Re-opening a file\n           creates some overhead, so beware.\n\n        Returns\n        -------\n\n        An iterator over a collection of reads.\n\n        Raises\n        ------\n\n        ValueError\n            if the genomic coordinates are out of range or invalid or the\n            file does not permit random access to genomic coordinates.\n\n        ";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_23fetch(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_reference = 0;
  PyObject *__pyx_v_start = 0;
  PyObject *__pyx_v_end = 0;
  PyObject *__pyx_v_region = 0;
  PyObject *__pyx_v_tid = 0;
  PyObject *__pyx_v_until_eof = 0;
  PyObject *__pyx_v_multiple_iterators = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("fetch (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_reference,&__pyx_n_s_start,&__pyx_n_s_end,&__pyx_n_s_region,&__pyx_n_s_tid,&__pyx_n_s_until_eof,&__pyx_n_s_multiple_iterators,0};
    PyObject* values[7] = {0,0,0,0,0,0,0};

    /* "pysam/calignmentfile.pyx":816
 * 
 *     def fetch(self,
 *               reference=None,             # <<<<<<<<<<<<<<
 *               start=None,
 *               end=None,
 */
    values[0] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":817
 *     def fetch(self,
 *               reference=None,
 *               start=None,             # <<<<<<<<<<<<<<
 *               end=None,
 *               region=None,
 */
    values[1] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":818
 *               reference=None,
 *               start=None,
 *               end=None,             # <<<<<<<<<<<<<<
 *               region=None,
 *               tid=None,
 */
    values[2] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":819
 *               start=None,
 *               end=None,
 *               region=None,             # <<<<<<<<<<<<<<
 *               tid=None,
 *               until_eof=False,
 */
    values[3] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":820
 *               end=None,
 *               region=None,
 *               tid=None,             # <<<<<<<<<<<<<<
 *               until_eof=False,
 *               multiple_iterators=False):
 */
    values[4] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":821
 *               region=None,
 *               tid=None,
 *               until_eof=False,             # <<<<<<<<<<<<<<
 *               multiple_iterators=False):
 *         """fetch reads aligned in a :term:`region`.
 */
    values[5] = ((PyObject *)Py_False);

    /* "pysam/calignmentfile.pyx":822
 *               tid=None,
 *               until_eof=False,
 *               multiple_iterators=False):             # <<<<<<<<<<<<<<
 *         """fetch reads aligned in a :term:`region`.
 * 
 */
    values[6] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_reference);
          if (value) { values[0] = value; kw_args--; }
        }
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_start);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_end);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_region);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_tid);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_until_eof);
          if (value) { values[5] = value; kw_args--; }
        }
        case  6:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_multiple_iterators);
          if (value) { values[6] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "fetch") < 0)) __PYX_ERR(0, 815, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  7: values[6] = PyTuple_GET_ITEM(__pyx_args, 6);
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_reference = values[0];
    __pyx_v_start = values[1];
    __pyx_v_end = values[2];
    __pyx_v_region = values[3];
    __pyx_v_tid = values[4];
    __pyx_v_until_eof = values[5];
    __pyx_v_multiple_iterators = values[6];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("fetch", 0, 0, 7, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 815, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.fetch", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_22fetch(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self), __pyx_v_reference, __pyx_v_start, __pyx_v_end, __pyx_v_region, __pyx_v_tid, __pyx_v_until_eof, __pyx_v_multiple_iterators);

  /* "pysam/calignmentfile.pyx":815
 *         return 1, rtid, rstart, rend
 * 
 *     def fetch(self,             # <<<<<<<<<<<<<<
 *               reference=None,
 *               start=None,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_22fetch(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_reference, PyObject *__pyx_v_start, PyObject *__pyx_v_end, PyObject *__pyx_v_region, PyObject *__pyx_v_tid, PyObject *__pyx_v_until_eof, PyObject *__pyx_v_multiple_iterators) {
  int __pyx_v_rtid;
  int __pyx_v_rstart;
  int __pyx_v_rend;
  int __pyx_v_has_coord;
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  Py_ssize_t __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *(*__pyx_t_10)(PyObject *);
  int __pyx_t_11;
  int __pyx_t_12;
  int __pyx_t_13;
  int __pyx_t_14;
  int __pyx_t_15;
  __Pyx_RefNannySetupContext("fetch", 0);
  __Pyx_TraceCall("fetch", __pyx_f[0], 815, 0, __PYX_ERR(0, 815, __pyx_L1_error));
  __Pyx_INCREF(__pyx_v_multiple_iterators);

  /* "pysam/calignmentfile.pyx":878
 *         cdef int rtid, rstart, rend, has_coord
 * 
 *         if not self.is_open():             # <<<<<<<<<<<<<<
 *             raise ValueError( "I/O operation on closed file" )
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_open); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 878, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 878, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 878, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 878, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = ((!__pyx_t_4) != 0);
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":879
 * 
 *         if not self.is_open():
 *             raise ValueError( "I/O operation on closed file" )             # <<<<<<<<<<<<<<
 * 
 *         has_coord, rtid, rstart, rend = self.parse_region(
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__25, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 879, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 879, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":878
 *         cdef int rtid, rstart, rend, has_coord
 * 
 *         if not self.is_open():             # <<<<<<<<<<<<<<
 *             raise ValueError( "I/O operation on closed file" )
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":881
 *             raise ValueError( "I/O operation on closed file" )
 * 
 *         has_coord, rtid, rstart, rend = self.parse_region(             # <<<<<<<<<<<<<<
 *             reference,
 *             start,
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_parse_region); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 881, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);

  /* "pysam/calignmentfile.pyx":886
 *             end,
 *             region,
 *             tid)             # <<<<<<<<<<<<<<
 * 
 *         # Turn of re-opening if htsfile is a stream
 */
  __pyx_t_3 = NULL;
  __pyx_t_6 = 0;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
      __pyx_t_6 = 1;
    }
  }
  __pyx_t_7 = PyTuple_New(5+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 881, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  if (__pyx_t_3) {
    __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_3); __pyx_t_3 = NULL;
  }
  __Pyx_INCREF(__pyx_v_reference);
  __Pyx_GIVEREF(__pyx_v_reference);
  PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_v_reference);
  __Pyx_INCREF(__pyx_v_start);
  __Pyx_GIVEREF(__pyx_v_start);
  PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_v_start);
  __Pyx_INCREF(__pyx_v_end);
  __Pyx_GIVEREF(__pyx_v_end);
  PyTuple_SET_ITEM(__pyx_t_7, 2+__pyx_t_6, __pyx_v_end);
  __Pyx_INCREF(__pyx_v_region);
  __Pyx_GIVEREF(__pyx_v_region);
  PyTuple_SET_ITEM(__pyx_t_7, 3+__pyx_t_6, __pyx_v_region);
  __Pyx_INCREF(__pyx_v_tid);
  __Pyx_GIVEREF(__pyx_v_tid);
  PyTuple_SET_ITEM(__pyx_t_7, 4+__pyx_t_6, __pyx_v_tid);
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 881, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
    PyObject* sequence = __pyx_t_1;
    #if CYTHON_COMPILING_IN_CPYTHON
    Py_ssize_t size = Py_SIZE(sequence);
    #else
    Py_ssize_t size = PySequence_Size(sequence);
    #endif
    if (unlikely(size != 4)) {
      if (size > 4) __Pyx_RaiseTooManyValuesError(4);
      else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
      __PYX_ERR(0, 881, __pyx_L1_error)
    }
    #if CYTHON_COMPILING_IN_CPYTHON
    if (likely(PyTuple_CheckExact(sequence))) {
      __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
      __pyx_t_7 = PyTuple_GET_ITEM(sequence, 1); 
      __pyx_t_3 = PyTuple_GET_ITEM(sequence, 2); 
      __pyx_t_8 = PyTuple_GET_ITEM(sequence, 3); 
    } else {
      __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
      __pyx_t_7 = PyList_GET_ITEM(sequence, 1); 
      __pyx_t_3 = PyList_GET_ITEM(sequence, 2); 
      __pyx_t_8 = PyList_GET_ITEM(sequence, 3); 
    }
    __Pyx_INCREF(__pyx_t_2);
    __Pyx_INCREF(__pyx_t_7);
    __Pyx_INCREF(__pyx_t_3);
    __Pyx_INCREF(__pyx_t_8);
    #else
    {
      Py_ssize_t i;
      PyObject** temps[4] = {&__pyx_t_2,&__pyx_t_7,&__pyx_t_3,&__pyx_t_8};
      for (i=0; i < 4; i++) {
        PyObject* item = PySequence_ITEM(sequence, i); if (unlikely(!item)) __PYX_ERR(0, 881, __pyx_L1_error)
        __Pyx_GOTREF(item);
        *(temps[i]) = item;
      }
    }
    #endif
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  } else {
    Py_ssize_t index = -1;
    PyObject** temps[4] = {&__pyx_t_2,&__pyx_t_7,&__pyx_t_3,&__pyx_t_8};
    __pyx_t_9 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 881, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_10 = Py_TYPE(__pyx_t_9)->tp_iternext;
    for (index=0; index < 4; index++) {
      PyObject* item = __pyx_t_10(__pyx_t_9); if (unlikely(!item)) goto __pyx_L4_unpacking_failed;
      __Pyx_GOTREF(item);
      *(temps[index]) = item;
    }
    if (__Pyx_IternextUnpackEndCheck(__pyx_t_10(__pyx_t_9), 4) < 0) __PYX_ERR(0, 881, __pyx_L1_error)
    __pyx_t_10 = NULL;
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    goto __pyx_L5_unpacking_done;
    __pyx_L4_unpacking_failed:;
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __pyx_t_10 = NULL;
    if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
    __PYX_ERR(0, 881, __pyx_L1_error)
    __pyx_L5_unpacking_done:;
  }

  /* "pysam/calignmentfile.pyx":881
 *             raise ValueError( "I/O operation on closed file" )
 * 
 *         has_coord, rtid, rstart, rend = self.parse_region(             # <<<<<<<<<<<<<<
 *             reference,
 *             start,
 */
  __pyx_t_11 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_11 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 881, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_12 = __Pyx_PyInt_As_int(__pyx_t_7); if (unlikely((__pyx_t_12 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 881, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __pyx_t_13 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_13 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 881, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_14 = __Pyx_PyInt_As_int(__pyx_t_8); if (unlikely((__pyx_t_14 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 881, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  __pyx_v_has_coord = __pyx_t_11;
  __pyx_v_rtid = __pyx_t_12;
  __pyx_v_rstart = __pyx_t_13;
  __pyx_v_rend = __pyx_t_14;

  /* "pysam/calignmentfile.pyx":889
 * 
 *         # Turn of re-opening if htsfile is a stream
 *         if self.is_stream:             # <<<<<<<<<<<<<<
 *             multiple_iterators = False
 * 
 */
  __pyx_t_5 = (__pyx_v_self->is_stream != 0);
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":890
 *         # Turn of re-opening if htsfile is a stream
 *         if self.is_stream:
 *             multiple_iterators = False             # <<<<<<<<<<<<<<
 * 
 *         if self.is_bam or self.is_cram:
 */
    __Pyx_INCREF(Py_False);
    __Pyx_DECREF_SET(__pyx_v_multiple_iterators, Py_False);

    /* "pysam/calignmentfile.pyx":889
 * 
 *         # Turn of re-opening if htsfile is a stream
 *         if self.is_stream:             # <<<<<<<<<<<<<<
 *             multiple_iterators = False
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":892
 *             multiple_iterators = False
 * 
 *         if self.is_bam or self.is_cram:             # <<<<<<<<<<<<<<
 *             if not until_eof and not self.is_remote:
 *                 if not self.has_index():
 */
  __pyx_t_4 = (__pyx_v_self->is_bam != 0);
  if (!__pyx_t_4) {
  } else {
    __pyx_t_5 = __pyx_t_4;
    goto __pyx_L8_bool_binop_done;
  }
  __pyx_t_4 = (__pyx_v_self->is_cram != 0);
  __pyx_t_5 = __pyx_t_4;
  __pyx_L8_bool_binop_done:;
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":893
 * 
 *         if self.is_bam or self.is_cram:
 *             if not until_eof and not self.is_remote:             # <<<<<<<<<<<<<<
 *                 if not self.has_index():
 *                     raise ValueError(
 */
    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_until_eof); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 893, __pyx_L1_error)
    __pyx_t_15 = ((!__pyx_t_4) != 0);
    if (__pyx_t_15) {
    } else {
      __pyx_t_5 = __pyx_t_15;
      goto __pyx_L11_bool_binop_done;
    }
    __pyx_t_15 = ((!(__pyx_v_self->is_remote != 0)) != 0);
    __pyx_t_5 = __pyx_t_15;
    __pyx_L11_bool_binop_done:;
    if (__pyx_t_5) {

      /* "pysam/calignmentfile.pyx":894
 *         if self.is_bam or self.is_cram:
 *             if not until_eof and not self.is_remote:
 *                 if not self.has_index():             # <<<<<<<<<<<<<<
 *                     raise ValueError(
 *                         "fetch called on bamfile without index")
 */
      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_has_index); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 894, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __pyx_t_3 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_8))) {
        __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_8);
        if (likely(__pyx_t_3)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
          __Pyx_INCREF(__pyx_t_3);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_8, function);
        }
      }
      if (__pyx_t_3) {
        __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 894, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      } else {
        __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 894, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 894, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_15 = ((!__pyx_t_5) != 0);
      if (__pyx_t_15) {

        /* "pysam/calignmentfile.pyx":895
 *             if not until_eof and not self.is_remote:
 *                 if not self.has_index():
 *                     raise ValueError(             # <<<<<<<<<<<<<<
 *                         "fetch called on bamfile without index")
 * 
 */
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__26, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 895, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_Raise(__pyx_t_1, 0, 0, 0);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __PYX_ERR(0, 895, __pyx_L1_error)

        /* "pysam/calignmentfile.pyx":894
 *         if self.is_bam or self.is_cram:
 *             if not until_eof and not self.is_remote:
 *                 if not self.has_index():             # <<<<<<<<<<<<<<
 *                     raise ValueError(
 *                         "fetch called on bamfile without index")
 */
      }

      /* "pysam/calignmentfile.pyx":893
 * 
 *         if self.is_bam or self.is_cram:
 *             if not until_eof and not self.is_remote:             # <<<<<<<<<<<<<<
 *                 if not self.has_index():
 *                     raise ValueError(
 */
    }

    /* "pysam/calignmentfile.pyx":898
 *                         "fetch called on bamfile without index")
 * 
 *             if has_coord:             # <<<<<<<<<<<<<<
 *                 return IteratorRowRegion(
 *                     self, rtid, rstart, rend,
 */
    __pyx_t_15 = (__pyx_v_has_coord != 0);
    if (__pyx_t_15) {

      /* "pysam/calignmentfile.pyx":899
 * 
 *             if has_coord:
 *                 return IteratorRowRegion(             # <<<<<<<<<<<<<<
 *                     self, rtid, rstart, rend,
 *                     multiple_iterators=multiple_iterators)
 */
      __Pyx_XDECREF(__pyx_r);

      /* "pysam/calignmentfile.pyx":900
 *             if has_coord:
 *                 return IteratorRowRegion(
 *                     self, rtid, rstart, rend,             # <<<<<<<<<<<<<<
 *                     multiple_iterators=multiple_iterators)
 *             else:
 */
      __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_rtid); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 900, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_8 = __Pyx_PyInt_From_int(__pyx_v_rstart); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 900, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_rend); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 900, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);

      /* "pysam/calignmentfile.pyx":899
 * 
 *             if has_coord:
 *                 return IteratorRowRegion(             # <<<<<<<<<<<<<<
 *                     self, rtid, rstart, rend,
 *                     multiple_iterators=multiple_iterators)
 */
      __pyx_t_7 = PyTuple_New(4); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 899, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_INCREF(((PyObject *)__pyx_v_self));
      __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
      PyTuple_SET_ITEM(__pyx_t_7, 0, ((PyObject *)__pyx_v_self));
      __Pyx_GIVEREF(__pyx_t_1);
      PyTuple_SET_ITEM(__pyx_t_7, 1, __pyx_t_1);
      __Pyx_GIVEREF(__pyx_t_8);
      PyTuple_SET_ITEM(__pyx_t_7, 2, __pyx_t_8);
      __Pyx_GIVEREF(__pyx_t_3);
      PyTuple_SET_ITEM(__pyx_t_7, 3, __pyx_t_3);
      __pyx_t_1 = 0;
      __pyx_t_8 = 0;
      __pyx_t_3 = 0;

      /* "pysam/calignmentfile.pyx":901
 *                 return IteratorRowRegion(
 *                     self, rtid, rstart, rend,
 *                     multiple_iterators=multiple_iterators)             # <<<<<<<<<<<<<<
 *             else:
 *                 if until_eof:
 */
      __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 901, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_multiple_iterators, __pyx_v_multiple_iterators) < 0) __PYX_ERR(0, 901, __pyx_L1_error)

      /* "pysam/calignmentfile.pyx":899
 * 
 *             if has_coord:
 *                 return IteratorRowRegion(             # <<<<<<<<<<<<<<
 *                     self, rtid, rstart, rend,
 *                     multiple_iterators=multiple_iterators)
 */
      __pyx_t_8 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_5pysam_14calignmentfile_IteratorRowRegion), __pyx_t_7, __pyx_t_3); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 899, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_r = __pyx_t_8;
      __pyx_t_8 = 0;
      goto __pyx_L0;

      /* "pysam/calignmentfile.pyx":898
 *                         "fetch called on bamfile without index")
 * 
 *             if has_coord:             # <<<<<<<<<<<<<<
 *                 return IteratorRowRegion(
 *                     self, rtid, rstart, rend,
 */
    }

    /* "pysam/calignmentfile.pyx":903
 *                     multiple_iterators=multiple_iterators)
 *             else:
 *                 if until_eof:             # <<<<<<<<<<<<<<
 *                     return IteratorRowAll(
 *                         self,
 */
    /*else*/ {
      __pyx_t_15 = __Pyx_PyObject_IsTrue(__pyx_v_until_eof); if (unlikely(__pyx_t_15 < 0)) __PYX_ERR(0, 903, __pyx_L1_error)
      if (__pyx_t_15) {

        /* "pysam/calignmentfile.pyx":904
 *             else:
 *                 if until_eof:
 *                     return IteratorRowAll(             # <<<<<<<<<<<<<<
 *                         self,
 *                         multiple_iterators=multiple_iterators)
 */
        __Pyx_XDECREF(__pyx_r);

        /* "pysam/calignmentfile.pyx":905
 *                 if until_eof:
 *                     return IteratorRowAll(
 *                         self,             # <<<<<<<<<<<<<<
 *                         multiple_iterators=multiple_iterators)
 *                 else:
 */
        __pyx_t_8 = PyTuple_New(1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 904, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_8);
        __Pyx_INCREF(((PyObject *)__pyx_v_self));
        __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
        PyTuple_SET_ITEM(__pyx_t_8, 0, ((PyObject *)__pyx_v_self));

        /* "pysam/calignmentfile.pyx":906
 *                     return IteratorRowAll(
 *                         self,
 *                         multiple_iterators=multiple_iterators)             # <<<<<<<<<<<<<<
 *                 else:
 *                     # AH: check - reason why no multiple_iterators for
 */
        __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 906, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_multiple_iterators, __pyx_v_multiple_iterators) < 0) __PYX_ERR(0, 906, __pyx_L1_error)

        /* "pysam/calignmentfile.pyx":904
 *             else:
 *                 if until_eof:
 *                     return IteratorRowAll(             # <<<<<<<<<<<<<<
 *                         self,
 *                         multiple_iterators=multiple_iterators)
 */
        __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_5pysam_14calignmentfile_IteratorRowAll), __pyx_t_8, __pyx_t_3); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 904, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_r = __pyx_t_7;
        __pyx_t_7 = 0;
        goto __pyx_L0;

        /* "pysam/calignmentfile.pyx":903
 *                     multiple_iterators=multiple_iterators)
 *             else:
 *                 if until_eof:             # <<<<<<<<<<<<<<
 *                     return IteratorRowAll(
 *                         self,
 */
      }

      /* "pysam/calignmentfile.pyx":910
 *                     # AH: check - reason why no multiple_iterators for
 *                     # AllRefs?
 *                     return IteratorRowAllRefs(             # <<<<<<<<<<<<<<
 *                         self,
 *                         multiple_iterators=multiple_iterators)
 */
      /*else*/ {
        __Pyx_XDECREF(__pyx_r);

        /* "pysam/calignmentfile.pyx":911
 *                     # AllRefs?
 *                     return IteratorRowAllRefs(
 *                         self,             # <<<<<<<<<<<<<<
 *                         multiple_iterators=multiple_iterators)
 *         else:
 */
        __pyx_t_7 = PyTuple_New(1); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 910, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_INCREF(((PyObject *)__pyx_v_self));
        __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
        PyTuple_SET_ITEM(__pyx_t_7, 0, ((PyObject *)__pyx_v_self));

        /* "pysam/calignmentfile.pyx":912
 *                     return IteratorRowAllRefs(
 *                         self,
 *                         multiple_iterators=multiple_iterators)             # <<<<<<<<<<<<<<
 *         else:
 *             if has_coord:
 */
        __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 912, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_multiple_iterators, __pyx_v_multiple_iterators) < 0) __PYX_ERR(0, 912, __pyx_L1_error)

        /* "pysam/calignmentfile.pyx":910
 *                     # AH: check - reason why no multiple_iterators for
 *                     # AllRefs?
 *                     return IteratorRowAllRefs(             # <<<<<<<<<<<<<<
 *                         self,
 *                         multiple_iterators=multiple_iterators)
 */
        __pyx_t_8 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_5pysam_14calignmentfile_IteratorRowAllRefs), __pyx_t_7, __pyx_t_3); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 910, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_8);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_r = __pyx_t_8;
        __pyx_t_8 = 0;
        goto __pyx_L0;
      }
    }

    /* "pysam/calignmentfile.pyx":892
 *             multiple_iterators = False
 * 
 *         if self.is_bam or self.is_cram:             # <<<<<<<<<<<<<<
 *             if not until_eof and not self.is_remote:
 *                 if not self.has_index():
 */
  }

  /* "pysam/calignmentfile.pyx":914
 *                         multiple_iterators=multiple_iterators)
 *         else:
 *             if has_coord:             # <<<<<<<<<<<<<<
 *                 raise ValueError(
 *                     "fetching by region is not available for sam files")
 */
  /*else*/ {
    __pyx_t_15 = (__pyx_v_has_coord != 0);
    if (__pyx_t_15) {

      /* "pysam/calignmentfile.pyx":915
 *         else:
 *             if has_coord:
 *                 raise ValueError(             # <<<<<<<<<<<<<<
 *                     "fetching by region is not available for sam files")
 * 
 */
      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__27, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 915, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_Raise(__pyx_t_8, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __PYX_ERR(0, 915, __pyx_L1_error)

      /* "pysam/calignmentfile.pyx":914
 *                         multiple_iterators=multiple_iterators)
 *         else:
 *             if has_coord:             # <<<<<<<<<<<<<<
 *                 raise ValueError(
 *                     "fetching by region is not available for sam files")
 */
    }

    /* "pysam/calignmentfile.pyx":918
 *                     "fetching by region is not available for sam files")
 * 
 *             if self.header == NULL:             # <<<<<<<<<<<<<<
 *                 raise ValueError(
 *                     "fetch called for htsfile without header")
 */
    __pyx_t_15 = ((__pyx_v_self->header == NULL) != 0);
    if (__pyx_t_15) {

      /* "pysam/calignmentfile.pyx":919
 * 
 *             if self.header == NULL:
 *                 raise ValueError(             # <<<<<<<<<<<<<<
 *                     "fetch called for htsfile without header")
 * 
 */
      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__28, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 919, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_Raise(__pyx_t_8, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __PYX_ERR(0, 919, __pyx_L1_error)

      /* "pysam/calignmentfile.pyx":918
 *                     "fetching by region is not available for sam files")
 * 
 *             if self.header == NULL:             # <<<<<<<<<<<<<<
 *                 raise ValueError(
 *                     "fetch called for htsfile without header")
 */
    }

    /* "pysam/calignmentfile.pyx":924
 *             # check if targets are defined
 *             # give warning, sam_read1 segfaults
 *             if self.header.n_targets == 0:             # <<<<<<<<<<<<<<
 *                 warnings.warn("fetch called for htsfile without header")
 * 
 */
    __pyx_t_15 = ((__pyx_v_self->header->n_targets == 0) != 0);
    if (__pyx_t_15) {

      /* "pysam/calignmentfile.pyx":925
 *             # give warning, sam_read1 segfaults
 *             if self.header.n_targets == 0:
 *                 warnings.warn("fetch called for htsfile without header")             # <<<<<<<<<<<<<<
 * 
 *             return IteratorRowAll(self,
 */
      __pyx_t_8 = __Pyx_GetModuleGlobalName(__pyx_n_s_warnings); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 925, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_8, __pyx_n_s_warn); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 925, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_tuple__29, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 925, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;

      /* "pysam/calignmentfile.pyx":924
 *             # check if targets are defined
 *             # give warning, sam_read1 segfaults
 *             if self.header.n_targets == 0:             # <<<<<<<<<<<<<<
 *                 warnings.warn("fetch called for htsfile without header")
 * 
 */
    }

    /* "pysam/calignmentfile.pyx":927
 *                 warnings.warn("fetch called for htsfile without header")
 * 
 *             return IteratorRowAll(self,             # <<<<<<<<<<<<<<
 *                                   multiple_iterators=multiple_iterators)
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_8 = PyTuple_New(1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 927, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_INCREF(((PyObject *)__pyx_v_self));
    __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
    PyTuple_SET_ITEM(__pyx_t_8, 0, ((PyObject *)__pyx_v_self));

    /* "pysam/calignmentfile.pyx":928
 * 
 *             return IteratorRowAll(self,
 *                                   multiple_iterators=multiple_iterators)             # <<<<<<<<<<<<<<
 * 
 *     def head(self, n, multiple_iterators=True):
 */
    __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 928, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_multiple_iterators, __pyx_v_multiple_iterators) < 0) __PYX_ERR(0, 928, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":927
 *                 warnings.warn("fetch called for htsfile without header")
 * 
 *             return IteratorRowAll(self,             # <<<<<<<<<<<<<<
 *                                   multiple_iterators=multiple_iterators)
 * 
 */
    __pyx_t_7 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_5pysam_14calignmentfile_IteratorRowAll), __pyx_t_8, __pyx_t_3); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 927, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_r = __pyx_t_7;
    __pyx_t_7 = 0;
    goto __pyx_L0;
  }

  /* "pysam/calignmentfile.pyx":815
 *         return 1, rtid, rstart, rend
 * 
 *     def fetch(self,             # <<<<<<<<<<<<<<
 *               reference=None,
 *               start=None,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.fetch", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_multiple_iterators);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":930
 *                                   multiple_iterators=multiple_iterators)
 * 
 *     def head(self, n, multiple_iterators=True):             # <<<<<<<<<<<<<<
 *         '''return an iterator over the first n alignments.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_25head(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_24head[] = "AlignmentFile.head(self, n, multiple_iterators=True)\nreturn an iterator over the first n alignments. \n\n        This iterator is is useful for inspecting the bam-file.\n\n        Parameters\n        ----------\n\n        multiple_iterators : bool\n        \n            is set to True by default in order to\n            avoid changing the current file position.\n        \n        Returns\n        -------\n        \n        an iterator over a collection of reads\n        \n        ";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_25head(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_n = 0;
  PyObject *__pyx_v_multiple_iterators = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("head (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_n,&__pyx_n_s_multiple_iterators,0};
    PyObject* values[2] = {0,0};
    values[1] = ((PyObject *)Py_True);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_n)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_multiple_iterators);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "head") < 0)) __PYX_ERR(0, 930, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_n = values[0];
    __pyx_v_multiple_iterators = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("head", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 930, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.head", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_24head(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self), __pyx_v_n, __pyx_v_multiple_iterators);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_24head(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_n, PyObject *__pyx_v_multiple_iterators) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("head", 0);
  __Pyx_TraceCall("head", __pyx_f[0], 930, 0, __PYX_ERR(0, 930, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":949
 * 
 *         '''
 *         return IteratorRowHead(self, n,             # <<<<<<<<<<<<<<
 *                                multiple_iterators=multiple_iterators)
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 949, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_v_self));
  __Pyx_INCREF(__pyx_v_n);
  __Pyx_GIVEREF(__pyx_v_n);
  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_n);

  /* "pysam/calignmentfile.pyx":950
 *         '''
 *         return IteratorRowHead(self, n,
 *                                multiple_iterators=multiple_iterators)             # <<<<<<<<<<<<<<
 * 
 *     def mate(self, AlignedSegment read):
 */
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 950, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_multiple_iterators, __pyx_v_multiple_iterators) < 0) __PYX_ERR(0, 950, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":949
 * 
 *         '''
 *         return IteratorRowHead(self, n,             # <<<<<<<<<<<<<<
 *                                multiple_iterators=multiple_iterators)
 * 
 */
  __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_5pysam_14calignmentfile_IteratorRowHead), __pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 949, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":930
 *                                   multiple_iterators=multiple_iterators)
 * 
 *     def head(self, n, multiple_iterators=True):             # <<<<<<<<<<<<<<
 *         '''return an iterator over the first n alignments.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.head", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":952
 *                                multiple_iterators=multiple_iterators)
 * 
 *     def mate(self, AlignedSegment read):             # <<<<<<<<<<<<<<
 *         '''return the mate of :class:`~pysam.AlignedSegment` `read`.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_27mate(PyObject *__pyx_v_self, PyObject *__pyx_v_read); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_26mate[] = "AlignmentFile.mate(self, AlignedSegment read)\nreturn the mate of :class:`~pysam.AlignedSegment` `read`.\n\n        .. note::\n\n            Calling this method will change the file position.\n            This might interfere with any iterators that have\n            not re-opened the file.\n\n        .. note::\n  \n           This method is too slow for high-throughput processing.\n           If a read needs to be processed with its mate, work\n           from a read name sorted file or, better, cache reads.\n\n        Returns\n        -------\n        \n        :class:`~pysam.AlignedSegment` : the mate\n\n        Raises\n        ------\n\n        ValueError\n            if the read is unpaired or the mate is unmapped\n\n        ";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_27mate(PyObject *__pyx_v_self, PyObject *__pyx_v_read) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("mate (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_read), __pyx_ptype_5pysam_15calignedsegment_AlignedSegment, 1, "read", 0))) __PYX_ERR(0, 952, __pyx_L1_error)
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_26mate(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self), ((struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *)__pyx_v_read));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_26mate(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *__pyx_v_read) {
  uint32_t __pyx_v_flag;
  int __pyx_v_x;
  PyObject *__pyx_v_mate = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  uint16_t __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  Py_ssize_t __pyx_t_7;
  PyObject *(*__pyx_t_8)(PyObject *);
  int __pyx_t_9;
  __Pyx_RefNannySetupContext("mate", 0);
  __Pyx_TraceCall("mate", __pyx_f[0], 952, 0, __PYX_ERR(0, 952, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":979
 * 
 *         '''
 *         cdef uint32_t flag = read._delegate.core.flag             # <<<<<<<<<<<<<<
 * 
 *         if flag & BAM_FPAIRED == 0:
 */
  __pyx_t_1 = __pyx_v_read->_delegate->core.flag;
  __pyx_v_flag = __pyx_t_1;

  /* "pysam/calignmentfile.pyx":981
 *         cdef uint32_t flag = read._delegate.core.flag
 * 
 *         if flag & BAM_FPAIRED == 0:             # <<<<<<<<<<<<<<
 *             raise ValueError("read %s: is unpaired" %
 *                              (read.query_name))
 */
  __pyx_t_2 = (((__pyx_v_flag & BAM_FPAIRED) == 0) != 0);
  if (__pyx_t_2) {

    /* "pysam/calignmentfile.pyx":983
 *         if flag & BAM_FPAIRED == 0:
 *             raise ValueError("read %s: is unpaired" %
 *                              (read.query_name))             # <<<<<<<<<<<<<<
 *         if flag & BAM_FMUNMAP != 0:
 *             raise ValueError("mate %s: is unmapped" %
 */
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_read), __pyx_n_s_query_name); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 983, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);

    /* "pysam/calignmentfile.pyx":982
 * 
 *         if flag & BAM_FPAIRED == 0:
 *             raise ValueError("read %s: is unpaired" %             # <<<<<<<<<<<<<<
 *                              (read.query_name))
 *         if flag & BAM_FMUNMAP != 0:
 */
    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_read_s_is_unpaired, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 982, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 982, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_4);
    __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_3, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 982, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 982, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":981
 *         cdef uint32_t flag = read._delegate.core.flag
 * 
 *         if flag & BAM_FPAIRED == 0:             # <<<<<<<<<<<<<<
 *             raise ValueError("read %s: is unpaired" %
 *                              (read.query_name))
 */
  }

  /* "pysam/calignmentfile.pyx":984
 *             raise ValueError("read %s: is unpaired" %
 *                              (read.query_name))
 *         if flag & BAM_FMUNMAP != 0:             # <<<<<<<<<<<<<<
 *             raise ValueError("mate %s: is unmapped" %
 *                              (read.query_name))
 */
  __pyx_t_2 = (((__pyx_v_flag & BAM_FMUNMAP) != 0) != 0);
  if (__pyx_t_2) {

    /* "pysam/calignmentfile.pyx":986
 *         if flag & BAM_FMUNMAP != 0:
 *             raise ValueError("mate %s: is unmapped" %
 *                              (read.query_name))             # <<<<<<<<<<<<<<
 * 
 *         # xor flags to get the other mate
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_read), __pyx_n_s_query_name); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 986, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);

    /* "pysam/calignmentfile.pyx":985
 *                              (read.query_name))
 *         if flag & BAM_FMUNMAP != 0:
 *             raise ValueError("mate %s: is unmapped" %             # <<<<<<<<<<<<<<
 *                              (read.query_name))
 * 
 */
    __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_mate_s_is_unmapped, __pyx_t_4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 985, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 985, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_4, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 985, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 985, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":984
 *             raise ValueError("read %s: is unpaired" %
 *                              (read.query_name))
 *         if flag & BAM_FMUNMAP != 0:             # <<<<<<<<<<<<<<
 *             raise ValueError("mate %s: is unmapped" %
 *                              (read.query_name))
 */
  }

  /* "pysam/calignmentfile.pyx":989
 * 
 *         # xor flags to get the other mate
 *         cdef int x = BAM_FREAD1 + BAM_FREAD2             # <<<<<<<<<<<<<<
 *         flag = (flag ^ x) & x
 * 
 */
  __pyx_v_x = (BAM_FREAD1 + BAM_FREAD2);

  /* "pysam/calignmentfile.pyx":990
 *         # xor flags to get the other mate
 *         cdef int x = BAM_FREAD1 + BAM_FREAD2
 *         flag = (flag ^ x) & x             # <<<<<<<<<<<<<<
 * 
 *         # Make sure to use a separate file to jump around
 */
  __pyx_v_flag = ((__pyx_v_flag ^ __pyx_v_x) & __pyx_v_x);

  /* "pysam/calignmentfile.pyx":998
 *         # could thus be made much quicker, for example
 *         # by using tell and seek.
 *         for mate in self.fetch(             # <<<<<<<<<<<<<<
 *                 read._delegate.core.mpos,
 *                 read._delegate.core.mpos + 1,
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_fetch); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 998, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);

  /* "pysam/calignmentfile.pyx":999
 *         # by using tell and seek.
 *         for mate in self.fetch(
 *                 read._delegate.core.mpos,             # <<<<<<<<<<<<<<
 *                 read._delegate.core.mpos + 1,
 *                 tid=read._delegate.core.mtid,
 */
  __pyx_t_4 = __Pyx_PyInt_From_int32_t(__pyx_v_read->_delegate->core.mpos); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 999, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);

  /* "pysam/calignmentfile.pyx":1000
 *         for mate in self.fetch(
 *                 read._delegate.core.mpos,
 *                 read._delegate.core.mpos + 1,             # <<<<<<<<<<<<<<
 *                 tid=read._delegate.core.mtid,
 *                 multiple_iterators=True):
 */
  __pyx_t_5 = __Pyx_PyInt_From_long((__pyx_v_read->_delegate->core.mpos + 1)); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1000, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);

  /* "pysam/calignmentfile.pyx":998
 *         # could thus be made much quicker, for example
 *         # by using tell and seek.
 *         for mate in self.fetch(             # <<<<<<<<<<<<<<
 *                 read._delegate.core.mpos,
 *                 read._delegate.core.mpos + 1,
 */
  __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 998, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);
  __Pyx_GIVEREF(__pyx_t_4);
  PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_5);
  PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_t_5);
  __pyx_t_4 = 0;
  __pyx_t_5 = 0;

  /* "pysam/calignmentfile.pyx":1001
 *                 read._delegate.core.mpos,
 *                 read._delegate.core.mpos + 1,
 *                 tid=read._delegate.core.mtid,             # <<<<<<<<<<<<<<
 *                 multiple_iterators=True):
 *             if mate.flag & flag != 0 and \
 */
  __pyx_t_5 = PyDict_New(); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1001, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __pyx_t_4 = __Pyx_PyInt_From_int32_t(__pyx_v_read->_delegate->core.mtid); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1001, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_tid, __pyx_t_4) < 0) __PYX_ERR(0, 1001, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pysam/calignmentfile.pyx":1002
 *                 read._delegate.core.mpos + 1,
 *                 tid=read._delegate.core.mtid,
 *                 multiple_iterators=True):             # <<<<<<<<<<<<<<
 *             if mate.flag & flag != 0 and \
 *                mate.query_name == read.query_name:
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_multiple_iterators, Py_True) < 0) __PYX_ERR(0, 1001, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":998
 *         # could thus be made much quicker, for example
 *         # by using tell and seek.
 *         for mate in self.fetch(             # <<<<<<<<<<<<<<
 *                 read._delegate.core.mpos,
 *                 read._delegate.core.mpos + 1,
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_6, __pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 998, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  if (likely(PyList_CheckExact(__pyx_t_4)) || PyTuple_CheckExact(__pyx_t_4)) {
    __pyx_t_5 = __pyx_t_4; __Pyx_INCREF(__pyx_t_5); __pyx_t_7 = 0;
    __pyx_t_8 = NULL;
  } else {
    __pyx_t_7 = -1; __pyx_t_5 = PyObject_GetIter(__pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 998, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_8 = Py_TYPE(__pyx_t_5)->tp_iternext; if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 998, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  for (;;) {
    if (likely(!__pyx_t_8)) {
      if (likely(PyList_CheckExact(__pyx_t_5))) {
        if (__pyx_t_7 >= PyList_GET_SIZE(__pyx_t_5)) break;
        #if CYTHON_COMPILING_IN_CPYTHON
        __pyx_t_4 = PyList_GET_ITEM(__pyx_t_5, __pyx_t_7); __Pyx_INCREF(__pyx_t_4); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(0, 998, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_5, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 998, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      } else {
        if (__pyx_t_7 >= PyTuple_GET_SIZE(__pyx_t_5)) break;
        #if CYTHON_COMPILING_IN_CPYTHON
        __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_5, __pyx_t_7); __Pyx_INCREF(__pyx_t_4); __pyx_t_7++; if (unlikely(0 < 0)) __PYX_ERR(0, 998, __pyx_L1_error)
        #else
        __pyx_t_4 = PySequence_ITEM(__pyx_t_5, __pyx_t_7); __pyx_t_7++; if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 998, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_4);
        #endif
      }
    } else {
      __pyx_t_4 = __pyx_t_8(__pyx_t_5);
      if (unlikely(!__pyx_t_4)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 998, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_4);
    }
    __Pyx_XDECREF_SET(__pyx_v_mate, __pyx_t_4);
    __pyx_t_4 = 0;

    /* "pysam/calignmentfile.pyx":1003
 *                 tid=read._delegate.core.mtid,
 *                 multiple_iterators=True):
 *             if mate.flag & flag != 0 and \             # <<<<<<<<<<<<<<
 *                mate.query_name == read.query_name:
 *                 break
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(__pyx_v_mate, __pyx_n_s_flag); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1003, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_6 = __Pyx_PyInt_From_uint32_t(__pyx_v_flag); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1003, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_3 = PyNumber_And(__pyx_t_4, __pyx_t_6); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1003, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = PyObject_RichCompare(__pyx_t_3, __pyx_int_0, Py_NE); __Pyx_XGOTREF(__pyx_t_6); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1003, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_6); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 1003, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    if (__pyx_t_9) {
    } else {
      __pyx_t_2 = __pyx_t_9;
      goto __pyx_L8_bool_binop_done;
    }

    /* "pysam/calignmentfile.pyx":1004
 *                 multiple_iterators=True):
 *             if mate.flag & flag != 0 and \
 *                mate.query_name == read.query_name:             # <<<<<<<<<<<<<<
 *                 break
 *         else:
 */
    __pyx_t_6 = __Pyx_PyObject_GetAttrStr(__pyx_v_mate, __pyx_n_s_query_name); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 1004, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_6);
    __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_read), __pyx_n_s_query_name); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1004, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = PyObject_RichCompare(__pyx_t_6, __pyx_t_3, Py_EQ); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1004, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_9 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_9 < 0)) __PYX_ERR(0, 1004, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_2 = __pyx_t_9;
    __pyx_L8_bool_binop_done:;

    /* "pysam/calignmentfile.pyx":1003
 *                 tid=read._delegate.core.mtid,
 *                 multiple_iterators=True):
 *             if mate.flag & flag != 0 and \             # <<<<<<<<<<<<<<
 *                mate.query_name == read.query_name:
 *                 break
 */
    if (__pyx_t_2) {

      /* "pysam/calignmentfile.pyx":1005
 *             if mate.flag & flag != 0 and \
 *                mate.query_name == read.query_name:
 *                 break             # <<<<<<<<<<<<<<
 *         else:
 *             raise ValueError("mate not found")
 */
      goto __pyx_L6_break;

      /* "pysam/calignmentfile.pyx":1003
 *                 tid=read._delegate.core.mtid,
 *                 multiple_iterators=True):
 *             if mate.flag & flag != 0 and \             # <<<<<<<<<<<<<<
 *                mate.query_name == read.query_name:
 *                 break
 */
    }

    /* "pysam/calignmentfile.pyx":998
 *         # could thus be made much quicker, for example
 *         # by using tell and seek.
 *         for mate in self.fetch(             # <<<<<<<<<<<<<<
 *                 read._delegate.core.mpos,
 *                 read._delegate.core.mpos + 1,
 */
  }
  /*else*/ {

    /* "pysam/calignmentfile.pyx":1007
 *                 break
 *         else:
 *             raise ValueError("mate not found")             # <<<<<<<<<<<<<<
 * 
 *         return mate
 */
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__30, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1007, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 1007, __pyx_L1_error)
  }

  /* "pysam/calignmentfile.pyx":998
 *         # could thus be made much quicker, for example
 *         # by using tell and seek.
 *         for mate in self.fetch(             # <<<<<<<<<<<<<<
 *                 read._delegate.core.mpos,
 *                 read._delegate.core.mpos + 1,
 */
  __pyx_L6_break:;
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

  /* "pysam/calignmentfile.pyx":1009
 *             raise ValueError("mate not found")
 * 
 *         return mate             # <<<<<<<<<<<<<<
 * 
 *     def pileup(self,
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_mate);
  __pyx_r = __pyx_v_mate;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":952
 *                                multiple_iterators=multiple_iterators)
 * 
 *     def mate(self, AlignedSegment read):             # <<<<<<<<<<<<<<
 *         '''return the mate of :class:`~pysam.AlignedSegment` `read`.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.mate", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_mate);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1011
 *         return mate
 * 
 *     def pileup(self,             # <<<<<<<<<<<<<<
 *                reference=None,
 *                start=None,
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_29pileup(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_28pileup[] = "AlignmentFile.pileup(self, reference=None, start=None, end=None, region=None, **kwargs)\nperform a :term:`pileup` within a :term:`region`. The region is\n        specified by :term:`reference`, 'start' and 'end' (using\n        0-based indexing).  Alternatively, a samtools 'region' string\n        can be supplied.\n\n        Without 'reference' or 'region' all reads will be used for the\n        pileup. The reads will be returned ordered by\n        :term:`reference` sequence, which will not necessarily be the\n        order within the file.\n\n        Note that :term:`SAM` formatted files do not allow random\n        access.  In these files, if a 'region' or 'reference' are\n        given an exception is raised.\n\n        .. note::\n\n            'all' reads which overlap the region are returned. The\n            first base returned will be the first base of the first\n            read 'not' necessarily the first base of the region used\n            in the query.\n\n        Parameters\n        ----------\n\n        stepper : string\n           The stepper controlls how the iterator advances.\n           Possible options for the stepper are\n\n           ``all``\n              skip reads in which any of the following flags are set:\n              BAM_FUNMAP, BAM_FSECONDARY, BAM_FQCFAIL, BAM_FDUP\n\n           ``nofilter``\n              uses every single read\n\n           ``samtools``\n              same filter and read processing as in :term:`csamtools`\n              pileup. This requires a 'fastafile' to be given.\n\n\n        fastafile : :class:`~pysam.FastaFile` object.\n\n           This is required for some of the steppers.\n\n        max_depth : int\n           Maximum read depth permitted. The default limit is '8000'.\n\n        truncate : bool\n\n           By default, the samtools pileup engine outputs all reads\n           overlapping a region. If truncate is True and a region is\n           given, only columns in the exact region specificied are\n    ""       returned.\n\n        Returns\n        -------\n\n        an iterator over genomic positions.\n\n        ";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_29pileup(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_reference = 0;
  PyObject *__pyx_v_start = 0;
  PyObject *__pyx_v_end = 0;
  PyObject *__pyx_v_region = 0;
  PyObject *__pyx_v_kwargs = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("pileup (wrapper)", 0);
  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return NULL;
  __Pyx_GOTREF(__pyx_v_kwargs);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_reference,&__pyx_n_s_start,&__pyx_n_s_end,&__pyx_n_s_region,0};
    PyObject* values[4] = {0,0,0,0};

    /* "pysam/calignmentfile.pyx":1012
 * 
 *     def pileup(self,
 *                reference=None,             # <<<<<<<<<<<<<<
 *                start=None,
 *                end=None,
 */
    values[0] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":1013
 *     def pileup(self,
 *                reference=None,
 *                start=None,             # <<<<<<<<<<<<<<
 *                end=None,
 *                region=None,
 */
    values[1] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":1014
 *                reference=None,
 *                start=None,
 *                end=None,             # <<<<<<<<<<<<<<
 *                region=None,
 *                **kwargs):
 */
    values[2] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":1015
 *                start=None,
 *                end=None,
 *                region=None,             # <<<<<<<<<<<<<<
 *                **kwargs):
 *         """perform a :term:`pileup` within a :term:`region`. The region is
 */
    values[3] = ((PyObject *)Py_None);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_reference);
          if (value) { values[0] = value; kw_args--; }
        }
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_start);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_end);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_region);
          if (value) { values[3] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "pileup") < 0)) __PYX_ERR(0, 1011, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_reference = values[0];
    __pyx_v_start = values[1];
    __pyx_v_end = values[2];
    __pyx_v_region = values[3];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("pileup", 0, 0, 4, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1011, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.pileup", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_28pileup(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self), __pyx_v_reference, __pyx_v_start, __pyx_v_end, __pyx_v_region, __pyx_v_kwargs);

  /* "pysam/calignmentfile.pyx":1011
 *         return mate
 * 
 *     def pileup(self,             # <<<<<<<<<<<<<<
 *                reference=None,
 *                start=None,
 */

  /* function exit code */
  __Pyx_XDECREF(__pyx_v_kwargs);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_28pileup(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_reference, PyObject *__pyx_v_start, PyObject *__pyx_v_end, PyObject *__pyx_v_region, PyObject *__pyx_v_kwargs) {
  int __pyx_v_rtid;
  int __pyx_v_rstart;
  int __pyx_v_rend;
  int __pyx_v_has_coord;
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  Py_ssize_t __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  PyObject *(*__pyx_t_10)(PyObject *);
  int __pyx_t_11;
  int __pyx_t_12;
  int __pyx_t_13;
  int __pyx_t_14;
  __Pyx_RefNannySetupContext("pileup", 0);
  __Pyx_TraceCall("pileup", __pyx_f[0], 1011, 0, __PYX_ERR(0, 1011, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1079
 *         cdef int rtid, rstart, rend, has_coord
 * 
 *         if not self.is_open():             # <<<<<<<<<<<<<<
 *             raise ValueError("I/O operation on closed file")
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_open); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1079, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1079, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1079, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1079, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = ((!__pyx_t_4) != 0);
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":1080
 * 
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")             # <<<<<<<<<<<<<<
 * 
 *         has_coord, rtid, rstart, rend = self.parse_region(
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__31, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1080, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 1080, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":1079
 *         cdef int rtid, rstart, rend, has_coord
 * 
 *         if not self.is_open():             # <<<<<<<<<<<<<<
 *             raise ValueError("I/O operation on closed file")
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":1082
 *             raise ValueError("I/O operation on closed file")
 * 
 *         has_coord, rtid, rstart, rend = self.parse_region(             # <<<<<<<<<<<<<<
 *             reference, start, end, region)
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_parse_region); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1082, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);

  /* "pysam/calignmentfile.pyx":1083
 * 
 *         has_coord, rtid, rstart, rend = self.parse_region(
 *             reference, start, end, region)             # <<<<<<<<<<<<<<
 * 
 *         if self.is_bam or self.is_cram:
 */
  __pyx_t_3 = NULL;
  __pyx_t_6 = 0;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
      __pyx_t_6 = 1;
    }
  }
  __pyx_t_7 = PyTuple_New(4+__pyx_t_6); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1082, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);
  if (__pyx_t_3) {
    __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_3); __pyx_t_3 = NULL;
  }
  __Pyx_INCREF(__pyx_v_reference);
  __Pyx_GIVEREF(__pyx_v_reference);
  PyTuple_SET_ITEM(__pyx_t_7, 0+__pyx_t_6, __pyx_v_reference);
  __Pyx_INCREF(__pyx_v_start);
  __Pyx_GIVEREF(__pyx_v_start);
  PyTuple_SET_ITEM(__pyx_t_7, 1+__pyx_t_6, __pyx_v_start);
  __Pyx_INCREF(__pyx_v_end);
  __Pyx_GIVEREF(__pyx_v_end);
  PyTuple_SET_ITEM(__pyx_t_7, 2+__pyx_t_6, __pyx_v_end);
  __Pyx_INCREF(__pyx_v_region);
  __Pyx_GIVEREF(__pyx_v_region);
  PyTuple_SET_ITEM(__pyx_t_7, 3+__pyx_t_6, __pyx_v_region);
  __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_7, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1082, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if ((likely(PyTuple_CheckExact(__pyx_t_1))) || (PyList_CheckExact(__pyx_t_1))) {
    PyObject* sequence = __pyx_t_1;
    #if CYTHON_COMPILING_IN_CPYTHON
    Py_ssize_t size = Py_SIZE(sequence);
    #else
    Py_ssize_t size = PySequence_Size(sequence);
    #endif
    if (unlikely(size != 4)) {
      if (size > 4) __Pyx_RaiseTooManyValuesError(4);
      else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
      __PYX_ERR(0, 1082, __pyx_L1_error)
    }
    #if CYTHON_COMPILING_IN_CPYTHON
    if (likely(PyTuple_CheckExact(sequence))) {
      __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
      __pyx_t_7 = PyTuple_GET_ITEM(sequence, 1); 
      __pyx_t_3 = PyTuple_GET_ITEM(sequence, 2); 
      __pyx_t_8 = PyTuple_GET_ITEM(sequence, 3); 
    } else {
      __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
      __pyx_t_7 = PyList_GET_ITEM(sequence, 1); 
      __pyx_t_3 = PyList_GET_ITEM(sequence, 2); 
      __pyx_t_8 = PyList_GET_ITEM(sequence, 3); 
    }
    __Pyx_INCREF(__pyx_t_2);
    __Pyx_INCREF(__pyx_t_7);
    __Pyx_INCREF(__pyx_t_3);
    __Pyx_INCREF(__pyx_t_8);
    #else
    {
      Py_ssize_t i;
      PyObject** temps[4] = {&__pyx_t_2,&__pyx_t_7,&__pyx_t_3,&__pyx_t_8};
      for (i=0; i < 4; i++) {
        PyObject* item = PySequence_ITEM(sequence, i); if (unlikely(!item)) __PYX_ERR(0, 1082, __pyx_L1_error)
        __Pyx_GOTREF(item);
        *(temps[i]) = item;
      }
    }
    #endif
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  } else {
    Py_ssize_t index = -1;
    PyObject** temps[4] = {&__pyx_t_2,&__pyx_t_7,&__pyx_t_3,&__pyx_t_8};
    __pyx_t_9 = PyObject_GetIter(__pyx_t_1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1082, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_9);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_10 = Py_TYPE(__pyx_t_9)->tp_iternext;
    for (index=0; index < 4; index++) {
      PyObject* item = __pyx_t_10(__pyx_t_9); if (unlikely(!item)) goto __pyx_L4_unpacking_failed;
      __Pyx_GOTREF(item);
      *(temps[index]) = item;
    }
    if (__Pyx_IternextUnpackEndCheck(__pyx_t_10(__pyx_t_9), 4) < 0) __PYX_ERR(0, 1082, __pyx_L1_error)
    __pyx_t_10 = NULL;
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    goto __pyx_L5_unpacking_done;
    __pyx_L4_unpacking_failed:;
    __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
    __pyx_t_10 = NULL;
    if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
    __PYX_ERR(0, 1082, __pyx_L1_error)
    __pyx_L5_unpacking_done:;
  }

  /* "pysam/calignmentfile.pyx":1082
 *             raise ValueError("I/O operation on closed file")
 * 
 *         has_coord, rtid, rstart, rend = self.parse_region(             # <<<<<<<<<<<<<<
 *             reference, start, end, region)
 * 
 */
  __pyx_t_11 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_11 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 1082, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_12 = __Pyx_PyInt_As_int(__pyx_t_7); if (unlikely((__pyx_t_12 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 1082, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
  __pyx_t_13 = __Pyx_PyInt_As_int(__pyx_t_3); if (unlikely((__pyx_t_13 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 1082, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_14 = __Pyx_PyInt_As_int(__pyx_t_8); if (unlikely((__pyx_t_14 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 1082, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  __pyx_v_has_coord = __pyx_t_11;
  __pyx_v_rtid = __pyx_t_12;
  __pyx_v_rstart = __pyx_t_13;
  __pyx_v_rend = __pyx_t_14;

  /* "pysam/calignmentfile.pyx":1085
 *             reference, start, end, region)
 * 
 *         if self.is_bam or self.is_cram:             # <<<<<<<<<<<<<<
 *             if not self.has_index():
 *                 raise ValueError("no index available for pileup")
 */
  __pyx_t_4 = (__pyx_v_self->is_bam != 0);
  if (!__pyx_t_4) {
  } else {
    __pyx_t_5 = __pyx_t_4;
    goto __pyx_L7_bool_binop_done;
  }
  __pyx_t_4 = (__pyx_v_self->is_cram != 0);
  __pyx_t_5 = __pyx_t_4;
  __pyx_L7_bool_binop_done:;
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":1086
 * 
 *         if self.is_bam or self.is_cram:
 *             if not self.has_index():             # <<<<<<<<<<<<<<
 *                 raise ValueError("no index available for pileup")
 * 
 */
    __pyx_t_8 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_has_index); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1086, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __pyx_t_3 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_8))) {
      __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_8);
      if (likely(__pyx_t_3)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_8);
        __Pyx_INCREF(__pyx_t_3);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_8, function);
      }
    }
    if (__pyx_t_3) {
      __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_8, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1086, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    } else {
      __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_8); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1086, __pyx_L1_error)
    }
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1086, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_4 = ((!__pyx_t_5) != 0);
    if (__pyx_t_4) {

      /* "pysam/calignmentfile.pyx":1087
 *         if self.is_bam or self.is_cram:
 *             if not self.has_index():
 *                 raise ValueError("no index available for pileup")             # <<<<<<<<<<<<<<
 * 
 *             if has_coord:
 */
      __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__32, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1087, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_Raise(__pyx_t_1, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __PYX_ERR(0, 1087, __pyx_L1_error)

      /* "pysam/calignmentfile.pyx":1086
 * 
 *         if self.is_bam or self.is_cram:
 *             if not self.has_index():             # <<<<<<<<<<<<<<
 *                 raise ValueError("no index available for pileup")
 * 
 */
    }

    /* "pysam/calignmentfile.pyx":1089
 *                 raise ValueError("no index available for pileup")
 * 
 *             if has_coord:             # <<<<<<<<<<<<<<
 *                 return IteratorColumnRegion(self,
 *                                             tid=rtid,
 */
    __pyx_t_4 = (__pyx_v_has_coord != 0);
    if (__pyx_t_4) {

      /* "pysam/calignmentfile.pyx":1090
 * 
 *             if has_coord:
 *                 return IteratorColumnRegion(self,             # <<<<<<<<<<<<<<
 *                                             tid=rtid,
 *                                             start=rstart,
 */
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1090, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_INCREF(((PyObject *)__pyx_v_self));
      __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
      PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_v_self));

      /* "pysam/calignmentfile.pyx":1091
 *             if has_coord:
 *                 return IteratorColumnRegion(self,
 *                                             tid=rtid,             # <<<<<<<<<<<<<<
 *                                             start=rstart,
 *                                             end=rend,
 */
      __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1091, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_7 = __Pyx_PyInt_From_int(__pyx_v_rtid); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1091, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_tid, __pyx_t_7) < 0) __PYX_ERR(0, 1091, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

      /* "pysam/calignmentfile.pyx":1092
 *                 return IteratorColumnRegion(self,
 *                                             tid=rtid,
 *                                             start=rstart,             # <<<<<<<<<<<<<<
 *                                             end=rend,
 *                                             **kwargs )
 */
      __pyx_t_7 = __Pyx_PyInt_From_int(__pyx_v_rstart); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1092, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_start, __pyx_t_7) < 0) __PYX_ERR(0, 1091, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;

      /* "pysam/calignmentfile.pyx":1093
 *                                             tid=rtid,
 *                                             start=rstart,
 *                                             end=rend,             # <<<<<<<<<<<<<<
 *                                             **kwargs )
 *             else:
 */
      __pyx_t_7 = __Pyx_PyInt_From_int(__pyx_v_rend); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1093, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_7);
      if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_end, __pyx_t_7) < 0) __PYX_ERR(0, 1091, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __pyx_t_8 = __pyx_t_3;
      __pyx_t_3 = 0;

      /* "pysam/calignmentfile.pyx":1094
 *                                             start=rstart,
 *                                             end=rend,
 *                                             **kwargs )             # <<<<<<<<<<<<<<
 *             else:
 *                 return IteratorColumnAllRefs(self, **kwargs )
 */
      if (__Pyx_MergeKeywords(__pyx_t_8, __pyx_v_kwargs) < 0) __PYX_ERR(0, 1094, __pyx_L1_error)

      /* "pysam/calignmentfile.pyx":1090
 * 
 *             if has_coord:
 *                 return IteratorColumnRegion(self,             # <<<<<<<<<<<<<<
 *                                             tid=rtid,
 *                                             start=rstart,
 */
      __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_5pysam_14calignmentfile_IteratorColumnRegion), __pyx_t_1, __pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1090, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __pyx_r = __pyx_t_3;
      __pyx_t_3 = 0;
      goto __pyx_L0;

      /* "pysam/calignmentfile.pyx":1089
 *                 raise ValueError("no index available for pileup")
 * 
 *             if has_coord:             # <<<<<<<<<<<<<<
 *                 return IteratorColumnRegion(self,
 *                                             tid=rtid,
 */
    }

    /* "pysam/calignmentfile.pyx":1096
 *                                             **kwargs )
 *             else:
 *                 return IteratorColumnAllRefs(self, **kwargs )             # <<<<<<<<<<<<<<
 * 
 *         else:
 */
    /*else*/ {
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1096, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_INCREF(((PyObject *)__pyx_v_self));
      __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
      PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_v_self));
      __pyx_t_8 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_5pysam_14calignmentfile_IteratorColumnAllRefs), __pyx_t_3, __pyx_v_kwargs); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1096, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_r = __pyx_t_8;
      __pyx_t_8 = 0;
      goto __pyx_L0;
    }

    /* "pysam/calignmentfile.pyx":1085
 *             reference, start, end, region)
 * 
 *         if self.is_bam or self.is_cram:             # <<<<<<<<<<<<<<
 *             if not self.has_index():
 *                 raise ValueError("no index available for pileup")
 */
  }

  /* "pysam/calignmentfile.pyx":1099
 * 
 *         else:
 *             raise NotImplementedError(             # <<<<<<<<<<<<<<
 *                 "pileup of samfiles not implemented yet")
 * 
 */
  /*else*/ {
    __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__33, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1099, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_8);
    __Pyx_Raise(__pyx_t_8, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
    __PYX_ERR(0, 1099, __pyx_L1_error)
  }

  /* "pysam/calignmentfile.pyx":1011
 *         return mate
 * 
 *     def pileup(self,             # <<<<<<<<<<<<<<
 *                reference=None,
 *                start=None,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.pileup", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1102
 *                 "pileup of samfiles not implemented yet")
 * 
 *     def count(self,             # <<<<<<<<<<<<<<
 *               reference=None,
 *               start=None,
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_31count(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_30count[] = "AlignmentFile.count(self, reference=None, start=None, end=None, region=None, until_eof=False, read_callback='nofilter')\ncount the number of reads in :term:`region`\n\n        The region is specified by :term:`reference`, `start` and\n        `end`. Alternatively, a :term:`samtools` :term:`region` string\n        can be supplied.\n\n        A :term:`SAM` file does not allow random access and if\n        `region` or `reference` are given, an exception is raised.\n\n        Parameters\n        ----------\n        \n        reference : string\n            reference_name of the genomic region (chromosome)\n\n        start : int\n            start of the genomic region\n\n        end : int\n            end of the genomic region\n        \n        region : string\n            a region string in samtools format.\n\n        until_eof : bool\n            count until the end of the file, possibly including \n            unmapped reads as well.\n\n        read_callback: string or function\n\n            select a call-back to ignore reads when counting. It can\n            be either a string with the following values:\n\n            ``all``\n                skip reads in which any of the following\n                flags are set: BAM_FUNMAP, BAM_FSECONDARY, BAM_FQCFAIL,\n                BAM_FDUP\n\n            ``nofilter``\n                uses every single read\n\n            Alternatively, `read_callback` can be a function\n            ``check_read(read)`` that should return True only for\n            those reads that shall be included in the counting.\n\n        Raises\n        ------\n\n        ValueError\n            if the genomic coordinates are out of range or invalid.\n\n        ";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_31count(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_reference = 0;
  PyObject *__pyx_v_start = 0;
  PyObject *__pyx_v_end = 0;
  PyObject *__pyx_v_region = 0;
  PyObject *__pyx_v_until_eof = 0;
  PyObject *__pyx_v_read_callback = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("count (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_reference,&__pyx_n_s_start,&__pyx_n_s_end,&__pyx_n_s_region,&__pyx_n_s_until_eof,&__pyx_n_s_read_callback,0};
    PyObject* values[6] = {0,0,0,0,0,0};

    /* "pysam/calignmentfile.pyx":1103
 * 
 *     def count(self,
 *               reference=None,             # <<<<<<<<<<<<<<
 *               start=None,
 *               end=None,
 */
    values[0] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":1104
 *     def count(self,
 *               reference=None,
 *               start=None,             # <<<<<<<<<<<<<<
 *               end=None,
 *               region=None,
 */
    values[1] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":1105
 *               reference=None,
 *               start=None,
 *               end=None,             # <<<<<<<<<<<<<<
 *               region=None,
 *               until_eof=False,
 */
    values[2] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":1106
 *               start=None,
 *               end=None,
 *               region=None,             # <<<<<<<<<<<<<<
 *               until_eof=False,
 *               read_callback="nofilter"):
 */
    values[3] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":1107
 *               end=None,
 *               region=None,
 *               until_eof=False,             # <<<<<<<<<<<<<<
 *               read_callback="nofilter"):
 *         '''count the number of reads in :term:`region`
 */
    values[4] = ((PyObject *)Py_False);
    values[5] = ((PyObject *)__pyx_n_s_nofilter);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_reference);
          if (value) { values[0] = value; kw_args--; }
        }
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_start);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_end);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_region);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_until_eof);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_read_callback);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "count") < 0)) __PYX_ERR(0, 1102, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_reference = values[0];
    __pyx_v_start = values[1];
    __pyx_v_end = values[2];
    __pyx_v_region = values[3];
    __pyx_v_until_eof = values[4];
    __pyx_v_read_callback = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("count", 0, 0, 6, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1102, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.count", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_30count(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self), __pyx_v_reference, __pyx_v_start, __pyx_v_end, __pyx_v_region, __pyx_v_until_eof, __pyx_v_read_callback);

  /* "pysam/calignmentfile.pyx":1102
 *                 "pileup of samfiles not implemented yet")
 * 
 *     def count(self,             # <<<<<<<<<<<<<<
 *               reference=None,
 *               start=None,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_30count(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_reference, PyObject *__pyx_v_start, PyObject *__pyx_v_end, PyObject *__pyx_v_region, PyObject *__pyx_v_until_eof, PyObject *__pyx_v_read_callback) {
  struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *__pyx_v_read = 0;
  long __pyx_v_counter;
  int __pyx_v_filter_method;
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  Py_ssize_t __pyx_t_6;
  PyObject *(*__pyx_t_7)(PyObject *);
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  __Pyx_RefNannySetupContext("count", 0);
  __Pyx_TraceCall("count", __pyx_f[0], 1102, 0, __PYX_ERR(0, 1102, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1162
 *         '''
 *         cdef AlignedSegment read
 *         cdef long counter = 0             # <<<<<<<<<<<<<<
 * 
 *         if not self.is_open():
 */
  __pyx_v_counter = 0;

  /* "pysam/calignmentfile.pyx":1164
 *         cdef long counter = 0
 * 
 *         if not self.is_open():             # <<<<<<<<<<<<<<
 *             raise ValueError( "I/O operation on closed file" )
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_open); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1164, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1164, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1164, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1164, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = ((!__pyx_t_4) != 0);
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":1165
 * 
 *         if not self.is_open():
 *             raise ValueError( "I/O operation on closed file" )             # <<<<<<<<<<<<<<
 * 
 *         cdef int filter_method = 0
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__34, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1165, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 1165, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":1164
 *         cdef long counter = 0
 * 
 *         if not self.is_open():             # <<<<<<<<<<<<<<
 *             raise ValueError( "I/O operation on closed file" )
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":1167
 *             raise ValueError( "I/O operation on closed file" )
 * 
 *         cdef int filter_method = 0             # <<<<<<<<<<<<<<
 *         if read_callback == "all":
 *             filter_method = 1
 */
  __pyx_v_filter_method = 0;

  /* "pysam/calignmentfile.pyx":1168
 * 
 *         cdef int filter_method = 0
 *         if read_callback == "all":             # <<<<<<<<<<<<<<
 *             filter_method = 1
 *         elif read_callback == "nofilter":
 */
  __pyx_t_5 = (__Pyx_PyString_Equals(__pyx_v_read_callback, __pyx_n_s_all, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1168, __pyx_L1_error)
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":1169
 *         cdef int filter_method = 0
 *         if read_callback == "all":
 *             filter_method = 1             # <<<<<<<<<<<<<<
 *         elif read_callback == "nofilter":
 *             filter_method = 2
 */
    __pyx_v_filter_method = 1;

    /* "pysam/calignmentfile.pyx":1168
 * 
 *         cdef int filter_method = 0
 *         if read_callback == "all":             # <<<<<<<<<<<<<<
 *             filter_method = 1
 *         elif read_callback == "nofilter":
 */
    goto __pyx_L4;
  }

  /* "pysam/calignmentfile.pyx":1170
 *         if read_callback == "all":
 *             filter_method = 1
 *         elif read_callback == "nofilter":             # <<<<<<<<<<<<<<
 *             filter_method = 2
 * 
 */
  __pyx_t_5 = (__Pyx_PyString_Equals(__pyx_v_read_callback, __pyx_n_s_nofilter, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1170, __pyx_L1_error)
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":1171
 *             filter_method = 1
 *         elif read_callback == "nofilter":
 *             filter_method = 2             # <<<<<<<<<<<<<<
 * 
 *         for read in self.fetch(reference=reference,
 */
    __pyx_v_filter_method = 2;

    /* "pysam/calignmentfile.pyx":1170
 *         if read_callback == "all":
 *             filter_method = 1
 *         elif read_callback == "nofilter":             # <<<<<<<<<<<<<<
 *             filter_method = 2
 * 
 */
  }
  __pyx_L4:;

  /* "pysam/calignmentfile.pyx":1173
 *             filter_method = 2
 * 
 *         for read in self.fetch(reference=reference,             # <<<<<<<<<<<<<<
 *                                start=start,
 *                                end=end,
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_fetch); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1173, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1173, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_reference, __pyx_v_reference) < 0) __PYX_ERR(0, 1173, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":1174
 * 
 *         for read in self.fetch(reference=reference,
 *                                start=start,             # <<<<<<<<<<<<<<
 *                                end=end,
 *                                region=region,
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_start, __pyx_v_start) < 0) __PYX_ERR(0, 1173, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":1175
 *         for read in self.fetch(reference=reference,
 *                                start=start,
 *                                end=end,             # <<<<<<<<<<<<<<
 *                                region=region,
 *                                until_eof=until_eof):
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_end, __pyx_v_end) < 0) __PYX_ERR(0, 1173, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":1176
 *                                start=start,
 *                                end=end,
 *                                region=region,             # <<<<<<<<<<<<<<
 *                                until_eof=until_eof):
 *             # apply filter
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_region, __pyx_v_region) < 0) __PYX_ERR(0, 1173, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":1177
 *                                end=end,
 *                                region=region,
 *                                until_eof=until_eof):             # <<<<<<<<<<<<<<
 *             # apply filter
 *             if filter_method == 1:
 */
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_until_eof, __pyx_v_until_eof) < 0) __PYX_ERR(0, 1173, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":1173
 *             filter_method = 2
 * 
 *         for read in self.fetch(reference=reference,             # <<<<<<<<<<<<<<
 *                                start=start,
 *                                end=end,
 */
  __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_empty_tuple, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1173, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (likely(PyList_CheckExact(__pyx_t_3)) || PyTuple_CheckExact(__pyx_t_3)) {
    __pyx_t_2 = __pyx_t_3; __Pyx_INCREF(__pyx_t_2); __pyx_t_6 = 0;
    __pyx_t_7 = NULL;
  } else {
    __pyx_t_6 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1173, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_7 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1173, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  for (;;) {
    if (likely(!__pyx_t_7)) {
      if (likely(PyList_CheckExact(__pyx_t_2))) {
        if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_2)) break;
        #if CYTHON_COMPILING_IN_CPYTHON
        __pyx_t_3 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_6); __Pyx_INCREF(__pyx_t_3); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 1173, __pyx_L1_error)
        #else
        __pyx_t_3 = PySequence_ITEM(__pyx_t_2, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1173, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        #endif
      } else {
        if (__pyx_t_6 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
        #if CYTHON_COMPILING_IN_CPYTHON
        __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_6); __Pyx_INCREF(__pyx_t_3); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 1173, __pyx_L1_error)
        #else
        __pyx_t_3 = PySequence_ITEM(__pyx_t_2, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1173, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        #endif
      }
    } else {
      __pyx_t_3 = __pyx_t_7(__pyx_t_2);
      if (unlikely(!__pyx_t_3)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 1173, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_3);
    }
    if (!(likely(((__pyx_t_3) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_3, __pyx_ptype_5pysam_15calignedsegment_AlignedSegment))))) __PYX_ERR(0, 1173, __pyx_L1_error)
    __Pyx_XDECREF_SET(__pyx_v_read, ((struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *)__pyx_t_3));
    __pyx_t_3 = 0;

    /* "pysam/calignmentfile.pyx":1179
 *                                until_eof=until_eof):
 *             # apply filter
 *             if filter_method == 1:             # <<<<<<<<<<<<<<
 *                 # filter = "all"
 *                 if (read.flag & (0x4 | 0x100 | 0x200 | 0x400)):
 */
    switch (__pyx_v_filter_method) {
      case 1:

      /* "pysam/calignmentfile.pyx":1181
 *             if filter_method == 1:
 *                 # filter = "all"
 *                 if (read.flag & (0x4 | 0x100 | 0x200 | 0x400)):             # <<<<<<<<<<<<<<
 *                     continue
 *             elif filter_method == 2:
 */
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_read), __pyx_n_s_flag); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1181, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_1 = __Pyx_PyInt_AndObjC(__pyx_t_3, __pyx_int_1796, 0x704, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1181, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1181, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (__pyx_t_5) {

        /* "pysam/calignmentfile.pyx":1182
 *                 # filter = "all"
 *                 if (read.flag & (0x4 | 0x100 | 0x200 | 0x400)):
 *                     continue             # <<<<<<<<<<<<<<
 *             elif filter_method == 2:
 *                 # filter = "nofilter"
 */
        goto __pyx_L5_continue;

        /* "pysam/calignmentfile.pyx":1181
 *             if filter_method == 1:
 *                 # filter = "all"
 *                 if (read.flag & (0x4 | 0x100 | 0x200 | 0x400)):             # <<<<<<<<<<<<<<
 *                     continue
 *             elif filter_method == 2:
 */
      }

      /* "pysam/calignmentfile.pyx":1179
 *                                until_eof=until_eof):
 *             # apply filter
 *             if filter_method == 1:             # <<<<<<<<<<<<<<
 *                 # filter = "all"
 *                 if (read.flag & (0x4 | 0x100 | 0x200 | 0x400)):
 */
      break;

      /* "pysam/calignmentfile.pyx":1183
 *                 if (read.flag & (0x4 | 0x100 | 0x200 | 0x400)):
 *                     continue
 *             elif filter_method == 2:             # <<<<<<<<<<<<<<
 *                 # filter = "nofilter"
 *                 pass
 */
      case 2:
      break;
      default:

      /* "pysam/calignmentfile.pyx":1187
 *                 pass
 *             else:
 *                 if not read_callback(read):             # <<<<<<<<<<<<<<
 *                     continue
 *             counter += 1
 */
      __Pyx_INCREF(__pyx_v_read_callback);
      __pyx_t_3 = __pyx_v_read_callback; __pyx_t_8 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_8)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_8);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (!__pyx_t_8) {
        __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, ((PyObject *)__pyx_v_read)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1187, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
      } else {
        __pyx_t_9 = PyTuple_New(1+1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1187, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_9);
        __Pyx_GIVEREF(__pyx_t_8); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_8); __pyx_t_8 = NULL;
        __Pyx_INCREF(((PyObject *)__pyx_v_read));
        __Pyx_GIVEREF(((PyObject *)__pyx_v_read));
        PyTuple_SET_ITEM(__pyx_t_9, 0+1, ((PyObject *)__pyx_v_read));
        __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_9, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1187, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      }
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1187, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __pyx_t_4 = ((!__pyx_t_5) != 0);
      if (__pyx_t_4) {

        /* "pysam/calignmentfile.pyx":1188
 *             else:
 *                 if not read_callback(read):
 *                     continue             # <<<<<<<<<<<<<<
 *             counter += 1
 * 
 */
        goto __pyx_L5_continue;

        /* "pysam/calignmentfile.pyx":1187
 *                 pass
 *             else:
 *                 if not read_callback(read):             # <<<<<<<<<<<<<<
 *                     continue
 *             counter += 1
 */
      }
      break;
    }

    /* "pysam/calignmentfile.pyx":1189
 *                 if not read_callback(read):
 *                     continue
 *             counter += 1             # <<<<<<<<<<<<<<
 * 
 *         return counter
 */
    __pyx_v_counter = (__pyx_v_counter + 1);

    /* "pysam/calignmentfile.pyx":1173
 *             filter_method = 2
 * 
 *         for read in self.fetch(reference=reference,             # <<<<<<<<<<<<<<
 *                                start=start,
 *                                end=end,
 */
    __pyx_L5_continue:;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

  /* "pysam/calignmentfile.pyx":1191
 *             counter += 1
 * 
 *         return counter             # <<<<<<<<<<<<<<
 * 
 *     @cython.boundscheck(False)  # we do manual bounds checking
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyInt_From_long(__pyx_v_counter); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1191, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1102
 *                 "pileup of samfiles not implemented yet")
 * 
 *     def count(self,             # <<<<<<<<<<<<<<
 *               reference=None,
 *               start=None,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.count", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_read);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1194
 * 
 *     @cython.boundscheck(False)  # we do manual bounds checking
 *     def count_coverage(self,             # <<<<<<<<<<<<<<
 *                        reference=None,
 *                        start=None,
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_33count_coverage(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_32count_coverage[] = "AlignmentFile.count_coverage(self, reference=None, start=None, end=None, region=None, quality_threshold=15, read_callback='all')\ncount the coverage of genomic positions by reads in :term:`region`.\n\n        The region is specified by :term:`reference`, `start` and\n        `end`. Alternatively, a :term:`samtools` :term:`region` string\n        can be supplied. The coverage is computed per-base [ACGT].\n\n        Parameters\n        ----------\n        \n        reference : string\n            reference_name of the genomic region (chromosome)\n\n        start : int\n            start of the genomic region\n\n        end : int\n            end of the genomic region\n\n        region : int\n            a region string.\n\n        quality_threshold : int\n            quality_threshold is the minimum quality score (in phred) a\n            base has to reach to be counted. \n\n        read_callback: string or function\n\n            select a call-back to ignore reads when counting. It can\n            be either a string with the following values:\n\n            ``all``\n                skip reads in which any of the following\n                flags are set: BAM_FUNMAP, BAM_FSECONDARY, BAM_FQCFAIL,\n                BAM_FDUP\n\n            ``nofilter``\n                uses every single read\n\n            Alternatively, `read_callback` can be a function\n            ``check_read(read)`` that should return True only for\n            those reads that shall be included in the counting.\n\n        Raises\n        ------\n\n        ValueError\n            if the genomic coordinates are out of range or invalid.\n\n        Returns\n        -------\n\n        four array.arrays of the same length in order A C G T : tuple\n\n        ";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_33count_coverage(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_reference = 0;
  PyObject *__pyx_v_start = 0;
  PyObject *__pyx_v_end = 0;
  PyObject *__pyx_v_region = 0;
  PyObject *__pyx_v_quality_threshold = 0;
  PyObject *__pyx_v_read_callback = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("count_coverage (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_reference,&__pyx_n_s_start,&__pyx_n_s_end,&__pyx_n_s_region,&__pyx_n_s_quality_threshold,&__pyx_n_s_read_callback,0};
    PyObject* values[6] = {0,0,0,0,0,0};

    /* "pysam/calignmentfile.pyx":1195
 *     @cython.boundscheck(False)  # we do manual bounds checking
 *     def count_coverage(self,
 *                        reference=None,             # <<<<<<<<<<<<<<
 *                        start=None,
 *                        end=None,
 */
    values[0] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":1196
 *     def count_coverage(self,
 *                        reference=None,
 *                        start=None,             # <<<<<<<<<<<<<<
 *                        end=None,
 *                        region=None,
 */
    values[1] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":1197
 *                        reference=None,
 *                        start=None,
 *                        end=None,             # <<<<<<<<<<<<<<
 *                        region=None,
 *                        quality_threshold=15,
 */
    values[2] = ((PyObject *)Py_None);

    /* "pysam/calignmentfile.pyx":1198
 *                        start=None,
 *                        end=None,
 *                        region=None,             # <<<<<<<<<<<<<<
 *                        quality_threshold=15,
 *                        read_callback='all'):
 */
    values[3] = ((PyObject *)Py_None);
    values[4] = ((PyObject *)__pyx_int_15);
    values[5] = ((PyObject *)__pyx_n_s_all);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_reference);
          if (value) { values[0] = value; kw_args--; }
        }
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_start);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_end);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_region);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_quality_threshold);
          if (value) { values[4] = value; kw_args--; }
        }
        case  5:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_read_callback);
          if (value) { values[5] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "count_coverage") < 0)) __PYX_ERR(0, 1194, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  6: values[5] = PyTuple_GET_ITEM(__pyx_args, 5);
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_reference = values[0];
    __pyx_v_start = values[1];
    __pyx_v_end = values[2];
    __pyx_v_region = values[3];
    __pyx_v_quality_threshold = values[4];
    __pyx_v_read_callback = values[5];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("count_coverage", 0, 0, 6, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1194, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.count_coverage", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_32count_coverage(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self), __pyx_v_reference, __pyx_v_start, __pyx_v_end, __pyx_v_region, __pyx_v_quality_threshold, __pyx_v_read_callback);

  /* "pysam/calignmentfile.pyx":1194
 * 
 *     @cython.boundscheck(False)  # we do manual bounds checking
 *     def count_coverage(self,             # <<<<<<<<<<<<<<
 *                        reference=None,
 *                        start=None,
 */

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_32count_coverage(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_reference, PyObject *__pyx_v_start, PyObject *__pyx_v_end, PyObject *__pyx_v_region, PyObject *__pyx_v_quality_threshold, PyObject *__pyx_v_read_callback) {
  int __pyx_v__start;
  int __pyx_v__stop;
  int __pyx_v_length;
  arrayobject *__pyx_v_int_array_template = 0;
  arrayobject *__pyx_v_count_a = 0;
  arrayobject *__pyx_v_count_c = 0;
  arrayobject *__pyx_v_count_g = 0;
  arrayobject *__pyx_v_count_t = 0;
  struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *__pyx_v_read = 0;
  PyObject *__pyx_v_seq = 0;
  arrayobject *__pyx_v_quality = 0;
  int __pyx_v_qpos;
  int __pyx_v_refpos;
  CYTHON_UNUSED int __pyx_v_c;
  int __pyx_v_filter_method;
  CYTHON_UNUSED int __pyx_v__threshold;
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  Py_ssize_t __pyx_t_6;
  PyObject *(*__pyx_t_7)(PyObject *);
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  int __pyx_t_10;
  Py_ssize_t __pyx_t_11;
  PyObject *(*__pyx_t_12)(PyObject *);
  PyObject *__pyx_t_13 = NULL;
  PyObject *(*__pyx_t_14)(PyObject *);
  int __pyx_t_15;
  int __pyx_t_16;
  __Pyx_RefNannySetupContext("count_coverage", 0);
  __Pyx_TraceCall("count_coverage", __pyx_f[0], 1194, 0, __PYX_ERR(0, 1194, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1256
 *         """
 * 
 *         cdef int _start = start             # <<<<<<<<<<<<<<
 *         cdef int _stop = end
 *         cdef int length = _stop - _start
 */
  __pyx_t_1 = __Pyx_PyInt_As_int(__pyx_v_start); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 1256, __pyx_L1_error)
  __pyx_v__start = __pyx_t_1;

  /* "pysam/calignmentfile.pyx":1257
 * 
 *         cdef int _start = start
 *         cdef int _stop = end             # <<<<<<<<<<<<<<
 *         cdef int length = _stop - _start
 *         cdef c_array.array int_array_template = array.array('L', [])
 */
  __pyx_t_1 = __Pyx_PyInt_As_int(__pyx_v_end); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 1257, __pyx_L1_error)
  __pyx_v__stop = __pyx_t_1;

  /* "pysam/calignmentfile.pyx":1258
 *         cdef int _start = start
 *         cdef int _stop = end
 *         cdef int length = _stop - _start             # <<<<<<<<<<<<<<
 *         cdef c_array.array int_array_template = array.array('L', [])
 *         cdef c_array.array count_a
 */
  __pyx_v_length = (__pyx_v__stop - __pyx_v__start);

  /* "pysam/calignmentfile.pyx":1259
 *         cdef int _stop = end
 *         cdef int length = _stop - _start
 *         cdef c_array.array int_array_template = array.array('L', [])             # <<<<<<<<<<<<<<
 *         cdef c_array.array count_a
 *         cdef c_array.array count_c
 */
  __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1259, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1259, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_n_s_L);
  __Pyx_GIVEREF(__pyx_n_s_L);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_n_s_L);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_2);
  __pyx_t_2 = 0;
  __pyx_t_2 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_7cpython_5array_array), __pyx_t_3, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1259, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_v_int_array_template = ((arrayobject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "pysam/calignmentfile.pyx":1264
 *         cdef c_array.array count_g
 *         cdef c_array.array count_t
 *         count_a = c_array.clone(int_array_template, length, zero=True)             # <<<<<<<<<<<<<<
 *         count_c = c_array.clone(int_array_template, length, zero=True)
 *         count_g = c_array.clone(int_array_template, length, zero=True)
 */
  __pyx_t_2 = ((PyObject *)__pyx_f_7cpython_5array_clone(__pyx_v_int_array_template, __pyx_v_length, 1)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1264, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_v_count_a = ((arrayobject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "pysam/calignmentfile.pyx":1265
 *         cdef c_array.array count_t
 *         count_a = c_array.clone(int_array_template, length, zero=True)
 *         count_c = c_array.clone(int_array_template, length, zero=True)             # <<<<<<<<<<<<<<
 *         count_g = c_array.clone(int_array_template, length, zero=True)
 *         count_t = c_array.clone(int_array_template, length, zero=True)
 */
  __pyx_t_2 = ((PyObject *)__pyx_f_7cpython_5array_clone(__pyx_v_int_array_template, __pyx_v_length, 1)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1265, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_v_count_c = ((arrayobject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "pysam/calignmentfile.pyx":1266
 *         count_a = c_array.clone(int_array_template, length, zero=True)
 *         count_c = c_array.clone(int_array_template, length, zero=True)
 *         count_g = c_array.clone(int_array_template, length, zero=True)             # <<<<<<<<<<<<<<
 *         count_t = c_array.clone(int_array_template, length, zero=True)
 * 
 */
  __pyx_t_2 = ((PyObject *)__pyx_f_7cpython_5array_clone(__pyx_v_int_array_template, __pyx_v_length, 1)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1266, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_v_count_g = ((arrayobject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "pysam/calignmentfile.pyx":1267
 *         count_c = c_array.clone(int_array_template, length, zero=True)
 *         count_g = c_array.clone(int_array_template, length, zero=True)
 *         count_t = c_array.clone(int_array_template, length, zero=True)             # <<<<<<<<<<<<<<
 * 
 *         cdef AlignedSegment read
 */
  __pyx_t_2 = ((PyObject *)__pyx_f_7cpython_5array_clone(__pyx_v_int_array_template, __pyx_v_length, 1)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1267, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_v_count_t = ((arrayobject *)__pyx_t_2);
  __pyx_t_2 = 0;

  /* "pysam/calignmentfile.pyx":1274
 *         cdef int qpos
 *         cdef int refpos
 *         cdef int c = 0             # <<<<<<<<<<<<<<
 *         cdef int filter_method = 0
 *         if read_callback == "all":
 */
  __pyx_v_c = 0;

  /* "pysam/calignmentfile.pyx":1275
 *         cdef int refpos
 *         cdef int c = 0
 *         cdef int filter_method = 0             # <<<<<<<<<<<<<<
 *         if read_callback == "all":
 *             filter_method = 1
 */
  __pyx_v_filter_method = 0;

  /* "pysam/calignmentfile.pyx":1276
 *         cdef int c = 0
 *         cdef int filter_method = 0
 *         if read_callback == "all":             # <<<<<<<<<<<<<<
 *             filter_method = 1
 *         elif read_callback == "nofilter":
 */
  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_read_callback, __pyx_n_s_all, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1276, __pyx_L1_error)
  if (__pyx_t_4) {

    /* "pysam/calignmentfile.pyx":1277
 *         cdef int filter_method = 0
 *         if read_callback == "all":
 *             filter_method = 1             # <<<<<<<<<<<<<<
 *         elif read_callback == "nofilter":
 *             filter_method = 2
 */
    __pyx_v_filter_method = 1;

    /* "pysam/calignmentfile.pyx":1276
 *         cdef int c = 0
 *         cdef int filter_method = 0
 *         if read_callback == "all":             # <<<<<<<<<<<<<<
 *             filter_method = 1
 *         elif read_callback == "nofilter":
 */
    goto __pyx_L3;
  }

  /* "pysam/calignmentfile.pyx":1278
 *         if read_callback == "all":
 *             filter_method = 1
 *         elif read_callback == "nofilter":             # <<<<<<<<<<<<<<
 *             filter_method = 2
 * 
 */
  __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_read_callback, __pyx_n_s_nofilter, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1278, __pyx_L1_error)
  if (__pyx_t_4) {

    /* "pysam/calignmentfile.pyx":1279
 *             filter_method = 1
 *         elif read_callback == "nofilter":
 *             filter_method = 2             # <<<<<<<<<<<<<<
 * 
 *         cdef int _threshold = quality_threshold
 */
    __pyx_v_filter_method = 2;

    /* "pysam/calignmentfile.pyx":1278
 *         if read_callback == "all":
 *             filter_method = 1
 *         elif read_callback == "nofilter":             # <<<<<<<<<<<<<<
 *             filter_method = 2
 * 
 */
  }
  __pyx_L3:;

  /* "pysam/calignmentfile.pyx":1281
 *             filter_method = 2
 * 
 *         cdef int _threshold = quality_threshold             # <<<<<<<<<<<<<<
 *         for read in self.fetch(reference=reference,
 *                                start=start,
 */
  __pyx_t_1 = __Pyx_PyInt_As_int(__pyx_v_quality_threshold); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 1281, __pyx_L1_error)
  __pyx_v__threshold = __pyx_t_1;

  /* "pysam/calignmentfile.pyx":1282
 * 
 *         cdef int _threshold = quality_threshold
 *         for read in self.fetch(reference=reference,             # <<<<<<<<<<<<<<
 *                                start=start,
 *                                end=end,
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_fetch); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1282, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1282, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_reference, __pyx_v_reference) < 0) __PYX_ERR(0, 1282, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":1283
 *         cdef int _threshold = quality_threshold
 *         for read in self.fetch(reference=reference,
 *                                start=start,             # <<<<<<<<<<<<<<
 *                                end=end,
 *                                region=region):
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_start, __pyx_v_start) < 0) __PYX_ERR(0, 1282, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":1284
 *         for read in self.fetch(reference=reference,
 *                                start=start,
 *                                end=end,             # <<<<<<<<<<<<<<
 *                                region=region):
 *             # apply filter
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_end, __pyx_v_end) < 0) __PYX_ERR(0, 1282, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":1285
 *                                start=start,
 *                                end=end,
 *                                region=region):             # <<<<<<<<<<<<<<
 *             # apply filter
 *             if filter_method == 1:
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_region, __pyx_v_region) < 0) __PYX_ERR(0, 1282, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":1282
 * 
 *         cdef int _threshold = quality_threshold
 *         for read in self.fetch(reference=reference,             # <<<<<<<<<<<<<<
 *                                start=start,
 *                                end=end,
 */
  __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_empty_tuple, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1282, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (likely(PyList_CheckExact(__pyx_t_5)) || PyTuple_CheckExact(__pyx_t_5)) {
    __pyx_t_3 = __pyx_t_5; __Pyx_INCREF(__pyx_t_3); __pyx_t_6 = 0;
    __pyx_t_7 = NULL;
  } else {
    __pyx_t_6 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1282, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_7 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1282, __pyx_L1_error)
  }
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  for (;;) {
    if (likely(!__pyx_t_7)) {
      if (likely(PyList_CheckExact(__pyx_t_3))) {
        if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_3)) break;
        #if CYTHON_COMPILING_IN_CPYTHON
        __pyx_t_5 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_6); __Pyx_INCREF(__pyx_t_5); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 1282, __pyx_L1_error)
        #else
        __pyx_t_5 = PySequence_ITEM(__pyx_t_3, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1282, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        #endif
      } else {
        if (__pyx_t_6 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
        #if CYTHON_COMPILING_IN_CPYTHON
        __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_6); __Pyx_INCREF(__pyx_t_5); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 1282, __pyx_L1_error)
        #else
        __pyx_t_5 = PySequence_ITEM(__pyx_t_3, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1282, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        #endif
      }
    } else {
      __pyx_t_5 = __pyx_t_7(__pyx_t_3);
      if (unlikely(!__pyx_t_5)) {
        PyObject* exc_type = PyErr_Occurred();
        if (exc_type) {
          if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
          else __PYX_ERR(0, 1282, __pyx_L1_error)
        }
        break;
      }
      __Pyx_GOTREF(__pyx_t_5);
    }
    if (!(likely(((__pyx_t_5) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_5, __pyx_ptype_5pysam_15calignedsegment_AlignedSegment))))) __PYX_ERR(0, 1282, __pyx_L1_error)
    __Pyx_XDECREF_SET(__pyx_v_read, ((struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *)__pyx_t_5));
    __pyx_t_5 = 0;

    /* "pysam/calignmentfile.pyx":1287
 *                                region=region):
 *             # apply filter
 *             if filter_method == 1:             # <<<<<<<<<<<<<<
 *                 # filter = "all"
 *                 if (read.flag & (0x4 | 0x100 | 0x200 | 0x400)):
 */
    switch (__pyx_v_filter_method) {
      case 1:

      /* "pysam/calignmentfile.pyx":1289
 *             if filter_method == 1:
 *                 # filter = "all"
 *                 if (read.flag & (0x4 | 0x100 | 0x200 | 0x400)):             # <<<<<<<<<<<<<<
 *                     continue
 *             elif filter_method == 2:
 */
      __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_read), __pyx_n_s_flag); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1289, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_2 = __Pyx_PyInt_AndObjC(__pyx_t_5, __pyx_int_1796, 0x704, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1289, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1289, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      if (__pyx_t_4) {

        /* "pysam/calignmentfile.pyx":1290
 *                 # filter = "all"
 *                 if (read.flag & (0x4 | 0x100 | 0x200 | 0x400)):
 *                     continue             # <<<<<<<<<<<<<<
 *             elif filter_method == 2:
 *                 # filter = "nofilter"
 */
        goto __pyx_L4_continue;

        /* "pysam/calignmentfile.pyx":1289
 *             if filter_method == 1:
 *                 # filter = "all"
 *                 if (read.flag & (0x4 | 0x100 | 0x200 | 0x400)):             # <<<<<<<<<<<<<<
 *                     continue
 *             elif filter_method == 2:
 */
      }

      /* "pysam/calignmentfile.pyx":1287
 *                                region=region):
 *             # apply filter
 *             if filter_method == 1:             # <<<<<<<<<<<<<<
 *                 # filter = "all"
 *                 if (read.flag & (0x4 | 0x100 | 0x200 | 0x400)):
 */
      break;

      /* "pysam/calignmentfile.pyx":1291
 *                 if (read.flag & (0x4 | 0x100 | 0x200 | 0x400)):
 *                     continue
 *             elif filter_method == 2:             # <<<<<<<<<<<<<<
 *                 # filter = "nofilter"
 *                 pass
 */
      case 2:
      break;
      default:

      /* "pysam/calignmentfile.pyx":1295
 *                 pass
 *             else:
 *                 if not read_callback(read):             # <<<<<<<<<<<<<<
 *                     continue
 * 
 */
      __Pyx_INCREF(__pyx_v_read_callback);
      __pyx_t_5 = __pyx_v_read_callback; __pyx_t_8 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_5))) {
        __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_5);
        if (likely(__pyx_t_8)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_5);
          __Pyx_INCREF(__pyx_t_8);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_5, function);
        }
      }
      if (!__pyx_t_8) {
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_5, ((PyObject *)__pyx_v_read)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1295, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
      } else {
        __pyx_t_9 = PyTuple_New(1+1); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1295, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_9);
        __Pyx_GIVEREF(__pyx_t_8); PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_8); __pyx_t_8 = NULL;
        __Pyx_INCREF(((PyObject *)__pyx_v_read));
        __Pyx_GIVEREF(((PyObject *)__pyx_v_read));
        PyTuple_SET_ITEM(__pyx_t_9, 0+1, ((PyObject *)__pyx_v_read));
        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_5, __pyx_t_9, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1295, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      }
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1295, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_10 = ((!__pyx_t_4) != 0);
      if (__pyx_t_10) {

        /* "pysam/calignmentfile.pyx":1296
 *             else:
 *                 if not read_callback(read):
 *                     continue             # <<<<<<<<<<<<<<
 * 
 *             # count
 */
        goto __pyx_L4_continue;

        /* "pysam/calignmentfile.pyx":1295
 *                 pass
 *             else:
 *                 if not read_callback(read):             # <<<<<<<<<<<<<<
 *                     continue
 * 
 */
      }
      break;
    }

    /* "pysam/calignmentfile.pyx":1299
 * 
 *             # count
 *             seq = read.seq             # <<<<<<<<<<<<<<
 *             quality = read.query_qualities
 *             for qpos, refpos in read.get_aligned_pairs(True):
 */
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_read), __pyx_n_s_seq); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1299, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(PyString_CheckExact(__pyx_t_2))||((__pyx_t_2) == Py_None)||(PyErr_Format(PyExc_TypeError, "Expected %.16s, got %.200s", "str", Py_TYPE(__pyx_t_2)->tp_name), 0))) __PYX_ERR(0, 1299, __pyx_L1_error)
    __Pyx_XDECREF_SET(__pyx_v_seq, ((PyObject*)__pyx_t_2));
    __pyx_t_2 = 0;

    /* "pysam/calignmentfile.pyx":1300
 *             # count
 *             seq = read.seq
 *             quality = read.query_qualities             # <<<<<<<<<<<<<<
 *             for qpos, refpos in read.get_aligned_pairs(True):
 *                 if qpos is not None and refpos is not None and \
 */
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_read), __pyx_n_s_query_qualities); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1300, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    if (!(likely(((__pyx_t_2) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_2, __pyx_ptype_7cpython_5array_array))))) __PYX_ERR(0, 1300, __pyx_L1_error)
    __Pyx_XDECREF_SET(__pyx_v_quality, ((arrayobject *)__pyx_t_2));
    __pyx_t_2 = 0;

    /* "pysam/calignmentfile.pyx":1301
 *             seq = read.seq
 *             quality = read.query_qualities
 *             for qpos, refpos in read.get_aligned_pairs(True):             # <<<<<<<<<<<<<<
 *                 if qpos is not None and refpos is not None and \
 *                    _start <= refpos < _stop:
 */
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_read), __pyx_n_s_get_aligned_pairs); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1301, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__35, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1301, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    if (likely(PyList_CheckExact(__pyx_t_5)) || PyTuple_CheckExact(__pyx_t_5)) {
      __pyx_t_2 = __pyx_t_5; __Pyx_INCREF(__pyx_t_2); __pyx_t_11 = 0;
      __pyx_t_12 = NULL;
    } else {
      __pyx_t_11 = -1; __pyx_t_2 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1301, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_12 = Py_TYPE(__pyx_t_2)->tp_iternext; if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 1301, __pyx_L1_error)
    }
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    for (;;) {
      if (likely(!__pyx_t_12)) {
        if (likely(PyList_CheckExact(__pyx_t_2))) {
          if (__pyx_t_11 >= PyList_GET_SIZE(__pyx_t_2)) break;
          #if CYTHON_COMPILING_IN_CPYTHON
          __pyx_t_5 = PyList_GET_ITEM(__pyx_t_2, __pyx_t_11); __Pyx_INCREF(__pyx_t_5); __pyx_t_11++; if (unlikely(0 < 0)) __PYX_ERR(0, 1301, __pyx_L1_error)
          #else
          __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_11); __pyx_t_11++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1301, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_5);
          #endif
        } else {
          if (__pyx_t_11 >= PyTuple_GET_SIZE(__pyx_t_2)) break;
          #if CYTHON_COMPILING_IN_CPYTHON
          __pyx_t_5 = PyTuple_GET_ITEM(__pyx_t_2, __pyx_t_11); __Pyx_INCREF(__pyx_t_5); __pyx_t_11++; if (unlikely(0 < 0)) __PYX_ERR(0, 1301, __pyx_L1_error)
          #else
          __pyx_t_5 = PySequence_ITEM(__pyx_t_2, __pyx_t_11); __pyx_t_11++; if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1301, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_5);
          #endif
        }
      } else {
        __pyx_t_5 = __pyx_t_12(__pyx_t_2);
        if (unlikely(!__pyx_t_5)) {
          PyObject* exc_type = PyErr_Occurred();
          if (exc_type) {
            if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
            else __PYX_ERR(0, 1301, __pyx_L1_error)
          }
          break;
        }
        __Pyx_GOTREF(__pyx_t_5);
      }
      if ((likely(PyTuple_CheckExact(__pyx_t_5))) || (PyList_CheckExact(__pyx_t_5))) {
        PyObject* sequence = __pyx_t_5;
        #if CYTHON_COMPILING_IN_CPYTHON
        Py_ssize_t size = Py_SIZE(sequence);
        #else
        Py_ssize_t size = PySequence_Size(sequence);
        #endif
        if (unlikely(size != 2)) {
          if (size > 2) __Pyx_RaiseTooManyValuesError(2);
          else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
          __PYX_ERR(0, 1301, __pyx_L1_error)
        }
        #if CYTHON_COMPILING_IN_CPYTHON
        if (likely(PyTuple_CheckExact(sequence))) {
          __pyx_t_9 = PyTuple_GET_ITEM(sequence, 0); 
          __pyx_t_8 = PyTuple_GET_ITEM(sequence, 1); 
        } else {
          __pyx_t_9 = PyList_GET_ITEM(sequence, 0); 
          __pyx_t_8 = PyList_GET_ITEM(sequence, 1); 
        }
        __Pyx_INCREF(__pyx_t_9);
        __Pyx_INCREF(__pyx_t_8);
        #else
        __pyx_t_9 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 1301, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_9);
        __pyx_t_8 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1301, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_8);
        #endif
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      } else {
        Py_ssize_t index = -1;
        __pyx_t_13 = PyObject_GetIter(__pyx_t_5); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 1301, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_13);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __pyx_t_14 = Py_TYPE(__pyx_t_13)->tp_iternext;
        index = 0; __pyx_t_9 = __pyx_t_14(__pyx_t_13); if (unlikely(!__pyx_t_9)) goto __pyx_L10_unpacking_failed;
        __Pyx_GOTREF(__pyx_t_9);
        index = 1; __pyx_t_8 = __pyx_t_14(__pyx_t_13); if (unlikely(!__pyx_t_8)) goto __pyx_L10_unpacking_failed;
        __Pyx_GOTREF(__pyx_t_8);
        if (__Pyx_IternextUnpackEndCheck(__pyx_t_14(__pyx_t_13), 2) < 0) __PYX_ERR(0, 1301, __pyx_L1_error)
        __pyx_t_14 = NULL;
        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
        goto __pyx_L11_unpacking_done;
        __pyx_L10_unpacking_failed:;
        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
        __pyx_t_14 = NULL;
        if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
        __PYX_ERR(0, 1301, __pyx_L1_error)
        __pyx_L11_unpacking_done:;
      }
      __pyx_t_1 = __Pyx_PyInt_As_int(__pyx_t_9); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 1301, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
      __pyx_t_15 = __Pyx_PyInt_As_int(__pyx_t_8); if (unlikely((__pyx_t_15 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 1301, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __pyx_v_qpos = __pyx_t_1;
      __pyx_v_refpos = __pyx_t_15;

      /* "pysam/calignmentfile.pyx":1302
 *             quality = read.query_qualities
 *             for qpos, refpos in read.get_aligned_pairs(True):
 *                 if qpos is not None and refpos is not None and \             # <<<<<<<<<<<<<<
 *                    _start <= refpos < _stop:
 *                     if quality[qpos] >= quality_threshold:
 */
      __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_qpos); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1302, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_4 = (__pyx_t_5 != Py_None);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_16 = (__pyx_t_4 != 0);
      if (__pyx_t_16) {
      } else {
        __pyx_t_10 = __pyx_t_16;
        goto __pyx_L13_bool_binop_done;
      }
      __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_refpos); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1302, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_16 = (__pyx_t_5 != Py_None);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_4 = (__pyx_t_16 != 0);
      if (__pyx_t_4) {
      } else {
        __pyx_t_10 = __pyx_t_4;
        goto __pyx_L13_bool_binop_done;
      }

      /* "pysam/calignmentfile.pyx":1303
 *             for qpos, refpos in read.get_aligned_pairs(True):
 *                 if qpos is not None and refpos is not None and \
 *                    _start <= refpos < _stop:             # <<<<<<<<<<<<<<
 *                     if quality[qpos] >= quality_threshold:
 *                         if seq[qpos] == 'A':
 */
      __pyx_t_4 = (__pyx_v__start <= __pyx_v_refpos);
      if (__pyx_t_4) {
        __pyx_t_4 = (__pyx_v_refpos < __pyx_v__stop);
      }
      __pyx_t_16 = (__pyx_t_4 != 0);
      __pyx_t_10 = __pyx_t_16;
      __pyx_L13_bool_binop_done:;

      /* "pysam/calignmentfile.pyx":1302
 *             quality = read.query_qualities
 *             for qpos, refpos in read.get_aligned_pairs(True):
 *                 if qpos is not None and refpos is not None and \             # <<<<<<<<<<<<<<
 *                    _start <= refpos < _stop:
 *                     if quality[qpos] >= quality_threshold:
 */
      if (__pyx_t_10) {

        /* "pysam/calignmentfile.pyx":1304
 *                 if qpos is not None and refpos is not None and \
 *                    _start <= refpos < _stop:
 *                     if quality[qpos] >= quality_threshold:             # <<<<<<<<<<<<<<
 *                         if seq[qpos] == 'A':
 *                             count_a.data.as_ulongs[refpos - _start] += 1
 */
        __pyx_t_5 = __Pyx_GetItemInt(((PyObject *)__pyx_v_quality), __pyx_v_qpos, int, 1, __Pyx_PyInt_From_int, 0, 1, 0); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1304, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __pyx_t_8 = PyObject_RichCompare(__pyx_t_5, __pyx_v_quality_threshold, Py_GE); __Pyx_XGOTREF(__pyx_t_8); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1304, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
        __pyx_t_10 = __Pyx_PyObject_IsTrue(__pyx_t_8); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 1304, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
        if (__pyx_t_10) {

          /* "pysam/calignmentfile.pyx":1305
 *                    _start <= refpos < _stop:
 *                     if quality[qpos] >= quality_threshold:
 *                         if seq[qpos] == 'A':             # <<<<<<<<<<<<<<
 *                             count_a.data.as_ulongs[refpos - _start] += 1
 *                         if seq[qpos] == 'C':
 */
          __pyx_t_8 = __Pyx_GetItemInt(__pyx_v_seq, __pyx_v_qpos, int, 1, __Pyx_PyInt_From_int, 0, 1, 0); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1305, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_8);
          __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_8, __pyx_n_s_A, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 1305, __pyx_L1_error)
          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
          if (__pyx_t_10) {

            /* "pysam/calignmentfile.pyx":1306
 *                     if quality[qpos] >= quality_threshold:
 *                         if seq[qpos] == 'A':
 *                             count_a.data.as_ulongs[refpos - _start] += 1             # <<<<<<<<<<<<<<
 *                         if seq[qpos] == 'C':
 *                             count_c.data.as_ulongs[refpos - _start] += 1
 */
            __pyx_t_15 = (__pyx_v_refpos - __pyx_v__start);
            (__pyx_v_count_a->data.as_ulongs[__pyx_t_15]) = ((__pyx_v_count_a->data.as_ulongs[__pyx_t_15]) + 1);

            /* "pysam/calignmentfile.pyx":1305
 *                    _start <= refpos < _stop:
 *                     if quality[qpos] >= quality_threshold:
 *                         if seq[qpos] == 'A':             # <<<<<<<<<<<<<<
 *                             count_a.data.as_ulongs[refpos - _start] += 1
 *                         if seq[qpos] == 'C':
 */
          }

          /* "pysam/calignmentfile.pyx":1307
 *                         if seq[qpos] == 'A':
 *                             count_a.data.as_ulongs[refpos - _start] += 1
 *                         if seq[qpos] == 'C':             # <<<<<<<<<<<<<<
 *                             count_c.data.as_ulongs[refpos - _start] += 1
 *                         if seq[qpos] == 'G':
 */
          __pyx_t_8 = __Pyx_GetItemInt(__pyx_v_seq, __pyx_v_qpos, int, 1, __Pyx_PyInt_From_int, 0, 1, 0); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1307, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_8);
          __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_8, __pyx_n_s_C, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 1307, __pyx_L1_error)
          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
          if (__pyx_t_10) {

            /* "pysam/calignmentfile.pyx":1308
 *                             count_a.data.as_ulongs[refpos - _start] += 1
 *                         if seq[qpos] == 'C':
 *                             count_c.data.as_ulongs[refpos - _start] += 1             # <<<<<<<<<<<<<<
 *                         if seq[qpos] == 'G':
 *                             count_g.data.as_ulongs[refpos - _start] += 1
 */
            __pyx_t_15 = (__pyx_v_refpos - __pyx_v__start);
            (__pyx_v_count_c->data.as_ulongs[__pyx_t_15]) = ((__pyx_v_count_c->data.as_ulongs[__pyx_t_15]) + 1);

            /* "pysam/calignmentfile.pyx":1307
 *                         if seq[qpos] == 'A':
 *                             count_a.data.as_ulongs[refpos - _start] += 1
 *                         if seq[qpos] == 'C':             # <<<<<<<<<<<<<<
 *                             count_c.data.as_ulongs[refpos - _start] += 1
 *                         if seq[qpos] == 'G':
 */
          }

          /* "pysam/calignmentfile.pyx":1309
 *                         if seq[qpos] == 'C':
 *                             count_c.data.as_ulongs[refpos - _start] += 1
 *                         if seq[qpos] == 'G':             # <<<<<<<<<<<<<<
 *                             count_g.data.as_ulongs[refpos - _start] += 1
 *                         if seq[qpos] == 'T':
 */
          __pyx_t_8 = __Pyx_GetItemInt(__pyx_v_seq, __pyx_v_qpos, int, 1, __Pyx_PyInt_From_int, 0, 1, 0); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1309, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_8);
          __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_8, __pyx_n_s_G, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 1309, __pyx_L1_error)
          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
          if (__pyx_t_10) {

            /* "pysam/calignmentfile.pyx":1310
 *                             count_c.data.as_ulongs[refpos - _start] += 1
 *                         if seq[qpos] == 'G':
 *                             count_g.data.as_ulongs[refpos - _start] += 1             # <<<<<<<<<<<<<<
 *                         if seq[qpos] == 'T':
 *                             count_t.data.as_ulongs[refpos - _start] += 1
 */
            __pyx_t_15 = (__pyx_v_refpos - __pyx_v__start);
            (__pyx_v_count_g->data.as_ulongs[__pyx_t_15]) = ((__pyx_v_count_g->data.as_ulongs[__pyx_t_15]) + 1);

            /* "pysam/calignmentfile.pyx":1309
 *                         if seq[qpos] == 'C':
 *                             count_c.data.as_ulongs[refpos - _start] += 1
 *                         if seq[qpos] == 'G':             # <<<<<<<<<<<<<<
 *                             count_g.data.as_ulongs[refpos - _start] += 1
 *                         if seq[qpos] == 'T':
 */
          }

          /* "pysam/calignmentfile.pyx":1311
 *                         if seq[qpos] == 'G':
 *                             count_g.data.as_ulongs[refpos - _start] += 1
 *                         if seq[qpos] == 'T':             # <<<<<<<<<<<<<<
 *                             count_t.data.as_ulongs[refpos - _start] += 1
 * 
 */
          __pyx_t_8 = __Pyx_GetItemInt(__pyx_v_seq, __pyx_v_qpos, int, 1, __Pyx_PyInt_From_int, 0, 1, 0); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1311, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_8);
          __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_t_8, __pyx_n_s_T, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 1311, __pyx_L1_error)
          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
          if (__pyx_t_10) {

            /* "pysam/calignmentfile.pyx":1312
 *                             count_g.data.as_ulongs[refpos - _start] += 1
 *                         if seq[qpos] == 'T':
 *                             count_t.data.as_ulongs[refpos - _start] += 1             # <<<<<<<<<<<<<<
 * 
 *         return count_a, count_c, count_g, count_t
 */
            __pyx_t_15 = (__pyx_v_refpos - __pyx_v__start);
            (__pyx_v_count_t->data.as_ulongs[__pyx_t_15]) = ((__pyx_v_count_t->data.as_ulongs[__pyx_t_15]) + 1);

            /* "pysam/calignmentfile.pyx":1311
 *                         if seq[qpos] == 'G':
 *                             count_g.data.as_ulongs[refpos - _start] += 1
 *                         if seq[qpos] == 'T':             # <<<<<<<<<<<<<<
 *                             count_t.data.as_ulongs[refpos - _start] += 1
 * 
 */
          }

          /* "pysam/calignmentfile.pyx":1304
 *                 if qpos is not None and refpos is not None and \
 *                    _start <= refpos < _stop:
 *                     if quality[qpos] >= quality_threshold:             # <<<<<<<<<<<<<<
 *                         if seq[qpos] == 'A':
 *                             count_a.data.as_ulongs[refpos - _start] += 1
 */
        }

        /* "pysam/calignmentfile.pyx":1302
 *             quality = read.query_qualities
 *             for qpos, refpos in read.get_aligned_pairs(True):
 *                 if qpos is not None and refpos is not None and \             # <<<<<<<<<<<<<<
 *                    _start <= refpos < _stop:
 *                     if quality[qpos] >= quality_threshold:
 */
      }

      /* "pysam/calignmentfile.pyx":1301
 *             seq = read.seq
 *             quality = read.query_qualities
 *             for qpos, refpos in read.get_aligned_pairs(True):             # <<<<<<<<<<<<<<
 *                 if qpos is not None and refpos is not None and \
 *                    _start <= refpos < _stop:
 */
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

    /* "pysam/calignmentfile.pyx":1282
 * 
 *         cdef int _threshold = quality_threshold
 *         for read in self.fetch(reference=reference,             # <<<<<<<<<<<<<<
 *                                start=start,
 *                                end=end,
 */
    __pyx_L4_continue:;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "pysam/calignmentfile.pyx":1314
 *                             count_t.data.as_ulongs[refpos - _start] += 1
 * 
 *         return count_a, count_c, count_g, count_t             # <<<<<<<<<<<<<<
 * 
 *     def close(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = PyTuple_New(4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1314, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(((PyObject *)__pyx_v_count_a));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_count_a));
  PyTuple_SET_ITEM(__pyx_t_3, 0, ((PyObject *)__pyx_v_count_a));
  __Pyx_INCREF(((PyObject *)__pyx_v_count_c));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_count_c));
  PyTuple_SET_ITEM(__pyx_t_3, 1, ((PyObject *)__pyx_v_count_c));
  __Pyx_INCREF(((PyObject *)__pyx_v_count_g));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_count_g));
  PyTuple_SET_ITEM(__pyx_t_3, 2, ((PyObject *)__pyx_v_count_g));
  __Pyx_INCREF(((PyObject *)__pyx_v_count_t));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_count_t));
  PyTuple_SET_ITEM(__pyx_t_3, 3, ((PyObject *)__pyx_v_count_t));
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1194
 * 
 *     @cython.boundscheck(False)  # we do manual bounds checking
 *     def count_coverage(self,             # <<<<<<<<<<<<<<
 *                        reference=None,
 *                        start=None,
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_XDECREF(__pyx_t_13);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.count_coverage", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_int_array_template);
  __Pyx_XDECREF((PyObject *)__pyx_v_count_a);
  __Pyx_XDECREF((PyObject *)__pyx_v_count_c);
  __Pyx_XDECREF((PyObject *)__pyx_v_count_g);
  __Pyx_XDECREF((PyObject *)__pyx_v_count_t);
  __Pyx_XDECREF((PyObject *)__pyx_v_read);
  __Pyx_XDECREF(__pyx_v_seq);
  __Pyx_XDECREF((PyObject *)__pyx_v_quality);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1316
 *         return count_a, count_c, count_g, count_t
 * 
 *     def close(self):             # <<<<<<<<<<<<<<
 *         '''
 *         closes the :class:`pysam.AlignmentFile`.'''
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_35close(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_34close[] = "AlignmentFile.close(self)\n\n        closes the :class:`pysam.AlignmentFile`.";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_35close(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("close (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_34close(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_34close(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("close", 0);
  __Pyx_TraceCall("close", __pyx_f[0], 1316, 0, __PYX_ERR(0, 1316, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1319
 *         '''
 *         closes the :class:`pysam.AlignmentFile`.'''
 *         if self.htsfile != NULL:             # <<<<<<<<<<<<<<
 *             hts_close(self.htsfile)
 *             hts_idx_destroy(self.index);
 */
  __pyx_t_1 = ((__pyx_v_self->htsfile != NULL) != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":1320
 *         closes the :class:`pysam.AlignmentFile`.'''
 *         if self.htsfile != NULL:
 *             hts_close(self.htsfile)             # <<<<<<<<<<<<<<
 *             hts_idx_destroy(self.index);
 *             self.htsfile = NULL
 */
    hts_close(__pyx_v_self->htsfile);

    /* "pysam/calignmentfile.pyx":1321
 *         if self.htsfile != NULL:
 *             hts_close(self.htsfile)
 *             hts_idx_destroy(self.index);             # <<<<<<<<<<<<<<
 *             self.htsfile = NULL
 * 
 */
    hts_idx_destroy(__pyx_v_self->index);

    /* "pysam/calignmentfile.pyx":1322
 *             hts_close(self.htsfile)
 *             hts_idx_destroy(self.index);
 *             self.htsfile = NULL             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
    __pyx_v_self->htsfile = NULL;

    /* "pysam/calignmentfile.pyx":1319
 *         '''
 *         closes the :class:`pysam.AlignmentFile`.'''
 *         if self.htsfile != NULL:             # <<<<<<<<<<<<<<
 *             hts_close(self.htsfile)
 *             hts_idx_destroy(self.index);
 */
  }

  /* "pysam/calignmentfile.pyx":1316
 *         return count_a, count_c, count_g, count_t
 * 
 *     def close(self):             # <<<<<<<<<<<<<<
 *         '''
 *         closes the :class:`pysam.AlignmentFile`.'''
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.close", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1324
 *             self.htsfile = NULL
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         # remember: dealloc cannot call other methods
 *         # note: no doc string
 */

/* Python wrapper */
static void __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_37__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_37__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_36__dealloc__(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_36__dealloc__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("__dealloc__", 0);
  __Pyx_TraceCall("__dealloc__", __pyx_f[0], 1324, 0, __PYX_ERR(0, 1324, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1336
 *         # it seems to be dangerous according to the documentation as the
 *         # object be partially deconstructed already.
 *         if self.htsfile != NULL:             # <<<<<<<<<<<<<<
 *             hts_close(self.htsfile)
 *             hts_idx_destroy(self.index);
 */
  __pyx_t_1 = ((__pyx_v_self->htsfile != NULL) != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":1337
 *         # object be partially deconstructed already.
 *         if self.htsfile != NULL:
 *             hts_close(self.htsfile)             # <<<<<<<<<<<<<<
 *             hts_idx_destroy(self.index);
 *             self.htsfile = NULL
 */
    hts_close(__pyx_v_self->htsfile);

    /* "pysam/calignmentfile.pyx":1338
 *         if self.htsfile != NULL:
 *             hts_close(self.htsfile)
 *             hts_idx_destroy(self.index);             # <<<<<<<<<<<<<<
 *             self.htsfile = NULL
 * 
 */
    hts_idx_destroy(__pyx_v_self->index);

    /* "pysam/calignmentfile.pyx":1339
 *             hts_close(self.htsfile)
 *             hts_idx_destroy(self.index);
 *             self.htsfile = NULL             # <<<<<<<<<<<<<<
 * 
 *         bam_destroy1(self.b)
 */
    __pyx_v_self->htsfile = NULL;

    /* "pysam/calignmentfile.pyx":1336
 *         # it seems to be dangerous according to the documentation as the
 *         # object be partially deconstructed already.
 *         if self.htsfile != NULL:             # <<<<<<<<<<<<<<
 *             hts_close(self.htsfile)
 *             hts_idx_destroy(self.index);
 */
  }

  /* "pysam/calignmentfile.pyx":1341
 *             self.htsfile = NULL
 * 
 *         bam_destroy1(self.b)             # <<<<<<<<<<<<<<
 *         if self.header != NULL:
 *             bam_hdr_destroy(self.header)
 */
  bam_destroy1(__pyx_v_self->b);

  /* "pysam/calignmentfile.pyx":1342
 * 
 *         bam_destroy1(self.b)
 *         if self.header != NULL:             # <<<<<<<<<<<<<<
 *             bam_hdr_destroy(self.header)
 * 
 */
  __pyx_t_1 = ((__pyx_v_self->header != NULL) != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":1343
 *         bam_destroy1(self.b)
 *         if self.header != NULL:
 *             bam_hdr_destroy(self.header)             # <<<<<<<<<<<<<<
 * 
 *     cpdef int write(self, AlignedSegment read) except -1:
 */
    bam_hdr_destroy(__pyx_v_self->header);

    /* "pysam/calignmentfile.pyx":1342
 * 
 *         bam_destroy1(self.b)
 *         if self.header != NULL:             # <<<<<<<<<<<<<<
 *             bam_hdr_destroy(self.header)
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":1324
 *             self.htsfile = NULL
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         # remember: dealloc cannot call other methods
 *         # note: no doc string
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("pysam.calignmentfile.AlignmentFile.__dealloc__", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
}

/* "pysam/calignmentfile.pyx":1345
 *             bam_hdr_destroy(self.header)
 * 
 *     cpdef int write(self, AlignedSegment read) except -1:             # <<<<<<<<<<<<<<
 *         '''
 *         write a single :class:`pysam.AlignedSegment` to disk.
 */

static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_39write(PyObject *__pyx_v_self, PyObject *__pyx_v_read); /*proto*/
static int __pyx_f_5pysam_14calignmentfile_13AlignmentFile_write(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *__pyx_v_read, int __pyx_skip_dispatch) {
  int __pyx_v_ret;
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  int __pyx_t_6;
  int __pyx_t_7;
  int __pyx_t_8;
  __Pyx_RefNannySetupContext("write", 0);
  __Pyx_TraceCall("write", __pyx_f[0], 1345, 0, __PYX_ERR(0, 1345, __pyx_L1_error));
  /* Check if called by wrapper */
  if (unlikely(__pyx_skip_dispatch)) ;
  /* Check if overridden in Python */
  else if (unlikely(Py_TYPE(((PyObject *)__pyx_v_self))->tp_dictoffset != 0)) {
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_write); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1345, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    if (!PyCFunction_Check(__pyx_t_1) || (PyCFunction_GET_FUNCTION(__pyx_t_1) != (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_39write)) {
      __Pyx_INCREF(__pyx_t_1);
      __pyx_t_3 = __pyx_t_1; __pyx_t_4 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (!__pyx_t_4) {
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, ((PyObject *)__pyx_v_read)); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1345, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
      } else {
        __pyx_t_5 = PyTuple_New(1+1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1345, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_5);
        __Pyx_GIVEREF(__pyx_t_4); PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4); __pyx_t_4 = NULL;
        __Pyx_INCREF(((PyObject *)__pyx_v_read));
        __Pyx_GIVEREF(((PyObject *)__pyx_v_read));
        PyTuple_SET_ITEM(__pyx_t_5, 0+1, ((PyObject *)__pyx_v_read));
        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_5, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1345, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      }
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_6 = __Pyx_PyInt_As_int(__pyx_t_2); if (unlikely((__pyx_t_6 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 1345, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_r = __pyx_t_6;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L0;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "pysam/calignmentfile.pyx":1360
 *               this will be 0.
 *         '''
 *         if not self.is_open():             # <<<<<<<<<<<<<<
 *             return 0
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_open); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1360, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1360, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1360, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_7 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_7 < 0)) __PYX_ERR(0, 1360, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_8 = ((!__pyx_t_7) != 0);
  if (__pyx_t_8) {

    /* "pysam/calignmentfile.pyx":1361
 *         '''
 *         if not self.is_open():
 *             return 0             # <<<<<<<<<<<<<<
 * 
 *         cdef int ret
 */
    __pyx_r = 0;
    goto __pyx_L0;

    /* "pysam/calignmentfile.pyx":1360
 *               this will be 0.
 *         '''
 *         if not self.is_open():             # <<<<<<<<<<<<<<
 *             return 0
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":1365
 *         cdef int ret
 * 
 *         with nogil:             # <<<<<<<<<<<<<<
 *             ret = sam_write1(self.htsfile,
 *                              self.header,
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "pysam/calignmentfile.pyx":1366
 * 
 *         with nogil:
 *             ret = sam_write1(self.htsfile,             # <<<<<<<<<<<<<<
 *                              self.header,
 *                              read._delegate)
 */
        __pyx_v_ret = sam_write1(__pyx_v_self->htsfile, __pyx_v_self->header, __pyx_v_read->_delegate);
      }

      /* "pysam/calignmentfile.pyx":1365
 *         cdef int ret
 * 
 *         with nogil:             # <<<<<<<<<<<<<<
 *             ret = sam_write1(self.htsfile,
 *                              self.header,
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L6;
        }
        __pyx_L6:;
      }
  }

  /* "pysam/calignmentfile.pyx":1373
 *         #      when ret == -1 we get a "SystemError: error return without
 *         #      exception set".
 *         if ret < 0:             # <<<<<<<<<<<<<<
 *             raise ValueError('sam write failed')
 * 
 */
  __pyx_t_8 = ((__pyx_v_ret < 0) != 0);
  if (__pyx_t_8) {

    /* "pysam/calignmentfile.pyx":1374
 *         #      exception set".
 *         if ret < 0:
 *             raise ValueError('sam write failed')             # <<<<<<<<<<<<<<
 * 
 *         return ret
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__36, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1374, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 1374, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":1373
 *         #      when ret == -1 we get a "SystemError: error return without
 *         #      exception set".
 *         if ret < 0:             # <<<<<<<<<<<<<<
 *             raise ValueError('sam write failed')
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":1376
 *             raise ValueError('sam write failed')
 * 
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     # context manager interface
 */
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1345
 *             bam_hdr_destroy(self.header)
 * 
 *     cpdef int write(self, AlignedSegment read) except -1:             # <<<<<<<<<<<<<<
 *         '''
 *         write a single :class:`pysam.AlignedSegment` to disk.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.write", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_39write(PyObject *__pyx_v_self, PyObject *__pyx_v_read); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_38write[] = "AlignmentFile.write(self, AlignedSegment read) -> int\n\n        write a single :class:`pysam.AlignedSegment` to disk.\n\n        Raises\n        ------\n        ValueError\n            if the writing failed\n\n        Returns\n        -------\n            \n        int : the number of bytes written. If the file is closed,\n              this will be 0.\n        ";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_39write(PyObject *__pyx_v_self, PyObject *__pyx_v_read) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("write (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_read), __pyx_ptype_5pysam_15calignedsegment_AlignedSegment, 1, "read", 0))) __PYX_ERR(0, 1345, __pyx_L1_error)
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_38write(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self), ((struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *)__pyx_v_read));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_38write(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *__pyx_v_read) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("write", 0);
  __Pyx_TraceCall("write (wrapper)", __pyx_f[0], 1345, 0, __PYX_ERR(0, 1345, __pyx_L1_error));
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_5pysam_14calignmentfile_13AlignmentFile_write(__pyx_v_self, __pyx_v_read, 1); if (unlikely(__pyx_t_1 == -1)) __PYX_ERR(0, 1345, __pyx_L1_error)
  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_t_1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1345, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.write", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1379
 * 
 *     # context manager interface
 *     def __enter__(self):             # <<<<<<<<<<<<<<
 *         return self
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_41__enter__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_40__enter__[] = "AlignmentFile.__enter__(self)";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_41__enter__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__enter__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_40__enter__(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_40__enter__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__enter__", 0);
  __Pyx_TraceCall("__enter__", __pyx_f[0], 1379, 0, __PYX_ERR(0, 1379, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1380
 *     # context manager interface
 *     def __enter__(self):
 *         return self             # <<<<<<<<<<<<<<
 * 
 *     def __exit__(self, exc_type, exc_value, traceback):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __pyx_r = ((PyObject *)__pyx_v_self);
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1379
 * 
 *     # context manager interface
 *     def __enter__(self):             # <<<<<<<<<<<<<<
 *         return self
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.__enter__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1382
 *         return self
 * 
 *     def __exit__(self, exc_type, exc_value, traceback):             # <<<<<<<<<<<<<<
 *         self.close()
 *         return False
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_43__exit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_42__exit__[] = "AlignmentFile.__exit__(self, exc_type, exc_value, traceback)";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_43__exit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED PyObject *__pyx_v_exc_type = 0;
  CYTHON_UNUSED PyObject *__pyx_v_exc_value = 0;
  CYTHON_UNUSED PyObject *__pyx_v_traceback = 0;
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__exit__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_exc_type,&__pyx_n_s_exc_value,&__pyx_n_s_traceback,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_exc_type)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_exc_value)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__exit__", 1, 3, 3, 1); __PYX_ERR(0, 1382, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_traceback)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__exit__", 1, 3, 3, 2); __PYX_ERR(0, 1382, __pyx_L3_error)
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__exit__") < 0)) __PYX_ERR(0, 1382, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 3) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
    }
    __pyx_v_exc_type = values[0];
    __pyx_v_exc_value = values[1];
    __pyx_v_traceback = values[2];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__exit__", 1, 3, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1382, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.__exit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_42__exit__(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self), __pyx_v_exc_type, __pyx_v_exc_value, __pyx_v_traceback);

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_42__exit__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_exc_type, CYTHON_UNUSED PyObject *__pyx_v_exc_value, CYTHON_UNUSED PyObject *__pyx_v_traceback) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("__exit__", 0);
  __Pyx_TraceCall("__exit__", __pyx_f[0], 1382, 0, __PYX_ERR(0, 1382, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1383
 * 
 *     def __exit__(self, exc_type, exc_value, traceback):
 *         self.close()             # <<<<<<<<<<<<<<
 *         return False
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_close); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1383, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1383, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1383, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pysam/calignmentfile.pyx":1384
 *     def __exit__(self, exc_type, exc_value, traceback):
 *         self.close()
 *         return False             # <<<<<<<<<<<<<<
 * 
 *     ###############################################################
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(Py_False);
  __pyx_r = Py_False;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1382
 *         return self
 * 
 *     def __exit__(self, exc_type, exc_value, traceback):             # <<<<<<<<<<<<<<
 *         self.close()
 *         return False
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.__exit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1395
 *         This is a read-only attribute; the close() method changes the value.
 *         """
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             return not self.is_open()
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_6closed_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_6closed_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_6closed___get__(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_6closed___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[0], 1395, 0, __PYX_ERR(0, 1395, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1396
 *         """
 *         def __get__(self):
 *             return not self.is_open()             # <<<<<<<<<<<<<<
 * 
 *     property filename:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_open); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1396, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1396, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1396, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1396, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyBool_FromLong((!__pyx_t_4)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1396, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1395
 *         This is a read-only attribute; the close() method changes the value.
 *         """
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             return not self.is_open()
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.closed.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1400
 *     property filename:
 *         """filename associated with this object. This is a read-only attribute."""
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             return self._filename
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_8filename_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_8filename_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_8filename___get__(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_8filename___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[0], 1400, 0, __PYX_ERR(0, 1400, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1401
 *         """filename associated with this object. This is a read-only attribute."""
 *         def __get__(self):
 *             return self._filename             # <<<<<<<<<<<<<<
 * 
 *     property nreferences:
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_self->_filename);
  __pyx_r = __pyx_v_self->_filename;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1400
 *     property filename:
 *         """filename associated with this object. This is a read-only attribute."""
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             return self._filename
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.filename.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1406
 *         """"int with the number of :term:`reference` sequences in the file.
 *         This is a read-only attribute."""
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             if not self.is_open():
 *                 raise ValueError("I/O operation on closed file")
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_11nreferences_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_11nreferences_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_11nreferences___get__(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_11nreferences___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[0], 1406, 0, __PYX_ERR(0, 1406, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1407
 *         This is a read-only attribute."""
 *         def __get__(self):
 *             if not self.is_open():             # <<<<<<<<<<<<<<
 *                 raise ValueError("I/O operation on closed file")
 *             return self.header.n_targets
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_open); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1407, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1407, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1407, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1407, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = ((!__pyx_t_4) != 0);
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":1408
 *         def __get__(self):
 *             if not self.is_open():
 *                 raise ValueError("I/O operation on closed file")             # <<<<<<<<<<<<<<
 *             return self.header.n_targets
 * 
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__37, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1408, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 1408, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":1407
 *         This is a read-only attribute."""
 *         def __get__(self):
 *             if not self.is_open():             # <<<<<<<<<<<<<<
 *                 raise ValueError("I/O operation on closed file")
 *             return self.header.n_targets
 */
  }

  /* "pysam/calignmentfile.pyx":1409
 *             if not self.is_open():
 *                 raise ValueError("I/O operation on closed file")
 *             return self.header.n_targets             # <<<<<<<<<<<<<<
 * 
 *     property references:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int32_t(__pyx_v_self->header->n_targets); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1409, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1406
 *         """"int with the number of :term:`reference` sequences in the file.
 *         This is a read-only attribute."""
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             if not self.is_open():
 *                 raise ValueError("I/O operation on closed file")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.nreferences.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1414
 *         """tuple with the names of :term:`reference` sequences. This is a
 *         read-only attribute"""
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             if not self.is_open(): raise ValueError( "I/O operation on closed file" )
 *             t = []
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_10references_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_10references_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_10references___get__(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_10references___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  PyObject *__pyx_v_t = NULL;
  long __pyx_v_x;
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  int32_t __pyx_t_6;
  int __pyx_t_7;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[0], 1414, 0, __PYX_ERR(0, 1414, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1415
 *         read-only attribute"""
 *         def __get__(self):
 *             if not self.is_open(): raise ValueError( "I/O operation on closed file" )             # <<<<<<<<<<<<<<
 *             t = []
 *             for x from 0 <= x < self.header.n_targets:
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_open); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1415, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1415, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1415, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1415, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = ((!__pyx_t_4) != 0);
  if (__pyx_t_5) {
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__38, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1415, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 1415, __pyx_L1_error)
  }

  /* "pysam/calignmentfile.pyx":1416
 *         def __get__(self):
 *             if not self.is_open(): raise ValueError( "I/O operation on closed file" )
 *             t = []             # <<<<<<<<<<<<<<
 *             for x from 0 <= x < self.header.n_targets:
 *                 t.append(charptr_to_str(self.header.target_name[x]))
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1416, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_t = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pysam/calignmentfile.pyx":1417
 *             if not self.is_open(): raise ValueError( "I/O operation on closed file" )
 *             t = []
 *             for x from 0 <= x < self.header.n_targets:             # <<<<<<<<<<<<<<
 *                 t.append(charptr_to_str(self.header.target_name[x]))
 *             return tuple(t)
 */
  __pyx_t_6 = __pyx_v_self->header->n_targets;
  for (__pyx_v_x = 0; __pyx_v_x < __pyx_t_6; __pyx_v_x++) {

    /* "pysam/calignmentfile.pyx":1418
 *             t = []
 *             for x from 0 <= x < self.header.n_targets:
 *                 t.append(charptr_to_str(self.header.target_name[x]))             # <<<<<<<<<<<<<<
 *             return tuple(t)
 * 
 */
    __pyx_t_1 = __pyx_f_5pysam_6cutils_charptr_to_str((__pyx_v_self->header->target_name[__pyx_v_x]), NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1418, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_7 = __Pyx_PyList_Append(__pyx_v_t, __pyx_t_1); if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 1418, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "pysam/calignmentfile.pyx":1419
 *             for x from 0 <= x < self.header.n_targets:
 *                 t.append(charptr_to_str(self.header.target_name[x]))
 *             return tuple(t)             # <<<<<<<<<<<<<<
 * 
 *     property lengths:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyList_AsTuple(__pyx_v_t); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1419, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1414
 *         """tuple with the names of :term:`reference` sequences. This is a
 *         read-only attribute"""
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             if not self.is_open(): raise ValueError( "I/O operation on closed file" )
 *             t = []
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.references.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_t);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1427
 * 
 *         """
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             if not self.is_open():
 *                 raise ValueError("I/O operation on closed file")
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_7lengths_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_7lengths_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_7lengths___get__(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_7lengths___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  PyObject *__pyx_v_t = NULL;
  long __pyx_v_x;
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  int32_t __pyx_t_6;
  int __pyx_t_7;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[0], 1427, 0, __PYX_ERR(0, 1427, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1428
 *         """
 *         def __get__(self):
 *             if not self.is_open():             # <<<<<<<<<<<<<<
 *                 raise ValueError("I/O operation on closed file")
 *             t = []
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_open); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1428, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1428, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1428, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1428, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = ((!__pyx_t_4) != 0);
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":1429
 *         def __get__(self):
 *             if not self.is_open():
 *                 raise ValueError("I/O operation on closed file")             # <<<<<<<<<<<<<<
 *             t = []
 *             for x from 0 <= x < self.header.n_targets:
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__39, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1429, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 1429, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":1428
 *         """
 *         def __get__(self):
 *             if not self.is_open():             # <<<<<<<<<<<<<<
 *                 raise ValueError("I/O operation on closed file")
 *             t = []
 */
  }

  /* "pysam/calignmentfile.pyx":1430
 *             if not self.is_open():
 *                 raise ValueError("I/O operation on closed file")
 *             t = []             # <<<<<<<<<<<<<<
 *             for x from 0 <= x < self.header.n_targets:
 *                 t.append(self.header.target_len[x])
 */
  __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1430, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_t = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pysam/calignmentfile.pyx":1431
 *                 raise ValueError("I/O operation on closed file")
 *             t = []
 *             for x from 0 <= x < self.header.n_targets:             # <<<<<<<<<<<<<<
 *                 t.append(self.header.target_len[x])
 *             return tuple(t)
 */
  __pyx_t_6 = __pyx_v_self->header->n_targets;
  for (__pyx_v_x = 0; __pyx_v_x < __pyx_t_6; __pyx_v_x++) {

    /* "pysam/calignmentfile.pyx":1432
 *             t = []
 *             for x from 0 <= x < self.header.n_targets:
 *                 t.append(self.header.target_len[x])             # <<<<<<<<<<<<<<
 *             return tuple(t)
 * 
 */
    __pyx_t_1 = __Pyx_PyInt_From_uint32_t((__pyx_v_self->header->target_len[__pyx_v_x])); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1432, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_7 = __Pyx_PyList_Append(__pyx_v_t, __pyx_t_1); if (unlikely(__pyx_t_7 == -1)) __PYX_ERR(0, 1432, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  }

  /* "pysam/calignmentfile.pyx":1433
 *             for x from 0 <= x < self.header.n_targets:
 *                 t.append(self.header.target_len[x])
 *             return tuple(t)             # <<<<<<<<<<<<<<
 * 
 *     property mapped:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyList_AsTuple(__pyx_v_t); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1433, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1427
 * 
 *         """
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             if not self.is_open():
 *                 raise ValueError("I/O operation on closed file")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.lengths.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_t);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1440
 *         attribute.
 *         """
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             self.check_index()
 *             cdef int tid
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_6mapped_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_6mapped_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_6mapped___get__(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_6mapped___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  int __pyx_v_tid;
  uint64_t __pyx_v_total;
  uint64_t __pyx_v_mapped;
  uint64_t __pyx_v_unmapped;
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int32_t __pyx_t_4;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[0], 1440, 0, __PYX_ERR(0, 1440, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1441
 *         """
 *         def __get__(self):
 *             self.check_index()             # <<<<<<<<<<<<<<
 *             cdef int tid
 *             cdef uint64_t total = 0
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1441, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1441, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1441, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pysam/calignmentfile.pyx":1443
 *             self.check_index()
 *             cdef int tid
 *             cdef uint64_t total = 0             # <<<<<<<<<<<<<<
 *             cdef uint64_t mapped, unmapped
 *             for tid from 0 <= tid < self.header.n_targets:
 */
  __pyx_v_total = 0;

  /* "pysam/calignmentfile.pyx":1445
 *             cdef uint64_t total = 0
 *             cdef uint64_t mapped, unmapped
 *             for tid from 0 <= tid < self.header.n_targets:             # <<<<<<<<<<<<<<
 *                 with nogil:
 *                     hts_idx_get_stat(self.index, tid, &mapped, &unmapped)
 */
  __pyx_t_4 = __pyx_v_self->header->n_targets;
  for (__pyx_v_tid = 0; __pyx_v_tid < __pyx_t_4; __pyx_v_tid++) {

    /* "pysam/calignmentfile.pyx":1446
 *             cdef uint64_t mapped, unmapped
 *             for tid from 0 <= tid < self.header.n_targets:
 *                 with nogil:             # <<<<<<<<<<<<<<
 *                     hts_idx_get_stat(self.index, tid, &mapped, &unmapped)
 *                 total += mapped
 */
    {
        #ifdef WITH_THREAD
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
        #endif
        /*try:*/ {

          /* "pysam/calignmentfile.pyx":1447
 *             for tid from 0 <= tid < self.header.n_targets:
 *                 with nogil:
 *                     hts_idx_get_stat(self.index, tid, &mapped, &unmapped)             # <<<<<<<<<<<<<<
 *                 total += mapped
 *             return total
 */
          hts_idx_get_stat(__pyx_v_self->index, __pyx_v_tid, (&__pyx_v_mapped), (&__pyx_v_unmapped));
        }

        /* "pysam/calignmentfile.pyx":1446
 *             cdef uint64_t mapped, unmapped
 *             for tid from 0 <= tid < self.header.n_targets:
 *                 with nogil:             # <<<<<<<<<<<<<<
 *                     hts_idx_get_stat(self.index, tid, &mapped, &unmapped)
 *                 total += mapped
 */
        /*finally:*/ {
          /*normal exit:*/{
            #ifdef WITH_THREAD
            Py_BLOCK_THREADS
            #endif
            goto __pyx_L9;
          }
          __pyx_L9:;
        }
    }

    /* "pysam/calignmentfile.pyx":1448
 *                 with nogil:
 *                     hts_idx_get_stat(self.index, tid, &mapped, &unmapped)
 *                 total += mapped             # <<<<<<<<<<<<<<
 *             return total
 * 
 */
    __pyx_v_total = (__pyx_v_total + __pyx_v_mapped);
  }

  /* "pysam/calignmentfile.pyx":1449
 *                     hts_idx_get_stat(self.index, tid, &mapped, &unmapped)
 *                 total += mapped
 *             return total             # <<<<<<<<<<<<<<
 * 
 *     property unmapped:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(__pyx_v_total); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1449, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1440
 *         attribute.
 *         """
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             self.check_index()
 *             cdef int tid
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.mapped.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1456
 *         without coordinates. This is a read-only attribute.
 *         """
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             self.check_index()
 *             cdef int tid
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_8unmapped_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_8unmapped_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_8unmapped___get__(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_8unmapped___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  int __pyx_v_tid;
  uint64_t __pyx_v_total;
  uint64_t __pyx_v_mapped;
  uint64_t __pyx_v_unmapped;
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int32_t __pyx_t_4;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[0], 1456, 0, __PYX_ERR(0, 1456, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1457
 *         """
 *         def __get__(self):
 *             self.check_index()             # <<<<<<<<<<<<<<
 *             cdef int tid
 *             cdef uint64_t total = hts_idx_get_n_no_coor(self.index)
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1457, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1457, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1457, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pysam/calignmentfile.pyx":1459
 *             self.check_index()
 *             cdef int tid
 *             cdef uint64_t total = hts_idx_get_n_no_coor(self.index)             # <<<<<<<<<<<<<<
 *             cdef uint64_t mapped, unmapped
 *             for tid from 0 <= tid < self.header.n_targets:
 */
  __pyx_v_total = hts_idx_get_n_no_coor(__pyx_v_self->index);

  /* "pysam/calignmentfile.pyx":1461
 *             cdef uint64_t total = hts_idx_get_n_no_coor(self.index)
 *             cdef uint64_t mapped, unmapped
 *             for tid from 0 <= tid < self.header.n_targets:             # <<<<<<<<<<<<<<
 *                 with nogil:
 *                     hts_idx_get_stat(self.index, tid, &mapped, &unmapped)
 */
  __pyx_t_4 = __pyx_v_self->header->n_targets;
  for (__pyx_v_tid = 0; __pyx_v_tid < __pyx_t_4; __pyx_v_tid++) {

    /* "pysam/calignmentfile.pyx":1462
 *             cdef uint64_t mapped, unmapped
 *             for tid from 0 <= tid < self.header.n_targets:
 *                 with nogil:             # <<<<<<<<<<<<<<
 *                     hts_idx_get_stat(self.index, tid, &mapped, &unmapped)
 *                 total += unmapped
 */
    {
        #ifdef WITH_THREAD
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
        #endif
        /*try:*/ {

          /* "pysam/calignmentfile.pyx":1463
 *             for tid from 0 <= tid < self.header.n_targets:
 *                 with nogil:
 *                     hts_idx_get_stat(self.index, tid, &mapped, &unmapped)             # <<<<<<<<<<<<<<
 *                 total += unmapped
 *             return total
 */
          hts_idx_get_stat(__pyx_v_self->index, __pyx_v_tid, (&__pyx_v_mapped), (&__pyx_v_unmapped));
        }

        /* "pysam/calignmentfile.pyx":1462
 *             cdef uint64_t mapped, unmapped
 *             for tid from 0 <= tid < self.header.n_targets:
 *                 with nogil:             # <<<<<<<<<<<<<<
 *                     hts_idx_get_stat(self.index, tid, &mapped, &unmapped)
 *                 total += unmapped
 */
        /*finally:*/ {
          /*normal exit:*/{
            #ifdef WITH_THREAD
            Py_BLOCK_THREADS
            #endif
            goto __pyx_L9;
          }
          __pyx_L9:;
        }
    }

    /* "pysam/calignmentfile.pyx":1464
 *                 with nogil:
 *                     hts_idx_get_stat(self.index, tid, &mapped, &unmapped)
 *                 total += unmapped             # <<<<<<<<<<<<<<
 *             return total
 * 
 */
    __pyx_v_total = (__pyx_v_total + __pyx_v_unmapped);
  }

  /* "pysam/calignmentfile.pyx":1465
 *                     hts_idx_get_stat(self.index, tid, &mapped, &unmapped)
 *                 total += unmapped
 *             return total             # <<<<<<<<<<<<<<
 * 
 *     property nocoordinate:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(__pyx_v_total); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1465, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1456
 *         without coordinates. This is a read-only attribute.
 *         """
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             self.check_index()
 *             cdef int tid
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.unmapped.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1471
 *         statistics recorded in the index. This is a read-only attribute.
 *         """
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             self.check_index()
 *             cdef uint64_t n
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_12nocoordinate_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_12nocoordinate_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_12nocoordinate___get__(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_12nocoordinate___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  uint64_t __pyx_v_n;
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[0], 1471, 0, __PYX_ERR(0, 1471, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1472
 *         """
 *         def __get__(self):
 *             self.check_index()             # <<<<<<<<<<<<<<
 *             cdef uint64_t n
 *             with nogil:
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_check_index); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1472, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1472, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1472, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pysam/calignmentfile.pyx":1474
 *             self.check_index()
 *             cdef uint64_t n
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 n = hts_idx_get_n_no_coor(self.index)
 *             return n
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "pysam/calignmentfile.pyx":1475
 *             cdef uint64_t n
 *             with nogil:
 *                 n = hts_idx_get_n_no_coor(self.index)             # <<<<<<<<<<<<<<
 *             return n
 * 
 */
        __pyx_v_n = hts_idx_get_n_no_coor(__pyx_v_self->index);
      }

      /* "pysam/calignmentfile.pyx":1474
 *             self.check_index()
 *             cdef uint64_t n
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 n = hts_idx_get_n_no_coor(self.index)
 *             return n
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L5:;
      }
  }

  /* "pysam/calignmentfile.pyx":1476
 *             with nogil:
 *                 n = hts_idx_get_n_no_coor(self.index)
 *             return n             # <<<<<<<<<<<<<<
 * 
 *     property format:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_uint64_t(__pyx_v_n); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1476, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1471
 *         statistics recorded in the index. This is a read-only attribute.
 *         """
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             self.check_index()
 *             cdef uint64_t n
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.nocoordinate.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1480
 *     property format:
 *         '''string describing the file format'''
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             if not self.is_open():
 *                 raise ValueError( "I/O operation on closed file" )
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_6format_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_6format_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_6format___get__(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_6format___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[0], 1480, 0, __PYX_ERR(0, 1480, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1481
 *         '''string describing the file format'''
 *         def __get__(self):
 *             if not self.is_open():             # <<<<<<<<<<<<<<
 *                 raise ValueError( "I/O operation on closed file" )
 *             return hts_format_description(&self.htsfile.format)
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_open); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1481, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1481, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1481, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1481, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = ((!__pyx_t_4) != 0);
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":1482
 *         def __get__(self):
 *             if not self.is_open():
 *                 raise ValueError( "I/O operation on closed file" )             # <<<<<<<<<<<<<<
 *             return hts_format_description(&self.htsfile.format)
 * 
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__40, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1482, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 1482, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":1481
 *         '''string describing the file format'''
 *         def __get__(self):
 *             if not self.is_open():             # <<<<<<<<<<<<<<
 *                 raise ValueError( "I/O operation on closed file" )
 *             return hts_format_description(&self.htsfile.format)
 */
  }

  /* "pysam/calignmentfile.pyx":1483
 *             if not self.is_open():
 *                 raise ValueError( "I/O operation on closed file" )
 *             return hts_format_description(&self.htsfile.format)             # <<<<<<<<<<<<<<
 * 
 *     property text:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBytes_FromString(hts_format_description((&__pyx_v_self->htsfile->format))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1483, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1480
 *     property format:
 *         '''string describing the file format'''
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             if not self.is_open():
 *                 raise ValueError( "I/O operation on closed file" )
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.format.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1494
 *         representation of the header.
 *         '''
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             if not self.is_open():
 *                 raise ValueError( "I/O operation on closed file" )
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_4text_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_4text_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_4text___get__(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_4text___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[0], 1494, 0, __PYX_ERR(0, 1494, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1495
 *         '''
 *         def __get__(self):
 *             if not self.is_open():             # <<<<<<<<<<<<<<
 *                 raise ValueError( "I/O operation on closed file" )
 *             return from_string_and_size(self.header.text, self.header.l_text)
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_open); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1495, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1495, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1495, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1495, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = ((!__pyx_t_4) != 0);
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":1496
 *         def __get__(self):
 *             if not self.is_open():
 *                 raise ValueError( "I/O operation on closed file" )             # <<<<<<<<<<<<<<
 *             return from_string_and_size(self.header.text, self.header.l_text)
 * 
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__41, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1496, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 1496, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":1495
 *         '''
 *         def __get__(self):
 *             if not self.is_open():             # <<<<<<<<<<<<<<
 *                 raise ValueError( "I/O operation on closed file" )
 *             return from_string_and_size(self.header.text, self.header.l_text)
 */
  }

  /* "pysam/calignmentfile.pyx":1497
 *             if not self.is_open():
 *                 raise ValueError( "I/O operation on closed file" )
 *             return from_string_and_size(self.header.text, self.header.l_text)             # <<<<<<<<<<<<<<
 * 
 *     property header:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_5pysam_6cutils_from_string_and_size(__pyx_v_self->header->text, __pyx_v_self->header->l_text); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1497, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1494
 *         representation of the header.
 *         '''
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             if not self.is_open():
 *                 raise ValueError( "I/O operation on closed file" )
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.text.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1521
 * 
 *         """
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             if not self.is_open():
 *                 raise ValueError( "I/O operation on closed file" )
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_6header_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_6header_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_6header___get__(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_6header___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  PyObject *__pyx_v_result = NULL;
  PyObject *__pyx_v_t = NULL;
  PyObject *__pyx_v_line = NULL;
  PyObject *__pyx_v_fields = NULL;
  PyObject *__pyx_v_record = NULL;
  PyObject *__pyx_v_x = NULL;
  PyObject *__pyx_v_idx = NULL;
  PyObject *__pyx_v_field = NULL;
  PyObject *__pyx_v_key = NULL;
  PyObject *__pyx_v_value = NULL;
  PyObject *__pyx_v_sq = NULL;
  PyObject *__pyx_v_ref = NULL;
  PyObject *__pyx_v_length = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  Py_ssize_t __pyx_t_6;
  PyObject *(*__pyx_t_7)(PyObject *);
  PyObject *__pyx_t_8 = NULL;
  int __pyx_t_9;
  Py_ssize_t __pyx_t_10;
  PyObject *(*__pyx_t_11)(PyObject *);
  PyObject *__pyx_t_12 = NULL;
  PyObject *__pyx_t_13 = NULL;
  PyObject *__pyx_t_14 = NULL;
  PyObject *(*__pyx_t_15)(PyObject *);
  Py_ssize_t __pyx_t_16;
  PyObject *__pyx_t_17 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[0], 1521, 0, __PYX_ERR(0, 1521, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1522
 *         """
 *         def __get__(self):
 *             if not self.is_open():             # <<<<<<<<<<<<<<
 *                 raise ValueError( "I/O operation on closed file" )
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_open); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1522, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1522, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1522, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1522, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = ((!__pyx_t_4) != 0);
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":1523
 *         def __get__(self):
 *             if not self.is_open():
 *                 raise ValueError( "I/O operation on closed file" )             # <<<<<<<<<<<<<<
 * 
 *             result = {}
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__42, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1523, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 1523, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":1522
 *         """
 *         def __get__(self):
 *             if not self.is_open():             # <<<<<<<<<<<<<<
 *                 raise ValueError( "I/O operation on closed file" )
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":1525
 *                 raise ValueError( "I/O operation on closed file" )
 * 
 *             result = {}             # <<<<<<<<<<<<<<
 * 
 *             if self.header.text != NULL:
 */
  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1525, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_result = ((PyObject*)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pysam/calignmentfile.pyx":1527
 *             result = {}
 * 
 *             if self.header.text != NULL:             # <<<<<<<<<<<<<<
 *                 # convert to python string (note: call self.text to
 *                 # create 0-terminated string)
 */
  __pyx_t_5 = ((__pyx_v_self->header->text != NULL) != 0);
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":1530
 *                 # convert to python string (note: call self.text to
 *                 # create 0-terminated string)
 *                 t = self.text             # <<<<<<<<<<<<<<
 *                 for line in t.split("\n"):
 *                     if not line.strip(): continue
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_text); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1530, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_v_t = __pyx_t_1;
    __pyx_t_1 = 0;

    /* "pysam/calignmentfile.pyx":1531
 *                 # create 0-terminated string)
 *                 t = self.text
 *                 for line in t.split("\n"):             # <<<<<<<<<<<<<<
 *                     if not line.strip(): continue
 *                     assert line.startswith("@"), \
 */
    __pyx_t_1 = __Pyx_PyObject_GetAttrStr(__pyx_v_t, __pyx_n_s_split); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1531, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_tuple__43, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1531, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    if (likely(PyList_CheckExact(__pyx_t_2)) || PyTuple_CheckExact(__pyx_t_2)) {
      __pyx_t_1 = __pyx_t_2; __Pyx_INCREF(__pyx_t_1); __pyx_t_6 = 0;
      __pyx_t_7 = NULL;
    } else {
      __pyx_t_6 = -1; __pyx_t_1 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1531, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_7 = Py_TYPE(__pyx_t_1)->tp_iternext; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1531, __pyx_L1_error)
    }
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    for (;;) {
      if (likely(!__pyx_t_7)) {
        if (likely(PyList_CheckExact(__pyx_t_1))) {
          if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_1)) break;
          #if CYTHON_COMPILING_IN_CPYTHON
          __pyx_t_2 = PyList_GET_ITEM(__pyx_t_1, __pyx_t_6); __Pyx_INCREF(__pyx_t_2); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 1531, __pyx_L1_error)
          #else
          __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1531, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          #endif
        } else {
          if (__pyx_t_6 >= PyTuple_GET_SIZE(__pyx_t_1)) break;
          #if CYTHON_COMPILING_IN_CPYTHON
          __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_1, __pyx_t_6); __Pyx_INCREF(__pyx_t_2); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 1531, __pyx_L1_error)
          #else
          __pyx_t_2 = PySequence_ITEM(__pyx_t_1, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1531, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          #endif
        }
      } else {
        __pyx_t_2 = __pyx_t_7(__pyx_t_1);
        if (unlikely(!__pyx_t_2)) {
          PyObject* exc_type = PyErr_Occurred();
          if (exc_type) {
            if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
            else __PYX_ERR(0, 1531, __pyx_L1_error)
          }
          break;
        }
        __Pyx_GOTREF(__pyx_t_2);
      }
      __Pyx_XDECREF_SET(__pyx_v_line, __pyx_t_2);
      __pyx_t_2 = 0;

      /* "pysam/calignmentfile.pyx":1532
 *                 t = self.text
 *                 for line in t.split("\n"):
 *                     if not line.strip(): continue             # <<<<<<<<<<<<<<
 *                     assert line.startswith("@"), \
 *                         "header line without '@': '%s'" % line
 */
      __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_v_line, __pyx_n_s_strip); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1532, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_8 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_3))) {
        __pyx_t_8 = PyMethod_GET_SELF(__pyx_t_3);
        if (likely(__pyx_t_8)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
          __Pyx_INCREF(__pyx_t_8);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_3, function);
        }
      }
      if (__pyx_t_8) {
        __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1532, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      } else {
        __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1532, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1532, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_t_4 = ((!__pyx_t_5) != 0);
      if (__pyx_t_4) {
        goto __pyx_L5_continue;
      }

      /* "pysam/calignmentfile.pyx":1533
 *                 for line in t.split("\n"):
 *                     if not line.strip(): continue
 *                     assert line.startswith("@"), \             # <<<<<<<<<<<<<<
 *                         "header line without '@': '%s'" % line
 *                     fields = line[1:].split("\t")
 */
      #ifndef CYTHON_WITHOUT_ASSERTIONS
      if (unlikely(!Py_OptimizeFlag)) {
        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_line, __pyx_n_s_startswith); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1533, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__45, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1533, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1533, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        if (unlikely(!__pyx_t_4)) {

          /* "pysam/calignmentfile.pyx":1534
 *                     if not line.strip(): continue
 *                     assert line.startswith("@"), \
 *                         "header line without '@': '%s'" % line             # <<<<<<<<<<<<<<
 *                     fields = line[1:].split("\t")
 *                     record = fields[0]
 */
          __pyx_t_3 = __Pyx_PyString_Format(__pyx_kp_s_header_line_without_s, __pyx_v_line); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1534, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_3);
          PyErr_SetObject(PyExc_AssertionError, __pyx_t_3);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          __PYX_ERR(0, 1533, __pyx_L1_error)
        }
      }
      #endif

      /* "pysam/calignmentfile.pyx":1535
 *                     assert line.startswith("@"), \
 *                         "header line without '@': '%s'" % line
 *                     fields = line[1:].split("\t")             # <<<<<<<<<<<<<<
 *                     record = fields[0]
 *                     assert record in VALID_HEADER_TYPES, \
 */
      __pyx_t_3 = __Pyx_PyObject_GetSlice(__pyx_v_line, 1, 0, NULL, NULL, &__pyx_slice__46, 1, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1535, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_t_3, __pyx_n_s_split); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1535, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__47, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1535, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF_SET(__pyx_v_fields, __pyx_t_3);
      __pyx_t_3 = 0;

      /* "pysam/calignmentfile.pyx":1536
 *                         "header line without '@': '%s'" % line
 *                     fields = line[1:].split("\t")
 *                     record = fields[0]             # <<<<<<<<<<<<<<
 *                     assert record in VALID_HEADER_TYPES, \
 *                         "header line with invalid type '%s': '%s'" % (record, line)
 */
      __pyx_t_3 = __Pyx_GetItemInt(__pyx_v_fields, 0, long, 1, __Pyx_PyInt_From_long, 0, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1536, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_XDECREF_SET(__pyx_v_record, __pyx_t_3);
      __pyx_t_3 = 0;

      /* "pysam/calignmentfile.pyx":1537
 *                     fields = line[1:].split("\t")
 *                     record = fields[0]
 *                     assert record in VALID_HEADER_TYPES, \             # <<<<<<<<<<<<<<
 *                         "header line with invalid type '%s': '%s'" % (record, line)
 * 
 */
      #ifndef CYTHON_WITHOUT_ASSERTIONS
      if (unlikely(!Py_OptimizeFlag)) {
        __pyx_t_3 = __Pyx_GetModuleGlobalName(__pyx_n_s_VALID_HEADER_TYPES); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1537, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_4 = (__Pyx_PySequence_ContainsTF(__pyx_v_record, __pyx_t_3, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1537, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        if (unlikely(!(__pyx_t_4 != 0))) {

          /* "pysam/calignmentfile.pyx":1538
 *                     record = fields[0]
 *                     assert record in VALID_HEADER_TYPES, \
 *                         "header line with invalid type '%s': '%s'" % (record, line)             # <<<<<<<<<<<<<<
 * 
 *                     # treat comments
 */
          __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1538, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_3);
          __Pyx_INCREF(__pyx_v_record);
          __Pyx_GIVEREF(__pyx_v_record);
          PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_record);
          __Pyx_INCREF(__pyx_v_line);
          __Pyx_GIVEREF(__pyx_v_line);
          PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_v_line);
          __pyx_t_2 = __Pyx_PyString_Format(__pyx_kp_s_header_line_with_invalid_type_s, __pyx_t_3); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1538, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          PyErr_SetObject(PyExc_AssertionError, __pyx_t_2);
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
          __PYX_ERR(0, 1537, __pyx_L1_error)
        }
      }
      #endif

      /* "pysam/calignmentfile.pyx":1541
 * 
 *                     # treat comments
 *                     if record == "CO":             # <<<<<<<<<<<<<<
 *                         if record not in result:
 *                             result[record] = []
 */
      __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_v_record, __pyx_n_s_CO, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1541, __pyx_L1_error)
      if (__pyx_t_4) {

        /* "pysam/calignmentfile.pyx":1542
 *                     # treat comments
 *                     if record == "CO":
 *                         if record not in result:             # <<<<<<<<<<<<<<
 *                             result[record] = []
 *                         result[record].append("\t".join( fields[1:]))
 */
        __pyx_t_4 = (__Pyx_PyDict_ContainsTF(__pyx_v_record, __pyx_v_result, Py_NE)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1542, __pyx_L1_error)
        __pyx_t_5 = (__pyx_t_4 != 0);
        if (__pyx_t_5) {

          /* "pysam/calignmentfile.pyx":1543
 *                     if record == "CO":
 *                         if record not in result:
 *                             result[record] = []             # <<<<<<<<<<<<<<
 *                         result[record].append("\t".join( fields[1:]))
 *                         continue
 */
          __pyx_t_2 = PyList_New(0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1543, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          if (unlikely(PyDict_SetItem(__pyx_v_result, __pyx_v_record, __pyx_t_2) < 0)) __PYX_ERR(0, 1543, __pyx_L1_error)
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

          /* "pysam/calignmentfile.pyx":1542
 *                     # treat comments
 *                     if record == "CO":
 *                         if record not in result:             # <<<<<<<<<<<<<<
 *                             result[record] = []
 *                         result[record].append("\t".join( fields[1:]))
 */
        }

        /* "pysam/calignmentfile.pyx":1544
 *                         if record not in result:
 *                             result[record] = []
 *                         result[record].append("\t".join( fields[1:]))             # <<<<<<<<<<<<<<
 *                         continue
 *                     # the following is clumsy as generators do not work?
 */
        __pyx_t_2 = __Pyx_PyDict_GetItem(__pyx_v_result, __pyx_v_record); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1544, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __pyx_t_3 = __Pyx_PyObject_GetSlice(__pyx_v_fields, 1, 0, NULL, NULL, &__pyx_slice__48, 1, 0, 1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1544, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_8 = __Pyx_PyString_Join(__pyx_kp_s__2, __pyx_t_3); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1544, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_8);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __pyx_t_9 = __Pyx_PyObject_Append(__pyx_t_2, __pyx_t_8); if (unlikely(__pyx_t_9 == -1)) __PYX_ERR(0, 1544, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;

        /* "pysam/calignmentfile.pyx":1545
 *                             result[record] = []
 *                         result[record].append("\t".join( fields[1:]))
 *                         continue             # <<<<<<<<<<<<<<
 *                     # the following is clumsy as generators do not work?
 *                     x = {}
 */
        goto __pyx_L5_continue;

        /* "pysam/calignmentfile.pyx":1541
 * 
 *                     # treat comments
 *                     if record == "CO":             # <<<<<<<<<<<<<<
 *                         if record not in result:
 *                             result[record] = []
 */
      }

      /* "pysam/calignmentfile.pyx":1547
 *                         continue
 *                     # the following is clumsy as generators do not work?
 *                     x = {}             # <<<<<<<<<<<<<<
 * 
 *                     for idx, field in enumerate(fields[1:]):
 */
      __pyx_t_8 = PyDict_New(); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1547, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_XDECREF_SET(__pyx_v_x, ((PyObject*)__pyx_t_8));
      __pyx_t_8 = 0;

      /* "pysam/calignmentfile.pyx":1549
 *                     x = {}
 * 
 *                     for idx, field in enumerate(fields[1:]):             # <<<<<<<<<<<<<<
 *                         if ":" not in field:
 *                             raise ValueError("malformatted header: no ':' in field" )
 */
      __Pyx_INCREF(__pyx_int_0);
      __pyx_t_8 = __pyx_int_0;
      __pyx_t_2 = __Pyx_PyObject_GetSlice(__pyx_v_fields, 1, 0, NULL, NULL, &__pyx_slice__49, 1, 0, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1549, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      if (likely(PyList_CheckExact(__pyx_t_2)) || PyTuple_CheckExact(__pyx_t_2)) {
        __pyx_t_3 = __pyx_t_2; __Pyx_INCREF(__pyx_t_3); __pyx_t_10 = 0;
        __pyx_t_11 = NULL;
      } else {
        __pyx_t_10 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1549, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_11 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_11)) __PYX_ERR(0, 1549, __pyx_L1_error)
      }
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      for (;;) {
        if (likely(!__pyx_t_11)) {
          if (likely(PyList_CheckExact(__pyx_t_3))) {
            if (__pyx_t_10 >= PyList_GET_SIZE(__pyx_t_3)) break;
            #if CYTHON_COMPILING_IN_CPYTHON
            __pyx_t_2 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_10); __Pyx_INCREF(__pyx_t_2); __pyx_t_10++; if (unlikely(0 < 0)) __PYX_ERR(0, 1549, __pyx_L1_error)
            #else
            __pyx_t_2 = PySequence_ITEM(__pyx_t_3, __pyx_t_10); __pyx_t_10++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1549, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_2);
            #endif
          } else {
            if (__pyx_t_10 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
            #if CYTHON_COMPILING_IN_CPYTHON
            __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_10); __Pyx_INCREF(__pyx_t_2); __pyx_t_10++; if (unlikely(0 < 0)) __PYX_ERR(0, 1549, __pyx_L1_error)
            #else
            __pyx_t_2 = PySequence_ITEM(__pyx_t_3, __pyx_t_10); __pyx_t_10++; if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1549, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_2);
            #endif
          }
        } else {
          __pyx_t_2 = __pyx_t_11(__pyx_t_3);
          if (unlikely(!__pyx_t_2)) {
            PyObject* exc_type = PyErr_Occurred();
            if (exc_type) {
              if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
              else __PYX_ERR(0, 1549, __pyx_L1_error)
            }
            break;
          }
          __Pyx_GOTREF(__pyx_t_2);
        }
        __Pyx_XDECREF_SET(__pyx_v_field, __pyx_t_2);
        __pyx_t_2 = 0;
        __Pyx_INCREF(__pyx_t_8);
        __Pyx_XDECREF_SET(__pyx_v_idx, __pyx_t_8);
        __pyx_t_2 = __Pyx_PyInt_AddObjC(__pyx_t_8, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1549, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_8);
        __pyx_t_8 = __pyx_t_2;
        __pyx_t_2 = 0;

        /* "pysam/calignmentfile.pyx":1550
 * 
 *                     for idx, field in enumerate(fields[1:]):
 *                         if ":" not in field:             # <<<<<<<<<<<<<<
 *                             raise ValueError("malformatted header: no ':' in field" )
 *                         key, value = field.split(":", 1)
 */
        __pyx_t_5 = (__Pyx_PySequence_ContainsTF(__pyx_kp_s__50, __pyx_v_field, Py_NE)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1550, __pyx_L1_error)
        __pyx_t_4 = (__pyx_t_5 != 0);
        if (__pyx_t_4) {

          /* "pysam/calignmentfile.pyx":1551
 *                     for idx, field in enumerate(fields[1:]):
 *                         if ":" not in field:
 *                             raise ValueError("malformatted header: no ':' in field" )             # <<<<<<<<<<<<<<
 *                         key, value = field.split(":", 1)
 *                         if key in ("CL",):
 */
          __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__51, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1551, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_Raise(__pyx_t_2, 0, 0, 0);
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
          __PYX_ERR(0, 1551, __pyx_L1_error)

          /* "pysam/calignmentfile.pyx":1550
 * 
 *                     for idx, field in enumerate(fields[1:]):
 *                         if ":" not in field:             # <<<<<<<<<<<<<<
 *                             raise ValueError("malformatted header: no ':' in field" )
 *                         key, value = field.split(":", 1)
 */
        }

        /* "pysam/calignmentfile.pyx":1552
 *                         if ":" not in field:
 *                             raise ValueError("malformatted header: no ':' in field" )
 *                         key, value = field.split(":", 1)             # <<<<<<<<<<<<<<
 *                         if key in ("CL",):
 *                             # special treatment for command line
 */
        __pyx_t_2 = __Pyx_PyObject_GetAttrStr(__pyx_v_field, __pyx_n_s_split); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1552, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __pyx_t_12 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_tuple__52, NULL); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 1552, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_12);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        if ((likely(PyTuple_CheckExact(__pyx_t_12))) || (PyList_CheckExact(__pyx_t_12))) {
          PyObject* sequence = __pyx_t_12;
          #if CYTHON_COMPILING_IN_CPYTHON
          Py_ssize_t size = Py_SIZE(sequence);
          #else
          Py_ssize_t size = PySequence_Size(sequence);
          #endif
          if (unlikely(size != 2)) {
            if (size > 2) __Pyx_RaiseTooManyValuesError(2);
            else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
            __PYX_ERR(0, 1552, __pyx_L1_error)
          }
          #if CYTHON_COMPILING_IN_CPYTHON
          if (likely(PyTuple_CheckExact(sequence))) {
            __pyx_t_2 = PyTuple_GET_ITEM(sequence, 0); 
            __pyx_t_13 = PyTuple_GET_ITEM(sequence, 1); 
          } else {
            __pyx_t_2 = PyList_GET_ITEM(sequence, 0); 
            __pyx_t_13 = PyList_GET_ITEM(sequence, 1); 
          }
          __Pyx_INCREF(__pyx_t_2);
          __Pyx_INCREF(__pyx_t_13);
          #else
          __pyx_t_2 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1552, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          __pyx_t_13 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 1552, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_13);
          #endif
          __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
        } else {
          Py_ssize_t index = -1;
          __pyx_t_14 = PyObject_GetIter(__pyx_t_12); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 1552, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_14);
          __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
          __pyx_t_15 = Py_TYPE(__pyx_t_14)->tp_iternext;
          index = 0; __pyx_t_2 = __pyx_t_15(__pyx_t_14); if (unlikely(!__pyx_t_2)) goto __pyx_L13_unpacking_failed;
          __Pyx_GOTREF(__pyx_t_2);
          index = 1; __pyx_t_13 = __pyx_t_15(__pyx_t_14); if (unlikely(!__pyx_t_13)) goto __pyx_L13_unpacking_failed;
          __Pyx_GOTREF(__pyx_t_13);
          if (__Pyx_IternextUnpackEndCheck(__pyx_t_15(__pyx_t_14), 2) < 0) __PYX_ERR(0, 1552, __pyx_L1_error)
          __pyx_t_15 = NULL;
          __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
          goto __pyx_L14_unpacking_done;
          __pyx_L13_unpacking_failed:;
          __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
          __pyx_t_15 = NULL;
          if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
          __PYX_ERR(0, 1552, __pyx_L1_error)
          __pyx_L14_unpacking_done:;
        }
        __Pyx_XDECREF_SET(__pyx_v_key, __pyx_t_2);
        __pyx_t_2 = 0;
        __Pyx_XDECREF_SET(__pyx_v_value, __pyx_t_13);
        __pyx_t_13 = 0;

        /* "pysam/calignmentfile.pyx":1553
 *                             raise ValueError("malformatted header: no ':' in field" )
 *                         key, value = field.split(":", 1)
 *                         if key in ("CL",):             # <<<<<<<<<<<<<<
 *                             # special treatment for command line
 *                             # statements (CL). These might contain
 */
        __Pyx_INCREF(__pyx_v_key);
        __pyx_t_12 = __pyx_v_key;
        __pyx_t_4 = (__Pyx_PyString_Equals(__pyx_t_12, __pyx_n_s_CL, Py_EQ)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1553, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
        __pyx_t_5 = (__pyx_t_4 != 0);
        if (__pyx_t_5) {

          /* "pysam/calignmentfile.pyx":1560
 *                             # header. Thus, in contravention to the
 *                             # SAM API, consume the rest of the line.
 *                             key, value = "\t".join(fields[idx+1:]).split(":", 1)             # <<<<<<<<<<<<<<
 *                             x[key] = KNOWN_HEADER_FIELDS[record][key](value)
 *                             break
 */
          __pyx_t_12 = __Pyx_PyInt_AddObjC(__pyx_v_idx, __pyx_int_1, 1, 0); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 1560, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_12);
          __pyx_t_13 = __Pyx_PyObject_GetSlice(__pyx_v_fields, 0, 0, &__pyx_t_12, NULL, NULL, 0, 0, 1); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 1560, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_13);
          __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
          __pyx_t_12 = __Pyx_PyString_Join(__pyx_kp_s__2, __pyx_t_13); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 1560, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_12);
          __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
          __pyx_t_13 = __Pyx_PyObject_GetAttrStr(__pyx_t_12, __pyx_n_s_split); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 1560, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_13);
          __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
          __pyx_t_12 = __Pyx_PyObject_Call(__pyx_t_13, __pyx_tuple__53, NULL); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 1560, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_12);
          __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
          if ((likely(PyTuple_CheckExact(__pyx_t_12))) || (PyList_CheckExact(__pyx_t_12))) {
            PyObject* sequence = __pyx_t_12;
            #if CYTHON_COMPILING_IN_CPYTHON
            Py_ssize_t size = Py_SIZE(sequence);
            #else
            Py_ssize_t size = PySequence_Size(sequence);
            #endif
            if (unlikely(size != 2)) {
              if (size > 2) __Pyx_RaiseTooManyValuesError(2);
              else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
              __PYX_ERR(0, 1560, __pyx_L1_error)
            }
            #if CYTHON_COMPILING_IN_CPYTHON
            if (likely(PyTuple_CheckExact(sequence))) {
              __pyx_t_13 = PyTuple_GET_ITEM(sequence, 0); 
              __pyx_t_2 = PyTuple_GET_ITEM(sequence, 1); 
            } else {
              __pyx_t_13 = PyList_GET_ITEM(sequence, 0); 
              __pyx_t_2 = PyList_GET_ITEM(sequence, 1); 
            }
            __Pyx_INCREF(__pyx_t_13);
            __Pyx_INCREF(__pyx_t_2);
            #else
            __pyx_t_13 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 1560, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_13);
            __pyx_t_2 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1560, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_2);
            #endif
            __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
          } else {
            Py_ssize_t index = -1;
            __pyx_t_14 = PyObject_GetIter(__pyx_t_12); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 1560, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_14);
            __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;
            __pyx_t_15 = Py_TYPE(__pyx_t_14)->tp_iternext;
            index = 0; __pyx_t_13 = __pyx_t_15(__pyx_t_14); if (unlikely(!__pyx_t_13)) goto __pyx_L16_unpacking_failed;
            __Pyx_GOTREF(__pyx_t_13);
            index = 1; __pyx_t_2 = __pyx_t_15(__pyx_t_14); if (unlikely(!__pyx_t_2)) goto __pyx_L16_unpacking_failed;
            __Pyx_GOTREF(__pyx_t_2);
            if (__Pyx_IternextUnpackEndCheck(__pyx_t_15(__pyx_t_14), 2) < 0) __PYX_ERR(0, 1560, __pyx_L1_error)
            __pyx_t_15 = NULL;
            __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
            goto __pyx_L17_unpacking_done;
            __pyx_L16_unpacking_failed:;
            __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
            __pyx_t_15 = NULL;
            if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
            __PYX_ERR(0, 1560, __pyx_L1_error)
            __pyx_L17_unpacking_done:;
          }
          __Pyx_DECREF_SET(__pyx_v_key, __pyx_t_13);
          __pyx_t_13 = 0;
          __Pyx_DECREF_SET(__pyx_v_value, __pyx_t_2);
          __pyx_t_2 = 0;

          /* "pysam/calignmentfile.pyx":1561
 *                             # SAM API, consume the rest of the line.
 *                             key, value = "\t".join(fields[idx+1:]).split(":", 1)
 *                             x[key] = KNOWN_HEADER_FIELDS[record][key](value)             # <<<<<<<<<<<<<<
 *                             break
 * 
 */
          __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_KNOWN_HEADER_FIELDS); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1561, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          __pyx_t_13 = PyObject_GetItem(__pyx_t_2, __pyx_v_record); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 1561, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_13);
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
          __pyx_t_2 = PyObject_GetItem(__pyx_t_13, __pyx_v_key); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1561, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
          __pyx_t_13 = NULL;
          if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_2))) {
            __pyx_t_13 = PyMethod_GET_SELF(__pyx_t_2);
            if (likely(__pyx_t_13)) {
              PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
              __Pyx_INCREF(__pyx_t_13);
              __Pyx_INCREF(function);
              __Pyx_DECREF_SET(__pyx_t_2, function);
            }
          }
          if (!__pyx_t_13) {
            __pyx_t_12 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_value); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 1561, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_12);
          } else {
            __pyx_t_14 = PyTuple_New(1+1); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 1561, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_14);
            __Pyx_GIVEREF(__pyx_t_13); PyTuple_SET_ITEM(__pyx_t_14, 0, __pyx_t_13); __pyx_t_13 = NULL;
            __Pyx_INCREF(__pyx_v_value);
            __Pyx_GIVEREF(__pyx_v_value);
            PyTuple_SET_ITEM(__pyx_t_14, 0+1, __pyx_v_value);
            __pyx_t_12 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_14, NULL); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 1561, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_12);
            __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
          }
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
          if (unlikely(PyDict_SetItem(__pyx_v_x, __pyx_v_key, __pyx_t_12) < 0)) __PYX_ERR(0, 1561, __pyx_L1_error)
          __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;

          /* "pysam/calignmentfile.pyx":1562
 *                             key, value = "\t".join(fields[idx+1:]).split(":", 1)
 *                             x[key] = KNOWN_HEADER_FIELDS[record][key](value)
 *                             break             # <<<<<<<<<<<<<<
 * 
 *                         # interpret type of known header record tags, default to str
 */
          goto __pyx_L11_break;

          /* "pysam/calignmentfile.pyx":1553
 *                             raise ValueError("malformatted header: no ':' in field" )
 *                         key, value = field.split(":", 1)
 *                         if key in ("CL",):             # <<<<<<<<<<<<<<
 *                             # special treatment for command line
 *                             # statements (CL). These might contain
 */
        }

        /* "pysam/calignmentfile.pyx":1565
 * 
 *                         # interpret type of known header record tags, default to str
 *                         x[key] = KNOWN_HEADER_FIELDS[record].get(key, str)(value)             # <<<<<<<<<<<<<<
 * 
 *                     if VALID_HEADER_TYPES[record] == dict:
 */
        __pyx_t_14 = __Pyx_GetModuleGlobalName(__pyx_n_s_KNOWN_HEADER_FIELDS); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 1565, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_14);
        __pyx_t_13 = PyObject_GetItem(__pyx_t_14, __pyx_v_record); if (unlikely(!__pyx_t_13)) __PYX_ERR(0, 1565, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_13);
        __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
        __pyx_t_14 = __Pyx_PyObject_GetAttrStr(__pyx_t_13, __pyx_n_s_get); if (unlikely(!__pyx_t_14)) __PYX_ERR(0, 1565, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_14);
        __Pyx_DECREF(__pyx_t_13); __pyx_t_13 = 0;
        __pyx_t_13 = NULL;
        __pyx_t_16 = 0;
        if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_14))) {
          __pyx_t_13 = PyMethod_GET_SELF(__pyx_t_14);
          if (likely(__pyx_t_13)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_14);
            __Pyx_INCREF(__pyx_t_13);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_14, function);
            __pyx_t_16 = 1;
          }
        }
        __pyx_t_17 = PyTuple_New(2+__pyx_t_16); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 1565, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_17);
        if (__pyx_t_13) {
          __Pyx_GIVEREF(__pyx_t_13); PyTuple_SET_ITEM(__pyx_t_17, 0, __pyx_t_13); __pyx_t_13 = NULL;
        }
        __Pyx_INCREF(__pyx_v_key);
        __Pyx_GIVEREF(__pyx_v_key);
        PyTuple_SET_ITEM(__pyx_t_17, 0+__pyx_t_16, __pyx_v_key);
        __Pyx_INCREF(((PyObject *)(&PyString_Type)));
        __Pyx_GIVEREF(((PyObject *)(&PyString_Type)));
        PyTuple_SET_ITEM(__pyx_t_17, 1+__pyx_t_16, ((PyObject *)(&PyString_Type)));
        __pyx_t_2 = __Pyx_PyObject_Call(__pyx_t_14, __pyx_t_17, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1565, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
        __Pyx_DECREF(__pyx_t_14); __pyx_t_14 = 0;
        __pyx_t_14 = NULL;
        if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_2))) {
          __pyx_t_14 = PyMethod_GET_SELF(__pyx_t_2);
          if (likely(__pyx_t_14)) {
            PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
            __Pyx_INCREF(__pyx_t_14);
            __Pyx_INCREF(function);
            __Pyx_DECREF_SET(__pyx_t_2, function);
          }
        }
        if (!__pyx_t_14) {
          __pyx_t_12 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_value); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 1565, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_12);
        } else {
          __pyx_t_17 = PyTuple_New(1+1); if (unlikely(!__pyx_t_17)) __PYX_ERR(0, 1565, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_17);
          __Pyx_GIVEREF(__pyx_t_14); PyTuple_SET_ITEM(__pyx_t_17, 0, __pyx_t_14); __pyx_t_14 = NULL;
          __Pyx_INCREF(__pyx_v_value);
          __Pyx_GIVEREF(__pyx_v_value);
          PyTuple_SET_ITEM(__pyx_t_17, 0+1, __pyx_v_value);
          __pyx_t_12 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_17, NULL); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 1565, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_12);
          __Pyx_DECREF(__pyx_t_17); __pyx_t_17 = 0;
        }
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        if (unlikely(PyDict_SetItem(__pyx_v_x, __pyx_v_key, __pyx_t_12) < 0)) __PYX_ERR(0, 1565, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_12); __pyx_t_12 = 0;

        /* "pysam/calignmentfile.pyx":1549
 *                     x = {}
 * 
 *                     for idx, field in enumerate(fields[1:]):             # <<<<<<<<<<<<<<
 *                         if ":" not in field:
 *                             raise ValueError("malformatted header: no ':' in field" )
 */
      }
      __pyx_L11_break:;
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;

      /* "pysam/calignmentfile.pyx":1567
 *                         x[key] = KNOWN_HEADER_FIELDS[record].get(key, str)(value)
 * 
 *                     if VALID_HEADER_TYPES[record] == dict:             # <<<<<<<<<<<<<<
 *                         if record in result:
 *                             raise ValueError(
 */
      __pyx_t_8 = __Pyx_GetModuleGlobalName(__pyx_n_s_VALID_HEADER_TYPES); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1567, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __pyx_t_3 = PyObject_GetItem(__pyx_t_8, __pyx_v_record); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1567, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __pyx_t_8 = PyObject_RichCompare(__pyx_t_3, ((PyObject *)(&PyDict_Type)), Py_EQ); __Pyx_XGOTREF(__pyx_t_8); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1567, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_8); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1567, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      if (__pyx_t_5) {

        /* "pysam/calignmentfile.pyx":1568
 * 
 *                     if VALID_HEADER_TYPES[record] == dict:
 *                         if record in result:             # <<<<<<<<<<<<<<
 *                             raise ValueError(
 *                                 "multiple '%s' lines are not permitted" % record)
 */
        __pyx_t_5 = (__Pyx_PyDict_ContainsTF(__pyx_v_record, __pyx_v_result, Py_EQ)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1568, __pyx_L1_error)
        __pyx_t_4 = (__pyx_t_5 != 0);
        if (__pyx_t_4) {

          /* "pysam/calignmentfile.pyx":1570
 *                         if record in result:
 *                             raise ValueError(
 *                                 "multiple '%s' lines are not permitted" % record)             # <<<<<<<<<<<<<<
 * 
 *                         result[record] = x
 */
          __pyx_t_8 = __Pyx_PyString_Format(__pyx_kp_s_multiple_s_lines_are_not_permitt, __pyx_v_record); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1570, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_8);

          /* "pysam/calignmentfile.pyx":1569
 *                     if VALID_HEADER_TYPES[record] == dict:
 *                         if record in result:
 *                             raise ValueError(             # <<<<<<<<<<<<<<
 *                                 "multiple '%s' lines are not permitted" % record)
 * 
 */
          __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1569, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_3);
          __Pyx_GIVEREF(__pyx_t_8);
          PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_8);
          __pyx_t_8 = 0;
          __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_3, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1569, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_8);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          __Pyx_Raise(__pyx_t_8, 0, 0, 0);
          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
          __PYX_ERR(0, 1569, __pyx_L1_error)

          /* "pysam/calignmentfile.pyx":1568
 * 
 *                     if VALID_HEADER_TYPES[record] == dict:
 *                         if record in result:             # <<<<<<<<<<<<<<
 *                             raise ValueError(
 *                                 "multiple '%s' lines are not permitted" % record)
 */
        }

        /* "pysam/calignmentfile.pyx":1572
 *                                 "multiple '%s' lines are not permitted" % record)
 * 
 *                         result[record] = x             # <<<<<<<<<<<<<<
 *                     elif VALID_HEADER_TYPES[record] == list:
 *                         if record not in result: result[record] = []
 */
        if (unlikely(PyDict_SetItem(__pyx_v_result, __pyx_v_record, __pyx_v_x) < 0)) __PYX_ERR(0, 1572, __pyx_L1_error)

        /* "pysam/calignmentfile.pyx":1567
 *                         x[key] = KNOWN_HEADER_FIELDS[record].get(key, str)(value)
 * 
 *                     if VALID_HEADER_TYPES[record] == dict:             # <<<<<<<<<<<<<<
 *                         if record in result:
 *                             raise ValueError(
 */
        goto __pyx_L18;
      }

      /* "pysam/calignmentfile.pyx":1573
 * 
 *                         result[record] = x
 *                     elif VALID_HEADER_TYPES[record] == list:             # <<<<<<<<<<<<<<
 *                         if record not in result: result[record] = []
 *                         result[record].append(x)
 */
      __pyx_t_8 = __Pyx_GetModuleGlobalName(__pyx_n_s_VALID_HEADER_TYPES); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1573, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __pyx_t_3 = PyObject_GetItem(__pyx_t_8, __pyx_v_record); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1573, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      __pyx_t_8 = PyObject_RichCompare(__pyx_t_3, ((PyObject *)(&PyList_Type)), Py_EQ); __Pyx_XGOTREF(__pyx_t_8); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1573, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_8); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1573, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      if (__pyx_t_4) {

        /* "pysam/calignmentfile.pyx":1574
 *                         result[record] = x
 *                     elif VALID_HEADER_TYPES[record] == list:
 *                         if record not in result: result[record] = []             # <<<<<<<<<<<<<<
 *                         result[record].append(x)
 * 
 */
        __pyx_t_4 = (__Pyx_PyDict_ContainsTF(__pyx_v_record, __pyx_v_result, Py_NE)); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1574, __pyx_L1_error)
        __pyx_t_5 = (__pyx_t_4 != 0);
        if (__pyx_t_5) {
          __pyx_t_8 = PyList_New(0); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1574, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_8);
          if (unlikely(PyDict_SetItem(__pyx_v_result, __pyx_v_record, __pyx_t_8) < 0)) __PYX_ERR(0, 1574, __pyx_L1_error)
          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
        }

        /* "pysam/calignmentfile.pyx":1575
 *                     elif VALID_HEADER_TYPES[record] == list:
 *                         if record not in result: result[record] = []
 *                         result[record].append(x)             # <<<<<<<<<<<<<<
 * 
 *                 # if there are no SQ lines in the header, add the
 */
        __pyx_t_8 = __Pyx_PyDict_GetItem(__pyx_v_result, __pyx_v_record); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1575, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_8);
        __pyx_t_9 = __Pyx_PyObject_Append(__pyx_t_8, __pyx_v_x); if (unlikely(__pyx_t_9 == -1)) __PYX_ERR(0, 1575, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;

        /* "pysam/calignmentfile.pyx":1573
 * 
 *                         result[record] = x
 *                     elif VALID_HEADER_TYPES[record] == list:             # <<<<<<<<<<<<<<
 *                         if record not in result: result[record] = []
 *                         result[record].append(x)
 */
      }
      __pyx_L18:;

      /* "pysam/calignmentfile.pyx":1531
 *                 # create 0-terminated string)
 *                 t = self.text
 *                 for line in t.split("\n"):             # <<<<<<<<<<<<<<
 *                     if not line.strip(): continue
 *                     assert line.startswith("@"), \
 */
      __pyx_L5_continue:;
    }
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

    /* "pysam/calignmentfile.pyx":1586
 *                 # the SQ information is not part of the textual header
 *                 # and thus are missing from the output. See issue 84.
 *                 if "SQ" not in result:             # <<<<<<<<<<<<<<
 *                     sq = []
 *                     for ref, length in zip(self.references, self.lengths):
 */
    __pyx_t_5 = (__Pyx_PyDict_ContainsTF(__pyx_n_s_SQ, __pyx_v_result, Py_NE)); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1586, __pyx_L1_error)
    __pyx_t_4 = (__pyx_t_5 != 0);
    if (__pyx_t_4) {

      /* "pysam/calignmentfile.pyx":1587
 *                 # and thus are missing from the output. See issue 84.
 *                 if "SQ" not in result:
 *                     sq = []             # <<<<<<<<<<<<<<
 *                     for ref, length in zip(self.references, self.lengths):
 *                         sq.append({'LN': length, 'SN': ref })
 */
      __pyx_t_1 = PyList_New(0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1587, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_v_sq = ((PyObject*)__pyx_t_1);
      __pyx_t_1 = 0;

      /* "pysam/calignmentfile.pyx":1588
 *                 if "SQ" not in result:
 *                     sq = []
 *                     for ref, length in zip(self.references, self.lengths):             # <<<<<<<<<<<<<<
 *                         sq.append({'LN': length, 'SN': ref })
 *                     result["SQ"] = sq
 */
      __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_references); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1588, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_8 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_lengths); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1588, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1588, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_GIVEREF(__pyx_t_1);
      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_1);
      __Pyx_GIVEREF(__pyx_t_8);
      PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_t_8);
      __pyx_t_1 = 0;
      __pyx_t_8 = 0;
      __pyx_t_8 = __Pyx_PyObject_Call(__pyx_builtin_zip, __pyx_t_3, NULL); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1588, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      if (likely(PyList_CheckExact(__pyx_t_8)) || PyTuple_CheckExact(__pyx_t_8)) {
        __pyx_t_3 = __pyx_t_8; __Pyx_INCREF(__pyx_t_3); __pyx_t_6 = 0;
        __pyx_t_7 = NULL;
      } else {
        __pyx_t_6 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_8); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1588, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_7 = Py_TYPE(__pyx_t_3)->tp_iternext; if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 1588, __pyx_L1_error)
      }
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      for (;;) {
        if (likely(!__pyx_t_7)) {
          if (likely(PyList_CheckExact(__pyx_t_3))) {
            if (__pyx_t_6 >= PyList_GET_SIZE(__pyx_t_3)) break;
            #if CYTHON_COMPILING_IN_CPYTHON
            __pyx_t_8 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_6); __Pyx_INCREF(__pyx_t_8); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 1588, __pyx_L1_error)
            #else
            __pyx_t_8 = PySequence_ITEM(__pyx_t_3, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1588, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_8);
            #endif
          } else {
            if (__pyx_t_6 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
            #if CYTHON_COMPILING_IN_CPYTHON
            __pyx_t_8 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_6); __Pyx_INCREF(__pyx_t_8); __pyx_t_6++; if (unlikely(0 < 0)) __PYX_ERR(0, 1588, __pyx_L1_error)
            #else
            __pyx_t_8 = PySequence_ITEM(__pyx_t_3, __pyx_t_6); __pyx_t_6++; if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1588, __pyx_L1_error)
            __Pyx_GOTREF(__pyx_t_8);
            #endif
          }
        } else {
          __pyx_t_8 = __pyx_t_7(__pyx_t_3);
          if (unlikely(!__pyx_t_8)) {
            PyObject* exc_type = PyErr_Occurred();
            if (exc_type) {
              if (likely(exc_type == PyExc_StopIteration || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration))) PyErr_Clear();
              else __PYX_ERR(0, 1588, __pyx_L1_error)
            }
            break;
          }
          __Pyx_GOTREF(__pyx_t_8);
        }
        if ((likely(PyTuple_CheckExact(__pyx_t_8))) || (PyList_CheckExact(__pyx_t_8))) {
          PyObject* sequence = __pyx_t_8;
          #if CYTHON_COMPILING_IN_CPYTHON
          Py_ssize_t size = Py_SIZE(sequence);
          #else
          Py_ssize_t size = PySequence_Size(sequence);
          #endif
          if (unlikely(size != 2)) {
            if (size > 2) __Pyx_RaiseTooManyValuesError(2);
            else if (size >= 0) __Pyx_RaiseNeedMoreValuesError(size);
            __PYX_ERR(0, 1588, __pyx_L1_error)
          }
          #if CYTHON_COMPILING_IN_CPYTHON
          if (likely(PyTuple_CheckExact(sequence))) {
            __pyx_t_1 = PyTuple_GET_ITEM(sequence, 0); 
            __pyx_t_12 = PyTuple_GET_ITEM(sequence, 1); 
          } else {
            __pyx_t_1 = PyList_GET_ITEM(sequence, 0); 
            __pyx_t_12 = PyList_GET_ITEM(sequence, 1); 
          }
          __Pyx_INCREF(__pyx_t_1);
          __Pyx_INCREF(__pyx_t_12);
          #else
          __pyx_t_1 = PySequence_ITEM(sequence, 0); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1588, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_1);
          __pyx_t_12 = PySequence_ITEM(sequence, 1); if (unlikely(!__pyx_t_12)) __PYX_ERR(0, 1588, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_12);
          #endif
          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
        } else {
          Py_ssize_t index = -1;
          __pyx_t_2 = PyObject_GetIter(__pyx_t_8); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1588, __pyx_L1_error)
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
          __pyx_t_15 = Py_TYPE(__pyx_t_2)->tp_iternext;
          index = 0; __pyx_t_1 = __pyx_t_15(__pyx_t_2); if (unlikely(!__pyx_t_1)) goto __pyx_L24_unpacking_failed;
          __Pyx_GOTREF(__pyx_t_1);
          index = 1; __pyx_t_12 = __pyx_t_15(__pyx_t_2); if (unlikely(!__pyx_t_12)) goto __pyx_L24_unpacking_failed;
          __Pyx_GOTREF(__pyx_t_12);
          if (__Pyx_IternextUnpackEndCheck(__pyx_t_15(__pyx_t_2), 2) < 0) __PYX_ERR(0, 1588, __pyx_L1_error)
          __pyx_t_15 = NULL;
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
          goto __pyx_L25_unpacking_done;
          __pyx_L24_unpacking_failed:;
          __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
          __pyx_t_15 = NULL;
          if (__Pyx_IterFinish() == 0) __Pyx_RaiseNeedMoreValuesError(index);
          __PYX_ERR(0, 1588, __pyx_L1_error)
          __pyx_L25_unpacking_done:;
        }
        __Pyx_XDECREF_SET(__pyx_v_ref, __pyx_t_1);
        __pyx_t_1 = 0;
        __Pyx_XDECREF_SET(__pyx_v_length, __pyx_t_12);
        __pyx_t_12 = 0;

        /* "pysam/calignmentfile.pyx":1589
 *                     sq = []
 *                     for ref, length in zip(self.references, self.lengths):
 *                         sq.append({'LN': length, 'SN': ref })             # <<<<<<<<<<<<<<
 *                     result["SQ"] = sq
 * 
 */
        __pyx_t_8 = PyDict_New(); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 1589, __pyx_L1_error)
        __Pyx_GOTREF(__pyx_t_8);
        if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_LN, __pyx_v_length) < 0) __PYX_ERR(0, 1589, __pyx_L1_error)
        if (PyDict_SetItem(__pyx_t_8, __pyx_n_s_SN, __pyx_v_ref) < 0) __PYX_ERR(0, 1589, __pyx_L1_error)
        __pyx_t_9 = __Pyx_PyList_Append(__pyx_v_sq, __pyx_t_8); if (unlikely(__pyx_t_9 == -1)) __PYX_ERR(0, 1589, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;

        /* "pysam/calignmentfile.pyx":1588
 *                 if "SQ" not in result:
 *                     sq = []
 *                     for ref, length in zip(self.references, self.lengths):             # <<<<<<<<<<<<<<
 *                         sq.append({'LN': length, 'SN': ref })
 *                     result["SQ"] = sq
 */
      }
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

      /* "pysam/calignmentfile.pyx":1590
 *                     for ref, length in zip(self.references, self.lengths):
 *                         sq.append({'LN': length, 'SN': ref })
 *                     result["SQ"] = sq             # <<<<<<<<<<<<<<
 * 
 *             return result
 */
      if (unlikely(PyDict_SetItem(__pyx_v_result, __pyx_n_s_SQ, __pyx_v_sq) < 0)) __PYX_ERR(0, 1590, __pyx_L1_error)

      /* "pysam/calignmentfile.pyx":1586
 *                 # the SQ information is not part of the textual header
 *                 # and thus are missing from the output. See issue 84.
 *                 if "SQ" not in result:             # <<<<<<<<<<<<<<
 *                     sq = []
 *                     for ref, length in zip(self.references, self.lengths):
 */
    }

    /* "pysam/calignmentfile.pyx":1527
 *             result = {}
 * 
 *             if self.header.text != NULL:             # <<<<<<<<<<<<<<
 *                 # convert to python string (note: call self.text to
 *                 # create 0-terminated string)
 */
  }

  /* "pysam/calignmentfile.pyx":1592
 *                     result["SQ"] = sq
 * 
 *             return result             # <<<<<<<<<<<<<<
 * 
 *     ###############################################################
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_result);
  __pyx_r = __pyx_v_result;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1521
 * 
 *         """
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             if not self.is_open():
 *                 raise ValueError( "I/O operation on closed file" )
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_12);
  __Pyx_XDECREF(__pyx_t_13);
  __Pyx_XDECREF(__pyx_t_14);
  __Pyx_XDECREF(__pyx_t_17);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.header.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_result);
  __Pyx_XDECREF(__pyx_v_t);
  __Pyx_XDECREF(__pyx_v_line);
  __Pyx_XDECREF(__pyx_v_fields);
  __Pyx_XDECREF(__pyx_v_record);
  __Pyx_XDECREF(__pyx_v_x);
  __Pyx_XDECREF(__pyx_v_idx);
  __Pyx_XDECREF(__pyx_v_field);
  __Pyx_XDECREF(__pyx_v_key);
  __Pyx_XDECREF(__pyx_v_value);
  __Pyx_XDECREF(__pyx_v_sq);
  __Pyx_XDECREF(__pyx_v_ref);
  __Pyx_XDECREF(__pyx_v_length);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1599
 *     ## and multiple_iterators)
 *     ## Possible solutions: deprecate or open new file handle
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_45__iter__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_45__iter__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__iter__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_44__iter__(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_44__iter__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("__iter__", 0);
  __Pyx_TraceCall("__iter__", __pyx_f[0], 1599, 0, __PYX_ERR(0, 1599, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1600
 *     ## Possible solutions: deprecate or open new file handle
 *     def __iter__(self):
 *         if not self.is_open():             # <<<<<<<<<<<<<<
 *             raise ValueError("I/O operation on closed file")
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_is_open); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1600, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1600, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1600, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1600, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = ((!__pyx_t_4) != 0);
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":1601
 *     def __iter__(self):
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")             # <<<<<<<<<<<<<<
 * 
 *         if not self.is_bam and self.header.n_targets == 0:
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__54, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1601, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 1601, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":1600
 *     ## Possible solutions: deprecate or open new file handle
 *     def __iter__(self):
 *         if not self.is_open():             # <<<<<<<<<<<<<<
 *             raise ValueError("I/O operation on closed file")
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":1603
 *             raise ValueError("I/O operation on closed file")
 * 
 *         if not self.is_bam and self.header.n_targets == 0:             # <<<<<<<<<<<<<<
 *             raise NotImplementedError(
 *                 "can not iterate over samfile without header")
 */
  __pyx_t_4 = ((!(__pyx_v_self->is_bam != 0)) != 0);
  if (__pyx_t_4) {
  } else {
    __pyx_t_5 = __pyx_t_4;
    goto __pyx_L5_bool_binop_done;
  }
  __pyx_t_4 = ((__pyx_v_self->header->n_targets == 0) != 0);
  __pyx_t_5 = __pyx_t_4;
  __pyx_L5_bool_binop_done:;
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":1604
 * 
 *         if not self.is_bam and self.header.n_targets == 0:
 *             raise NotImplementedError(             # <<<<<<<<<<<<<<
 *                 "can not iterate over samfile without header")
 *         return self
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_NotImplementedError, __pyx_tuple__55, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1604, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 1604, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":1603
 *             raise ValueError("I/O operation on closed file")
 * 
 *         if not self.is_bam and self.header.n_targets == 0:             # <<<<<<<<<<<<<<
 *             raise NotImplementedError(
 *                 "can not iterate over samfile without header")
 */
  }

  /* "pysam/calignmentfile.pyx":1606
 *             raise NotImplementedError(
 *                 "can not iterate over samfile without header")
 *         return self             # <<<<<<<<<<<<<<
 * 
 *     cdef bam1_t * getCurrent( self ):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __pyx_r = ((PyObject *)__pyx_v_self);
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1599
 *     ## and multiple_iterators)
 *     ## Possible solutions: deprecate or open new file handle
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.__iter__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1608
 *         return self
 * 
 *     cdef bam1_t * getCurrent( self ):             # <<<<<<<<<<<<<<
 *         return self.b
 * 
 */

static bam1_t *__pyx_f_5pysam_14calignmentfile_13AlignmentFile_getCurrent(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  bam1_t *__pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getCurrent", 0);
  __Pyx_TraceCall("getCurrent", __pyx_f[0], 1608, 0, __PYX_ERR(0, 1608, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1609
 * 
 *     cdef bam1_t * getCurrent( self ):
 *         return self.b             # <<<<<<<<<<<<<<
 * 
 *     cdef int cnext(self):
 */
  __pyx_r = __pyx_v_self->b;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1608
 *         return self
 * 
 *     cdef bam1_t * getCurrent( self ):             # <<<<<<<<<<<<<<
 *         return self.b
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("pysam.calignmentfile.AlignmentFile.getCurrent", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1611
 *         return self.b
 * 
 *     cdef int cnext(self):             # <<<<<<<<<<<<<<
 *         '''
 *         cversion of iterator. Used by :class:`pysam.AlignmentFile.IteratorColumn`.
 */

static int __pyx_f_5pysam_14calignmentfile_13AlignmentFile_cnext(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  int __pyx_v_ret;
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cnext", 0);
  __Pyx_TraceCall("cnext", __pyx_f[0], 1611, 0, __PYX_ERR(0, 1611, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1616
 *         '''
 *         cdef int ret
 *         with nogil:             # <<<<<<<<<<<<<<
 *             ret = sam_read1(self.htsfile,
 *                             self.header,
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "pysam/calignmentfile.pyx":1617
 *         cdef int ret
 *         with nogil:
 *             ret = sam_read1(self.htsfile,             # <<<<<<<<<<<<<<
 *                             self.header,
 *                             self.b)
 */
        __pyx_v_ret = sam_read1(__pyx_v_self->htsfile, __pyx_v_self->header, __pyx_v_self->b);
      }

      /* "pysam/calignmentfile.pyx":1616
 *         '''
 *         cdef int ret
 *         with nogil:             # <<<<<<<<<<<<<<
 *             ret = sam_read1(self.htsfile,
 *                             self.header,
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L5:;
      }
  }

  /* "pysam/calignmentfile.pyx":1620
 *                             self.header,
 *                             self.b)
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def __next__(self):
 */
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1611
 *         return self.b
 * 
 *     cdef int cnext(self):             # <<<<<<<<<<<<<<
 *         '''
 *         cversion of iterator. Used by :class:`pysam.AlignmentFile.IteratorColumn`.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("pysam.calignmentfile.AlignmentFile.cnext", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1622
 *         return ret
 * 
 *     def __next__(self):             # <<<<<<<<<<<<<<
 *         cdef int ret = self.cnext()
 *         if (ret >= 0):
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_47__next__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_47__next__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__next__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_46__next__(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_46__next__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  int __pyx_v_ret;
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("__next__", 0);
  __Pyx_TraceCall("__next__", __pyx_f[0], 1622, 0, __PYX_ERR(0, 1622, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1623
 * 
 *     def __next__(self):
 *         cdef int ret = self.cnext()             # <<<<<<<<<<<<<<
 *         if (ret >= 0):
 *             return makeAlignedSegment(self.b, self)
 */
  __pyx_v_ret = ((struct __pyx_vtabstruct_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self->__pyx_vtab)->cnext(__pyx_v_self);

  /* "pysam/calignmentfile.pyx":1624
 *     def __next__(self):
 *         cdef int ret = self.cnext()
 *         if (ret >= 0):             # <<<<<<<<<<<<<<
 *             return makeAlignedSegment(self.b, self)
 *         elif ret == -2:
 */
  __pyx_t_1 = ((__pyx_v_ret >= 0) != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":1625
 *         cdef int ret = self.cnext()
 *         if (ret >= 0):
 *             return makeAlignedSegment(self.b, self)             # <<<<<<<<<<<<<<
 *         elif ret == -2:
 *             raise IOError('truncated file')
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __pyx_f_5pysam_15calignedsegment_makeAlignedSegment(__pyx_v_self->b, __pyx_v_self); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1625, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;

    /* "pysam/calignmentfile.pyx":1624
 *     def __next__(self):
 *         cdef int ret = self.cnext()
 *         if (ret >= 0):             # <<<<<<<<<<<<<<
 *             return makeAlignedSegment(self.b, self)
 *         elif ret == -2:
 */
  }

  /* "pysam/calignmentfile.pyx":1626
 *         if (ret >= 0):
 *             return makeAlignedSegment(self.b, self)
 *         elif ret == -2:             # <<<<<<<<<<<<<<
 *             raise IOError('truncated file')
 *         else:
 */
  __pyx_t_1 = ((__pyx_v_ret == -2L) != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":1627
 *             return makeAlignedSegment(self.b, self)
 *         elif ret == -2:
 *             raise IOError('truncated file')             # <<<<<<<<<<<<<<
 *         else:
 *             raise StopIteration
 */
    __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_IOError, __pyx_tuple__56, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1627, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __PYX_ERR(0, 1627, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":1626
 *         if (ret >= 0):
 *             return makeAlignedSegment(self.b, self)
 *         elif ret == -2:             # <<<<<<<<<<<<<<
 *             raise IOError('truncated file')
 *         else:
 */
  }

  /* "pysam/calignmentfile.pyx":1629
 *             raise IOError('truncated file')
 *         else:
 *             raise StopIteration             # <<<<<<<<<<<<<<
 * 
 *     # Compatibility functions for pysam < 0.8.3
 */
  /*else*/ {
    __Pyx_Raise(__pyx_builtin_StopIteration, 0, 0, 0);
    __PYX_ERR(0, 1629, __pyx_L1_error)
  }

  /* "pysam/calignmentfile.pyx":1622
 *         return ret
 * 
 *     def __next__(self):             # <<<<<<<<<<<<<<
 *         cdef int ret = self.cnext()
 *         if (ret >= 0):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.__next__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1632
 * 
 *     # Compatibility functions for pysam < 0.8.3
 *     def gettid(self, reference):             # <<<<<<<<<<<<<<
 *         """deprecated, use get_tid() instead"""
 *         return self.get_tid(reference)
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_49gettid(PyObject *__pyx_v_self, PyObject *__pyx_v_reference); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_48gettid[] = "AlignmentFile.gettid(self, reference)\ndeprecated, use get_tid() instead";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_49gettid(PyObject *__pyx_v_self, PyObject *__pyx_v_reference) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("gettid (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_48gettid(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self), ((PyObject *)__pyx_v_reference));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_48gettid(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_reference) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("gettid", 0);
  __Pyx_TraceCall("gettid", __pyx_f[0], 1632, 0, __PYX_ERR(0, 1632, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1634
 *     def gettid(self, reference):
 *         """deprecated, use get_tid() instead"""
 *         return self.get_tid(reference)             # <<<<<<<<<<<<<<
 * 
 *     def getrname(self, tid):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_get_tid); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1634, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (!__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_reference); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1634, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    __pyx_t_4 = PyTuple_New(1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1634, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3); __pyx_t_3 = NULL;
    __Pyx_INCREF(__pyx_v_reference);
    __Pyx_GIVEREF(__pyx_v_reference);
    PyTuple_SET_ITEM(__pyx_t_4, 0+1, __pyx_v_reference);
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1634, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1632
 * 
 *     # Compatibility functions for pysam < 0.8.3
 *     def gettid(self, reference):             # <<<<<<<<<<<<<<
 *         """deprecated, use get_tid() instead"""
 *         return self.get_tid(reference)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.gettid", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1636
 *         return self.get_tid(reference)
 * 
 *     def getrname(self, tid):             # <<<<<<<<<<<<<<
 *         """deprecated, use get_reference_name() instead"""
 *         return self.get_reference_name(tid)
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_51getrname(PyObject *__pyx_v_self, PyObject *__pyx_v_tid); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_50getrname[] = "AlignmentFile.getrname(self, tid)\ndeprecated, use get_reference_name() instead";
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_51getrname(PyObject *__pyx_v_self, PyObject *__pyx_v_tid) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getrname (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_50getrname(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self), ((PyObject *)__pyx_v_tid));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_50getrname(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self, PyObject *__pyx_v_tid) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("getrname", 0);
  __Pyx_TraceCall("getrname", __pyx_f[0], 1636, 0, __PYX_ERR(0, 1636, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1638
 *     def getrname(self, tid):
 *         """deprecated, use get_reference_name() instead"""
 *         return self.get_reference_name(tid)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_get_reference_name); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1638, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (!__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_v_tid); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1638, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    __pyx_t_4 = PyTuple_New(1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1638, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_3); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3); __pyx_t_3 = NULL;
    __Pyx_INCREF(__pyx_v_tid);
    __Pyx_GIVEREF(__pyx_v_tid);
    PyTuple_SET_ITEM(__pyx_t_4, 0+1, __pyx_v_tid);
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_2, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1638, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  }
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1636
 *         return self.get_tid(reference)
 * 
 *     def getrname(self, tid):             # <<<<<<<<<<<<<<
 *         """deprecated, use get_reference_name() instead"""
 *         return self.get_reference_name(tid)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.getrname", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pxd":51
 *     cdef bam_hdr_t * header
 *     # true if file is bam format
 *     cdef readonly bint is_bam             # <<<<<<<<<<<<<<
 *     # true if file is bam format
 *     cdef readonly bint is_cram
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_6is_bam_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_6is_bam_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_6is_bam___get__(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_6is_bam___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[1], 51, 0, __PYX_ERR(1, 51, __pyx_L1_error));
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->is_bam); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 51, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.is_bam.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pxd":53
 *     cdef readonly bint is_bam
 *     # true if file is bam format
 *     cdef readonly bint is_cram             # <<<<<<<<<<<<<<
 *     # true if not a file but a stream
 *     cdef readonly bint is_stream
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_7is_cram_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_7is_cram_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_7is_cram___get__(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_7is_cram___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[1], 53, 0, __PYX_ERR(1, 53, __pyx_L1_error));
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->is_cram); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 53, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.is_cram.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pxd":55
 *     cdef readonly bint is_cram
 *     # true if not a file but a stream
 *     cdef readonly bint is_stream             # <<<<<<<<<<<<<<
 *     # true if file is not on the local filesystem
 *     cdef readonly bint is_remote
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_9is_stream_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_9is_stream_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_9is_stream___get__(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_9is_stream___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[1], 55, 0, __PYX_ERR(1, 55, __pyx_L1_error));
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->is_stream); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 55, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.is_stream.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pxd":57
 *     cdef readonly bint is_stream
 *     # true if file is not on the local filesystem
 *     cdef readonly bint is_remote             # <<<<<<<<<<<<<<
 *     # current read within iteration
 *     cdef bam1_t * b
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_9is_remote_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_9is_remote_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_13AlignmentFile_9is_remote___get__(((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_13AlignmentFile_9is_remote___get__(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[1], 57, 0, __PYX_ERR(1, 57, __pyx_L1_error));
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong(__pyx_v_self->is_remote); if (unlikely(!__pyx_t_1)) __PYX_ERR(1, 57, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pysam.calignmentfile.AlignmentFile.is_remote.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1666
 *     '''
 * 
 *     def __init__(self, AlignmentFile samfile, int multiple_iterators=False):             # <<<<<<<<<<<<<<
 *         cdef char *cfilename
 * 
 */

/* Python wrapper */
static int __pyx_pw_5pysam_14calignmentfile_11IteratorRow_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_5pysam_14calignmentfile_11IteratorRow_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile = 0;
  int __pyx_v_multiple_iterators;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_samfile,&__pyx_n_s_multiple_iterators,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_samfile)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_multiple_iterators);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 1666, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_samfile = ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)values[0]);
    if (values[1]) {
      __pyx_v_multiple_iterators = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_multiple_iterators == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 1666, __pyx_L3_error)
    } else {
      __pyx_v_multiple_iterators = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1666, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRow.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_samfile), __pyx_ptype_5pysam_14calignmentfile_AlignmentFile, 1, "samfile", 0))) __PYX_ERR(0, 1666, __pyx_L1_error)
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_11IteratorRow___init__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorRow *)__pyx_v_self), __pyx_v_samfile, __pyx_v_multiple_iterators);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_5pysam_14calignmentfile_11IteratorRow___init__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRow *__pyx_v_self, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile, int __pyx_v_multiple_iterators) {
  char *__pyx_v_cfilename;
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  char *__pyx_t_6;
  htsFile *__pyx_t_7;
  bam_hdr_t *__pyx_t_8;
  __Pyx_RefNannySetupContext("__init__", 0);
  __Pyx_TraceCall("__init__", __pyx_f[0], 1666, 0, __PYX_ERR(0, 1666, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1669
 *         cdef char *cfilename
 * 
 *         if not samfile.is_open():             # <<<<<<<<<<<<<<
 *             raise ValueError("I/O operation on closed file")
 * 
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_samfile), __pyx_n_s_is_open); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1669, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
    __pyx_t_3 = PyMethod_GET_SELF(__pyx_t_2);
    if (likely(__pyx_t_3)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
      __Pyx_INCREF(__pyx_t_3);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_2, function);
    }
  }
  if (__pyx_t_3) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1669, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  } else {
    __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1669, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_4 < 0)) __PYX_ERR(0, 1669, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = ((!__pyx_t_4) != 0);
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":1670
 * 
 *         if not samfile.is_open():
 *             raise ValueError("I/O operation on closed file")             # <<<<<<<<<<<<<<
 * 
 *         # makes sure that samfile stays alive as long as the
 */
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__57, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1670, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_Raise(__pyx_t_1, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __PYX_ERR(0, 1670, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":1669
 *         cdef char *cfilename
 * 
 *         if not samfile.is_open():             # <<<<<<<<<<<<<<
 *             raise ValueError("I/O operation on closed file")
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":1674
 *         # makes sure that samfile stays alive as long as the
 *         # iterator is alive
 *         self.samfile = samfile             # <<<<<<<<<<<<<<
 * 
 *         # reopen the file - note that this makes the iterator
 */
  __Pyx_INCREF(((PyObject *)__pyx_v_samfile));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_samfile));
  __Pyx_GOTREF(__pyx_v_self->samfile);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->samfile));
  __pyx_v_self->samfile = __pyx_v_samfile;

  /* "pysam/calignmentfile.pyx":1678
 *         # reopen the file - note that this makes the iterator
 *         # slow and causes pileup to slow down significantly.
 *         if multiple_iterators:             # <<<<<<<<<<<<<<
 *             cfilename = samfile._filename
 *             with nogil:
 */
  __pyx_t_5 = (__pyx_v_multiple_iterators != 0);
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":1679
 *         # slow and causes pileup to slow down significantly.
 *         if multiple_iterators:
 *             cfilename = samfile._filename             # <<<<<<<<<<<<<<
 *             with nogil:
 *                 self.htsfile = hts_open(cfilename, 'r')
 */
    __pyx_t_6 = __Pyx_PyObject_AsString(__pyx_v_samfile->_filename); if (unlikely((!__pyx_t_6) && PyErr_Occurred())) __PYX_ERR(0, 1679, __pyx_L1_error)
    __pyx_v_cfilename = __pyx_t_6;

    /* "pysam/calignmentfile.pyx":1680
 *         if multiple_iterators:
 *             cfilename = samfile._filename
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 self.htsfile = hts_open(cfilename, 'r')
 *             assert self.htsfile != NULL
 */
    {
        #ifdef WITH_THREAD
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
        #endif
        /*try:*/ {

          /* "pysam/calignmentfile.pyx":1681
 *             cfilename = samfile._filename
 *             with nogil:
 *                 self.htsfile = hts_open(cfilename, 'r')             # <<<<<<<<<<<<<<
 *             assert self.htsfile != NULL
 *             # read header - required for accurate positioning
 */
          __pyx_v_self->htsfile = hts_open(__pyx_v_cfilename, ((char const *)"r"));
        }

        /* "pysam/calignmentfile.pyx":1680
 *         if multiple_iterators:
 *             cfilename = samfile._filename
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 self.htsfile = hts_open(cfilename, 'r')
 *             assert self.htsfile != NULL
 */
        /*finally:*/ {
          /*normal exit:*/{
            #ifdef WITH_THREAD
            Py_BLOCK_THREADS
            #endif
            goto __pyx_L7;
          }
          __pyx_L7:;
        }
    }

    /* "pysam/calignmentfile.pyx":1682
 *             with nogil:
 *                 self.htsfile = hts_open(cfilename, 'r')
 *             assert self.htsfile != NULL             # <<<<<<<<<<<<<<
 *             # read header - required for accurate positioning
 *             # could a tell/seek work?
 */
    #ifndef CYTHON_WITHOUT_ASSERTIONS
    if (unlikely(!Py_OptimizeFlag)) {
      if (unlikely(!((__pyx_v_self->htsfile != NULL) != 0))) {
        PyErr_SetNone(PyExc_AssertionError);
        __PYX_ERR(0, 1682, __pyx_L1_error)
      }
    }
    #endif

    /* "pysam/calignmentfile.pyx":1685
 *             # read header - required for accurate positioning
 *             # could a tell/seek work?
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 self.header = sam_hdr_read(self.htsfile)
 *             assert self.header != NULL
 */
    {
        #ifdef WITH_THREAD
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
        #endif
        /*try:*/ {

          /* "pysam/calignmentfile.pyx":1686
 *             # could a tell/seek work?
 *             with nogil:
 *                 self.header = sam_hdr_read(self.htsfile)             # <<<<<<<<<<<<<<
 *             assert self.header != NULL
 *             self.owns_samfile = True
 */
          __pyx_v_self->header = sam_hdr_read(__pyx_v_self->htsfile);
        }

        /* "pysam/calignmentfile.pyx":1685
 *             # read header - required for accurate positioning
 *             # could a tell/seek work?
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 self.header = sam_hdr_read(self.htsfile)
 *             assert self.header != NULL
 */
        /*finally:*/ {
          /*normal exit:*/{
            #ifdef WITH_THREAD
            Py_BLOCK_THREADS
            #endif
            goto __pyx_L10;
          }
          __pyx_L10:;
        }
    }

    /* "pysam/calignmentfile.pyx":1687
 *             with nogil:
 *                 self.header = sam_hdr_read(self.htsfile)
 *             assert self.header != NULL             # <<<<<<<<<<<<<<
 *             self.owns_samfile = True
 *         else:
 */
    #ifndef CYTHON_WITHOUT_ASSERTIONS
    if (unlikely(!Py_OptimizeFlag)) {
      if (unlikely(!((__pyx_v_self->header != NULL) != 0))) {
        PyErr_SetNone(PyExc_AssertionError);
        __PYX_ERR(0, 1687, __pyx_L1_error)
      }
    }
    #endif

    /* "pysam/calignmentfile.pyx":1688
 *                 self.header = sam_hdr_read(self.htsfile)
 *             assert self.header != NULL
 *             self.owns_samfile = True             # <<<<<<<<<<<<<<
 *         else:
 *             self.htsfile = self.samfile.htsfile
 */
    __pyx_v_self->owns_samfile = 1;

    /* "pysam/calignmentfile.pyx":1678
 *         # reopen the file - note that this makes the iterator
 *         # slow and causes pileup to slow down significantly.
 *         if multiple_iterators:             # <<<<<<<<<<<<<<
 *             cfilename = samfile._filename
 *             with nogil:
 */
    goto __pyx_L4;
  }

  /* "pysam/calignmentfile.pyx":1690
 *             self.owns_samfile = True
 *         else:
 *             self.htsfile = self.samfile.htsfile             # <<<<<<<<<<<<<<
 *             self.owns_samfile = False
 *             self.header = self.samfile.header
 */
  /*else*/ {
    __pyx_t_7 = __pyx_v_self->samfile->htsfile;
    __pyx_v_self->htsfile = __pyx_t_7;

    /* "pysam/calignmentfile.pyx":1691
 *         else:
 *             self.htsfile = self.samfile.htsfile
 *             self.owns_samfile = False             # <<<<<<<<<<<<<<
 *             self.header = self.samfile.header
 * 
 */
    __pyx_v_self->owns_samfile = 0;

    /* "pysam/calignmentfile.pyx":1692
 *             self.htsfile = self.samfile.htsfile
 *             self.owns_samfile = False
 *             self.header = self.samfile.header             # <<<<<<<<<<<<<<
 * 
 *         self.retval = 0
 */
    __pyx_t_8 = __pyx_v_self->samfile->header;
    __pyx_v_self->header = __pyx_t_8;
  }
  __pyx_L4:;

  /* "pysam/calignmentfile.pyx":1694
 *             self.header = self.samfile.header
 * 
 *         self.retval = 0             # <<<<<<<<<<<<<<
 * 
 *         self.b = bam_init1()
 */
  __pyx_v_self->retval = 0;

  /* "pysam/calignmentfile.pyx":1696
 *         self.retval = 0
 * 
 *         self.b = bam_init1()             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  __pyx_v_self->b = bam_init1();

  /* "pysam/calignmentfile.pyx":1666
 *     '''
 * 
 *     def __init__(self, AlignmentFile samfile, int multiple_iterators=False):             # <<<<<<<<<<<<<<
 *         cdef char *cfilename
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRow.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1698
 *         self.b = bam_init1()
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         bam_destroy1(self.b)
 *         if self.owns_samfile:
 */

/* Python wrapper */
static void __pyx_pw_5pysam_14calignmentfile_11IteratorRow_3__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_5pysam_14calignmentfile_11IteratorRow_3__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_5pysam_14calignmentfile_11IteratorRow_2__dealloc__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorRow *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_5pysam_14calignmentfile_11IteratorRow_2__dealloc__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRow *__pyx_v_self) {
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("__dealloc__", 0);
  __Pyx_TraceCall("__dealloc__", __pyx_f[0], 1698, 0, __PYX_ERR(0, 1698, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1699
 * 
 *     def __dealloc__(self):
 *         bam_destroy1(self.b)             # <<<<<<<<<<<<<<
 *         if self.owns_samfile:
 *             hts_close(self.htsfile)
 */
  bam_destroy1(__pyx_v_self->b);

  /* "pysam/calignmentfile.pyx":1700
 *     def __dealloc__(self):
 *         bam_destroy1(self.b)
 *         if self.owns_samfile:             # <<<<<<<<<<<<<<
 *             hts_close(self.htsfile)
 *             bam_hdr_destroy(self.header)
 */
  __pyx_t_1 = (__pyx_v_self->owns_samfile != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":1701
 *         bam_destroy1(self.b)
 *         if self.owns_samfile:
 *             hts_close(self.htsfile)             # <<<<<<<<<<<<<<
 *             bam_hdr_destroy(self.header)
 * 
 */
    hts_close(__pyx_v_self->htsfile);

    /* "pysam/calignmentfile.pyx":1702
 *         if self.owns_samfile:
 *             hts_close(self.htsfile)
 *             bam_hdr_destroy(self.header)             # <<<<<<<<<<<<<<
 * 
 * 
 */
    bam_hdr_destroy(__pyx_v_self->header);

    /* "pysam/calignmentfile.pyx":1700
 *     def __dealloc__(self):
 *         bam_destroy1(self.b)
 *         if self.owns_samfile:             # <<<<<<<<<<<<<<
 *             hts_close(self.htsfile)
 *             bam_hdr_destroy(self.header)
 */
  }

  /* "pysam/calignmentfile.pyx":1698
 *         self.b = bam_init1()
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         bam_destroy1(self.b)
 *         if self.owns_samfile:
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("pysam.calignmentfile.IteratorRow.__dealloc__", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
}

/* "pysam/calignmentfile.pyx":1719
 *     """
 * 
 *     def __init__(self, AlignmentFile samfile,             # <<<<<<<<<<<<<<
 *                  int tid, int beg, int end,
 *                  int multiple_iterators=False):
 */

/* Python wrapper */
static int __pyx_pw_5pysam_14calignmentfile_17IteratorRowRegion_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_5pysam_14calignmentfile_17IteratorRowRegion_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile = 0;
  int __pyx_v_tid;
  int __pyx_v_beg;
  int __pyx_v_end;
  int __pyx_v_multiple_iterators;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_samfile,&__pyx_n_s_tid,&__pyx_n_s_beg,&__pyx_n_s_end,&__pyx_n_s_multiple_iterators,0};
    PyObject* values[5] = {0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_samfile)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_tid)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 0, 4, 5, 1); __PYX_ERR(0, 1719, __pyx_L3_error)
        }
        case  2:
        if (likely((values[2] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_beg)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 0, 4, 5, 2); __PYX_ERR(0, 1719, __pyx_L3_error)
        }
        case  3:
        if (likely((values[3] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_end)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 0, 4, 5, 3); __PYX_ERR(0, 1719, __pyx_L3_error)
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_multiple_iterators);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 1719, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_samfile = ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)values[0]);
    __pyx_v_tid = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_tid == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 1720, __pyx_L3_error)
    __pyx_v_beg = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_beg == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 1720, __pyx_L3_error)
    __pyx_v_end = __Pyx_PyInt_As_int(values[3]); if (unlikely((__pyx_v_end == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 1720, __pyx_L3_error)
    if (values[4]) {
      __pyx_v_multiple_iterators = __Pyx_PyInt_As_int(values[4]); if (unlikely((__pyx_v_multiple_iterators == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 1721, __pyx_L3_error)
    } else {

      /* "pysam/calignmentfile.pyx":1721
 *     def __init__(self, AlignmentFile samfile,
 *                  int tid, int beg, int end,
 *                  int multiple_iterators=False):             # <<<<<<<<<<<<<<
 * 
 *         IteratorRow.__init__(self, samfile,
 */
      __pyx_v_multiple_iterators = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 0, 4, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1719, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRowRegion.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_samfile), __pyx_ptype_5pysam_14calignmentfile_AlignmentFile, 1, "samfile", 0))) __PYX_ERR(0, 1719, __pyx_L1_error)
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_17IteratorRowRegion___init__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *)__pyx_v_self), __pyx_v_samfile, __pyx_v_tid, __pyx_v_beg, __pyx_v_end, __pyx_v_multiple_iterators);

  /* "pysam/calignmentfile.pyx":1719
 *     """
 * 
 *     def __init__(self, AlignmentFile samfile,             # <<<<<<<<<<<<<<
 *                  int tid, int beg, int end,
 *                  int multiple_iterators=False):
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_5pysam_14calignmentfile_17IteratorRowRegion___init__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *__pyx_v_self, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile, int __pyx_v_tid, int __pyx_v_beg, int __pyx_v_end, int __pyx_v_multiple_iterators) {
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  __Pyx_RefNannySetupContext("__init__", 0);
  __Pyx_TraceCall("__init__", __pyx_f[0], 1719, 0, __PYX_ERR(0, 1719, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1723
 *                  int multiple_iterators=False):
 * 
 *         IteratorRow.__init__(self, samfile,             # <<<<<<<<<<<<<<
 *                              multiple_iterators=multiple_iterators)
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_5pysam_14calignmentfile_IteratorRow), __pyx_n_s_init); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1723, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1723, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_self));
  __Pyx_INCREF(((PyObject *)__pyx_v_samfile));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_samfile));
  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_samfile));

  /* "pysam/calignmentfile.pyx":1724
 * 
 *         IteratorRow.__init__(self, samfile,
 *                              multiple_iterators=multiple_iterators)             # <<<<<<<<<<<<<<
 * 
 *         if not samfile.has_index():
 */
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1724, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_multiple_iterators); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1724, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_multiple_iterators, __pyx_t_4) < 0) __PYX_ERR(0, 1724, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pysam/calignmentfile.pyx":1723
 *                  int multiple_iterators=False):
 * 
 *         IteratorRow.__init__(self, samfile,             # <<<<<<<<<<<<<<
 *                              multiple_iterators=multiple_iterators)
 * 
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1723, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pysam/calignmentfile.pyx":1726
 *                              multiple_iterators=multiple_iterators)
 * 
 *         if not samfile.has_index():             # <<<<<<<<<<<<<<
 *             raise ValueError("no index available for iteration")
 * 
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_samfile), __pyx_n_s_has_index); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1726, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (__pyx_t_2) {
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1726, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  } else {
    __pyx_t_4 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1726, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1726, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_6 = ((!__pyx_t_5) != 0);
  if (__pyx_t_6) {

    /* "pysam/calignmentfile.pyx":1727
 * 
 *         if not samfile.has_index():
 *             raise ValueError("no index available for iteration")             # <<<<<<<<<<<<<<
 * 
 *         with nogil:
 */
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__58, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1727, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 1727, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":1726
 *                              multiple_iterators=multiple_iterators)
 * 
 *         if not samfile.has_index():             # <<<<<<<<<<<<<<
 *             raise ValueError("no index available for iteration")
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":1729
 *             raise ValueError("no index available for iteration")
 * 
 *         with nogil:             # <<<<<<<<<<<<<<
 *             self.iter = sam_itr_queryi(
 *                 self.samfile.index,
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "pysam/calignmentfile.pyx":1730
 * 
 *         with nogil:
 *             self.iter = sam_itr_queryi(             # <<<<<<<<<<<<<<
 *                 self.samfile.index,
 *                 tid,
 */
        __pyx_v_self->iter = sam_itr_queryi(__pyx_v_self->__pyx_base.samfile->index, __pyx_v_tid, __pyx_v_beg, __pyx_v_end);
      }

      /* "pysam/calignmentfile.pyx":1729
 *             raise ValueError("no index available for iteration")
 * 
 *         with nogil:             # <<<<<<<<<<<<<<
 *             self.iter = sam_itr_queryi(
 *                 self.samfile.index,
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L6;
        }
        __pyx_L6:;
      }
  }

  /* "pysam/calignmentfile.pyx":1719
 *     """
 * 
 *     def __init__(self, AlignmentFile samfile,             # <<<<<<<<<<<<<<
 *                  int tid, int beg, int end,
 *                  int multiple_iterators=False):
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRowRegion.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1736
 *                 end)
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return self
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_17IteratorRowRegion_3__iter__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_17IteratorRowRegion_3__iter__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__iter__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_17IteratorRowRegion_2__iter__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_17IteratorRowRegion_2__iter__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__iter__", 0);
  __Pyx_TraceCall("__iter__", __pyx_f[0], 1736, 0, __PYX_ERR(0, 1736, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1737
 * 
 *     def __iter__(self):
 *         return self             # <<<<<<<<<<<<<<
 * 
 *     cdef bam1_t * getCurrent(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __pyx_r = ((PyObject *)__pyx_v_self);
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1736
 *                 end)
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return self
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRowRegion.__iter__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1739
 *         return self
 * 
 *     cdef bam1_t * getCurrent(self):             # <<<<<<<<<<<<<<
 *         return self.b
 * 
 */

static bam1_t *__pyx_f_5pysam_14calignmentfile_17IteratorRowRegion_getCurrent(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *__pyx_v_self) {
  bam1_t *__pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getCurrent", 0);
  __Pyx_TraceCall("getCurrent", __pyx_f[0], 1739, 0, __PYX_ERR(0, 1739, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1740
 * 
 *     cdef bam1_t * getCurrent(self):
 *         return self.b             # <<<<<<<<<<<<<<
 * 
 *     cdef int cnext(self):
 */
  __pyx_r = __pyx_v_self->__pyx_base.b;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1739
 *         return self
 * 
 *     cdef bam1_t * getCurrent(self):             # <<<<<<<<<<<<<<
 *         return self.b
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("pysam.calignmentfile.IteratorRowRegion.getCurrent", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1742
 *         return self.b
 * 
 *     cdef int cnext(self):             # <<<<<<<<<<<<<<
 *         '''cversion of iterator. Used by IteratorColumn'''
 *         with nogil:
 */

static int __pyx_f_5pysam_14calignmentfile_17IteratorRowRegion_cnext(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *__pyx_v_self) {
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cnext", 0);
  __Pyx_TraceCall("cnext", __pyx_f[0], 1742, 0, __PYX_ERR(0, 1742, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1744
 *     cdef int cnext(self):
 *         '''cversion of iterator. Used by IteratorColumn'''
 *         with nogil:             # <<<<<<<<<<<<<<
 *             self.retval = hts_itr_next(hts_get_bgzfp(self.htsfile),
 *                                        self.iter,
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "pysam/calignmentfile.pyx":1745
 *         '''cversion of iterator. Used by IteratorColumn'''
 *         with nogil:
 *             self.retval = hts_itr_next(hts_get_bgzfp(self.htsfile),             # <<<<<<<<<<<<<<
 *                                        self.iter,
 *                                        self.b,
 */
        __pyx_v_self->__pyx_base.retval = hts_itr_next(hts_get_bgzfp(__pyx_v_self->__pyx_base.htsfile), __pyx_v_self->iter, __pyx_v_self->__pyx_base.b, __pyx_v_self->__pyx_base.htsfile);
      }

      /* "pysam/calignmentfile.pyx":1744
 *     cdef int cnext(self):
 *         '''cversion of iterator. Used by IteratorColumn'''
 *         with nogil:             # <<<<<<<<<<<<<<
 *             self.retval = hts_itr_next(hts_get_bgzfp(self.htsfile),
 *                                        self.iter,
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L5:;
      }
  }

  /* "pysam/calignmentfile.pyx":1742
 *         return self.b
 * 
 *     cdef int cnext(self):             # <<<<<<<<<<<<<<
 *         '''cversion of iterator. Used by IteratorColumn'''
 *         with nogil:
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("pysam.calignmentfile.IteratorRowRegion.cnext", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1750
 *                                        self.htsfile)
 * 
 *     def __next__(self):             # <<<<<<<<<<<<<<
 *         self.cnext()
 *         if self.retval >= 0:
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_17IteratorRowRegion_5__next__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_17IteratorRowRegion_5__next__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__next__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_17IteratorRowRegion_4__next__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_17IteratorRowRegion_4__next__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("__next__", 0);
  __Pyx_TraceCall("__next__", __pyx_f[0], 1750, 0, __PYX_ERR(0, 1750, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1751
 * 
 *     def __next__(self):
 *         self.cnext()             # <<<<<<<<<<<<<<
 *         if self.retval >= 0:
 *             return makeAlignedSegment(self.b, self.samfile)
 */
  ((struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorRowRegion *)__pyx_v_self->__pyx_vtab)->cnext(__pyx_v_self);

  /* "pysam/calignmentfile.pyx":1752
 *     def __next__(self):
 *         self.cnext()
 *         if self.retval >= 0:             # <<<<<<<<<<<<<<
 *             return makeAlignedSegment(self.b, self.samfile)
 *         elif self.retval == -2:
 */
  __pyx_t_1 = ((__pyx_v_self->__pyx_base.retval >= 0) != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":1753
 *         self.cnext()
 *         if self.retval >= 0:
 *             return makeAlignedSegment(self.b, self.samfile)             # <<<<<<<<<<<<<<
 *         elif self.retval == -2:
 *             # Note: it is currently not the case that hts_iter_next
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = ((PyObject *)__pyx_v_self->__pyx_base.samfile);
    __Pyx_INCREF(__pyx_t_2);
    __pyx_t_3 = __pyx_f_5pysam_15calignedsegment_makeAlignedSegment(__pyx_v_self->__pyx_base.b, ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1753, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L0;

    /* "pysam/calignmentfile.pyx":1752
 *     def __next__(self):
 *         self.cnext()
 *         if self.retval >= 0:             # <<<<<<<<<<<<<<
 *             return makeAlignedSegment(self.b, self.samfile)
 *         elif self.retval == -2:
 */
  }

  /* "pysam/calignmentfile.pyx":1754
 *         if self.retval >= 0:
 *             return makeAlignedSegment(self.b, self.samfile)
 *         elif self.retval == -2:             # <<<<<<<<<<<<<<
 *             # Note: it is currently not the case that hts_iter_next
 *             # returns -2 for a truncated file.
 */
  __pyx_t_1 = ((__pyx_v_self->__pyx_base.retval == -2L) != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":1758
 *             # returns -2 for a truncated file.
 *             # See https://github.com/pysam-developers/pysam/pull/50#issuecomment-64928625
 *             raise IOError('truncated file')             # <<<<<<<<<<<<<<
 *         else:
 *             raise StopIteration
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_IOError, __pyx_tuple__59, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1758, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 1758, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":1754
 *         if self.retval >= 0:
 *             return makeAlignedSegment(self.b, self.samfile)
 *         elif self.retval == -2:             # <<<<<<<<<<<<<<
 *             # Note: it is currently not the case that hts_iter_next
 *             # returns -2 for a truncated file.
 */
  }

  /* "pysam/calignmentfile.pyx":1760
 *             raise IOError('truncated file')
 *         else:
 *             raise StopIteration             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  /*else*/ {
    __Pyx_Raise(__pyx_builtin_StopIteration, 0, 0, 0);
    __PYX_ERR(0, 1760, __pyx_L1_error)
  }

  /* "pysam/calignmentfile.pyx":1750
 *                                        self.htsfile)
 * 
 *     def __next__(self):             # <<<<<<<<<<<<<<
 *         self.cnext()
 *         if self.retval >= 0:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRowRegion.__next__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1762
 *             raise StopIteration
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         hts_itr_destroy(self.iter)
 * 
 */

/* Python wrapper */
static void __pyx_pw_5pysam_14calignmentfile_17IteratorRowRegion_7__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_5pysam_14calignmentfile_17IteratorRowRegion_7__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_5pysam_14calignmentfile_17IteratorRowRegion_6__dealloc__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_5pysam_14calignmentfile_17IteratorRowRegion_6__dealloc__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *__pyx_v_self) {
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__", 0);
  __Pyx_TraceCall("__dealloc__", __pyx_f[0], 1762, 0, __PYX_ERR(0, 1762, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1763
 * 
 *     def __dealloc__(self):
 *         hts_itr_destroy(self.iter)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  hts_itr_destroy(__pyx_v_self->iter);

  /* "pysam/calignmentfile.pyx":1762
 *             raise StopIteration
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         hts_itr_destroy(self.iter)
 * 
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("pysam.calignmentfile.IteratorRowRegion.__dealloc__", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
}

/* "pysam/calignmentfile.pyx":1778
 *     """
 * 
 *     def __init__(self, AlignmentFile samfile, int n,             # <<<<<<<<<<<<<<
 *                  int multiple_iterators=False):
 * 
 */

/* Python wrapper */
static int __pyx_pw_5pysam_14calignmentfile_15IteratorRowHead_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_5pysam_14calignmentfile_15IteratorRowHead_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile = 0;
  int __pyx_v_n;
  int __pyx_v_multiple_iterators;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_samfile,&__pyx_n_s_n,&__pyx_n_s_multiple_iterators,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_samfile)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_n)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 0, 2, 3, 1); __PYX_ERR(0, 1778, __pyx_L3_error)
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_multiple_iterators);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 1778, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_samfile = ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)values[0]);
    __pyx_v_n = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_n == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 1778, __pyx_L3_error)
    if (values[2]) {
      __pyx_v_multiple_iterators = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_multiple_iterators == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 1779, __pyx_L3_error)
    } else {

      /* "pysam/calignmentfile.pyx":1779
 * 
 *     def __init__(self, AlignmentFile samfile, int n,
 *                  int multiple_iterators=False):             # <<<<<<<<<<<<<<
 * 
 *         IteratorRow.__init__(self, samfile,
 */
      __pyx_v_multiple_iterators = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1778, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRowHead.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_samfile), __pyx_ptype_5pysam_14calignmentfile_AlignmentFile, 1, "samfile", 0))) __PYX_ERR(0, 1778, __pyx_L1_error)
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_15IteratorRowHead___init__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead *)__pyx_v_self), __pyx_v_samfile, __pyx_v_n, __pyx_v_multiple_iterators);

  /* "pysam/calignmentfile.pyx":1778
 *     """
 * 
 *     def __init__(self, AlignmentFile samfile, int n,             # <<<<<<<<<<<<<<
 *                  int multiple_iterators=False):
 * 
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_5pysam_14calignmentfile_15IteratorRowHead___init__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead *__pyx_v_self, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile, int __pyx_v_n, int __pyx_v_multiple_iterators) {
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("__init__", 0);
  __Pyx_TraceCall("__init__", __pyx_f[0], 1778, 0, __PYX_ERR(0, 1778, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1781
 *                  int multiple_iterators=False):
 * 
 *         IteratorRow.__init__(self, samfile,             # <<<<<<<<<<<<<<
 *                              multiple_iterators=multiple_iterators)
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_5pysam_14calignmentfile_IteratorRow), __pyx_n_s_init); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1781, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1781, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_self));
  __Pyx_INCREF(((PyObject *)__pyx_v_samfile));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_samfile));
  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_samfile));

  /* "pysam/calignmentfile.pyx":1782
 * 
 *         IteratorRow.__init__(self, samfile,
 *                              multiple_iterators=multiple_iterators)             # <<<<<<<<<<<<<<
 * 
 *         self.max_rows = n
 */
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1782, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_multiple_iterators); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1782, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_multiple_iterators, __pyx_t_4) < 0) __PYX_ERR(0, 1782, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pysam/calignmentfile.pyx":1781
 *                  int multiple_iterators=False):
 * 
 *         IteratorRow.__init__(self, samfile,             # <<<<<<<<<<<<<<
 *                              multiple_iterators=multiple_iterators)
 * 
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1781, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pysam/calignmentfile.pyx":1784
 *                              multiple_iterators=multiple_iterators)
 * 
 *         self.max_rows = n             # <<<<<<<<<<<<<<
 *         self.current_row = 0
 * 
 */
  __pyx_v_self->max_rows = __pyx_v_n;

  /* "pysam/calignmentfile.pyx":1785
 * 
 *         self.max_rows = n
 *         self.current_row = 0             # <<<<<<<<<<<<<<
 * 
 *     def __iter__(self):
 */
  __pyx_v_self->current_row = 0;

  /* "pysam/calignmentfile.pyx":1778
 *     """
 * 
 *     def __init__(self, AlignmentFile samfile, int n,             # <<<<<<<<<<<<<<
 *                  int multiple_iterators=False):
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRowHead.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1787
 *         self.current_row = 0
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return self
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_15IteratorRowHead_3__iter__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_15IteratorRowHead_3__iter__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__iter__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_15IteratorRowHead_2__iter__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_15IteratorRowHead_2__iter__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__iter__", 0);
  __Pyx_TraceCall("__iter__", __pyx_f[0], 1787, 0, __PYX_ERR(0, 1787, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1788
 * 
 *     def __iter__(self):
 *         return self             # <<<<<<<<<<<<<<
 * 
 *     cdef bam1_t * getCurrent( self ):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __pyx_r = ((PyObject *)__pyx_v_self);
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1787
 *         self.current_row = 0
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return self
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRowHead.__iter__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1790
 *         return self
 * 
 *     cdef bam1_t * getCurrent( self ):             # <<<<<<<<<<<<<<
 *         return self.b
 * 
 */

static bam1_t *__pyx_f_5pysam_14calignmentfile_15IteratorRowHead_getCurrent(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead *__pyx_v_self) {
  bam1_t *__pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getCurrent", 0);
  __Pyx_TraceCall("getCurrent", __pyx_f[0], 1790, 0, __PYX_ERR(0, 1790, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1791
 * 
 *     cdef bam1_t * getCurrent( self ):
 *         return self.b             # <<<<<<<<<<<<<<
 * 
 *     cdef int cnext(self):
 */
  __pyx_r = __pyx_v_self->__pyx_base.b;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1790
 *         return self
 * 
 *     cdef bam1_t * getCurrent( self ):             # <<<<<<<<<<<<<<
 *         return self.b
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("pysam.calignmentfile.IteratorRowHead.getCurrent", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1793
 *         return self.b
 * 
 *     cdef int cnext(self):             # <<<<<<<<<<<<<<
 *         '''cversion of iterator. Used by IteratorColumn'''
 *         cdef int ret
 */

static int __pyx_f_5pysam_14calignmentfile_15IteratorRowHead_cnext(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead *__pyx_v_self) {
  int __pyx_v_ret;
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cnext", 0);
  __Pyx_TraceCall("cnext", __pyx_f[0], 1793, 0, __PYX_ERR(0, 1793, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1796
 *         '''cversion of iterator. Used by IteratorColumn'''
 *         cdef int ret
 *         with nogil:             # <<<<<<<<<<<<<<
 *             ret = sam_read1(self.htsfile,
 *                             self.samfile.header,
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "pysam/calignmentfile.pyx":1797
 *         cdef int ret
 *         with nogil:
 *             ret = sam_read1(self.htsfile,             # <<<<<<<<<<<<<<
 *                             self.samfile.header,
 *                             self.b)
 */
        __pyx_v_ret = sam_read1(__pyx_v_self->__pyx_base.htsfile, __pyx_v_self->__pyx_base.samfile->header, __pyx_v_self->__pyx_base.b);
      }

      /* "pysam/calignmentfile.pyx":1796
 *         '''cversion of iterator. Used by IteratorColumn'''
 *         cdef int ret
 *         with nogil:             # <<<<<<<<<<<<<<
 *             ret = sam_read1(self.htsfile,
 *                             self.samfile.header,
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L5:;
      }
  }

  /* "pysam/calignmentfile.pyx":1800
 *                             self.samfile.header,
 *                             self.b)
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def __next__(self):
 */
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1793
 *         return self.b
 * 
 *     cdef int cnext(self):             # <<<<<<<<<<<<<<
 *         '''cversion of iterator. Used by IteratorColumn'''
 *         cdef int ret
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("pysam.calignmentfile.IteratorRowHead.cnext", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1802
 *         return ret
 * 
 *     def __next__(self):             # <<<<<<<<<<<<<<
 *         if self.current_row >= self.max_rows:
 *             raise StopIteration
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_15IteratorRowHead_5__next__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_15IteratorRowHead_5__next__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__next__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_15IteratorRowHead_4__next__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_15IteratorRowHead_4__next__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead *__pyx_v_self) {
  int __pyx_v_ret;
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("__next__", 0);
  __Pyx_TraceCall("__next__", __pyx_f[0], 1802, 0, __PYX_ERR(0, 1802, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1803
 * 
 *     def __next__(self):
 *         if self.current_row >= self.max_rows:             # <<<<<<<<<<<<<<
 *             raise StopIteration
 * 
 */
  __pyx_t_1 = ((__pyx_v_self->current_row >= __pyx_v_self->max_rows) != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":1804
 *     def __next__(self):
 *         if self.current_row >= self.max_rows:
 *             raise StopIteration             # <<<<<<<<<<<<<<
 * 
 *         cdef int ret = self.cnext()
 */
    __Pyx_Raise(__pyx_builtin_StopIteration, 0, 0, 0);
    __PYX_ERR(0, 1804, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":1803
 * 
 *     def __next__(self):
 *         if self.current_row >= self.max_rows:             # <<<<<<<<<<<<<<
 *             raise StopIteration
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":1806
 *             raise StopIteration
 * 
 *         cdef int ret = self.cnext()             # <<<<<<<<<<<<<<
 *         if ret >= 0:
 *             self.current_row += 1
 */
  __pyx_v_ret = ((struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorRowHead *)__pyx_v_self->__pyx_vtab)->cnext(__pyx_v_self);

  /* "pysam/calignmentfile.pyx":1807
 * 
 *         cdef int ret = self.cnext()
 *         if ret >= 0:             # <<<<<<<<<<<<<<
 *             self.current_row += 1
 *             return makeAlignedSegment(self.b, self.samfile)
 */
  __pyx_t_1 = ((__pyx_v_ret >= 0) != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":1808
 *         cdef int ret = self.cnext()
 *         if ret >= 0:
 *             self.current_row += 1             # <<<<<<<<<<<<<<
 *             return makeAlignedSegment(self.b, self.samfile)
 *         elif ret == -2:
 */
    __pyx_v_self->current_row = (__pyx_v_self->current_row + 1);

    /* "pysam/calignmentfile.pyx":1809
 *         if ret >= 0:
 *             self.current_row += 1
 *             return makeAlignedSegment(self.b, self.samfile)             # <<<<<<<<<<<<<<
 *         elif ret == -2:
 *             raise IOError('truncated file')
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = ((PyObject *)__pyx_v_self->__pyx_base.samfile);
    __Pyx_INCREF(__pyx_t_2);
    __pyx_t_3 = __pyx_f_5pysam_15calignedsegment_makeAlignedSegment(__pyx_v_self->__pyx_base.b, ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1809, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L0;

    /* "pysam/calignmentfile.pyx":1807
 * 
 *         cdef int ret = self.cnext()
 *         if ret >= 0:             # <<<<<<<<<<<<<<
 *             self.current_row += 1
 *             return makeAlignedSegment(self.b, self.samfile)
 */
  }

  /* "pysam/calignmentfile.pyx":1810
 *             self.current_row += 1
 *             return makeAlignedSegment(self.b, self.samfile)
 *         elif ret == -2:             # <<<<<<<<<<<<<<
 *             raise IOError('truncated file')
 *         else:
 */
  __pyx_t_1 = ((__pyx_v_ret == -2L) != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":1811
 *             return makeAlignedSegment(self.b, self.samfile)
 *         elif ret == -2:
 *             raise IOError('truncated file')             # <<<<<<<<<<<<<<
 *         else:
 *             raise StopIteration
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_IOError, __pyx_tuple__60, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1811, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 1811, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":1810
 *             self.current_row += 1
 *             return makeAlignedSegment(self.b, self.samfile)
 *         elif ret == -2:             # <<<<<<<<<<<<<<
 *             raise IOError('truncated file')
 *         else:
 */
  }

  /* "pysam/calignmentfile.pyx":1813
 *             raise IOError('truncated file')
 *         else:
 *             raise StopIteration             # <<<<<<<<<<<<<<
 * 
 * 
 */
  /*else*/ {
    __Pyx_Raise(__pyx_builtin_StopIteration, 0, 0, 0);
    __PYX_ERR(0, 1813, __pyx_L1_error)
  }

  /* "pysam/calignmentfile.pyx":1802
 *         return ret
 * 
 *     def __next__(self):             # <<<<<<<<<<<<<<
 *         if self.current_row >= self.max_rows:
 *             raise StopIteration
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRowHead.__next__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1829
 *     """
 * 
 *     def __init__(self, AlignmentFile samfile,             # <<<<<<<<<<<<<<
 *                  int multiple_iterators=False):
 * 
 */

/* Python wrapper */
static int __pyx_pw_5pysam_14calignmentfile_14IteratorRowAll_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_5pysam_14calignmentfile_14IteratorRowAll_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile = 0;
  int __pyx_v_multiple_iterators;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_samfile,&__pyx_n_s_multiple_iterators,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_samfile)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_multiple_iterators);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 1829, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_samfile = ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)values[0]);
    if (values[1]) {
      __pyx_v_multiple_iterators = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_multiple_iterators == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 1830, __pyx_L3_error)
    } else {

      /* "pysam/calignmentfile.pyx":1830
 * 
 *     def __init__(self, AlignmentFile samfile,
 *                  int multiple_iterators=False):             # <<<<<<<<<<<<<<
 * 
 *         IteratorRow.__init__(self, samfile,
 */
      __pyx_v_multiple_iterators = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1829, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRowAll.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_samfile), __pyx_ptype_5pysam_14calignmentfile_AlignmentFile, 1, "samfile", 0))) __PYX_ERR(0, 1829, __pyx_L1_error)
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_14IteratorRowAll___init__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll *)__pyx_v_self), __pyx_v_samfile, __pyx_v_multiple_iterators);

  /* "pysam/calignmentfile.pyx":1829
 *     """
 * 
 *     def __init__(self, AlignmentFile samfile,             # <<<<<<<<<<<<<<
 *                  int multiple_iterators=False):
 * 
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_5pysam_14calignmentfile_14IteratorRowAll___init__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll *__pyx_v_self, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile, int __pyx_v_multiple_iterators) {
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("__init__", 0);
  __Pyx_TraceCall("__init__", __pyx_f[0], 1829, 0, __PYX_ERR(0, 1829, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1832
 *                  int multiple_iterators=False):
 * 
 *         IteratorRow.__init__(self, samfile,             # <<<<<<<<<<<<<<
 *                              multiple_iterators=multiple_iterators)
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_5pysam_14calignmentfile_IteratorRow), __pyx_n_s_init); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1832, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1832, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_self));
  __Pyx_INCREF(((PyObject *)__pyx_v_samfile));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_samfile));
  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_samfile));

  /* "pysam/calignmentfile.pyx":1833
 * 
 *         IteratorRow.__init__(self, samfile,
 *                              multiple_iterators=multiple_iterators)             # <<<<<<<<<<<<<<
 * 
 *     def __iter__(self):
 */
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1833, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_multiple_iterators); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1833, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_multiple_iterators, __pyx_t_4) < 0) __PYX_ERR(0, 1833, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pysam/calignmentfile.pyx":1832
 *                  int multiple_iterators=False):
 * 
 *         IteratorRow.__init__(self, samfile,             # <<<<<<<<<<<<<<
 *                              multiple_iterators=multiple_iterators)
 * 
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1832, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pysam/calignmentfile.pyx":1829
 *     """
 * 
 *     def __init__(self, AlignmentFile samfile,             # <<<<<<<<<<<<<<
 *                  int multiple_iterators=False):
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRowAll.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1835
 *                              multiple_iterators=multiple_iterators)
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return self
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_14IteratorRowAll_3__iter__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_14IteratorRowAll_3__iter__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__iter__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_14IteratorRowAll_2__iter__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_14IteratorRowAll_2__iter__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__iter__", 0);
  __Pyx_TraceCall("__iter__", __pyx_f[0], 1835, 0, __PYX_ERR(0, 1835, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1836
 * 
 *     def __iter__(self):
 *         return self             # <<<<<<<<<<<<<<
 * 
 *     cdef bam1_t * getCurrent( self ):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __pyx_r = ((PyObject *)__pyx_v_self);
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1835
 *                              multiple_iterators=multiple_iterators)
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return self
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRowAll.__iter__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1838
 *         return self
 * 
 *     cdef bam1_t * getCurrent( self ):             # <<<<<<<<<<<<<<
 *         return self.b
 * 
 */

static bam1_t *__pyx_f_5pysam_14calignmentfile_14IteratorRowAll_getCurrent(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll *__pyx_v_self) {
  bam1_t *__pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getCurrent", 0);
  __Pyx_TraceCall("getCurrent", __pyx_f[0], 1838, 0, __PYX_ERR(0, 1838, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1839
 * 
 *     cdef bam1_t * getCurrent( self ):
 *         return self.b             # <<<<<<<<<<<<<<
 * 
 *     cdef int cnext(self):
 */
  __pyx_r = __pyx_v_self->__pyx_base.b;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1838
 *         return self
 * 
 *     cdef bam1_t * getCurrent( self ):             # <<<<<<<<<<<<<<
 *         return self.b
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("pysam.calignmentfile.IteratorRowAll.getCurrent", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1841
 *         return self.b
 * 
 *     cdef int cnext(self):             # <<<<<<<<<<<<<<
 *         '''cversion of iterator. Used by IteratorColumn'''
 *         cdef int ret
 */

static int __pyx_f_5pysam_14calignmentfile_14IteratorRowAll_cnext(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll *__pyx_v_self) {
  int __pyx_v_ret;
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cnext", 0);
  __Pyx_TraceCall("cnext", __pyx_f[0], 1841, 0, __PYX_ERR(0, 1841, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1844
 *         '''cversion of iterator. Used by IteratorColumn'''
 *         cdef int ret
 *         with nogil:             # <<<<<<<<<<<<<<
 *             ret = sam_read1(self.htsfile,
 *                             self.samfile.header,
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "pysam/calignmentfile.pyx":1845
 *         cdef int ret
 *         with nogil:
 *             ret = sam_read1(self.htsfile,             # <<<<<<<<<<<<<<
 *                             self.samfile.header,
 *                             self.b)
 */
        __pyx_v_ret = sam_read1(__pyx_v_self->__pyx_base.htsfile, __pyx_v_self->__pyx_base.samfile->header, __pyx_v_self->__pyx_base.b);
      }

      /* "pysam/calignmentfile.pyx":1844
 *         '''cversion of iterator. Used by IteratorColumn'''
 *         cdef int ret
 *         with nogil:             # <<<<<<<<<<<<<<
 *             ret = sam_read1(self.htsfile,
 *                             self.samfile.header,
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L5:;
      }
  }

  /* "pysam/calignmentfile.pyx":1848
 *                             self.samfile.header,
 *                             self.b)
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def __next__(self):
 */
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1841
 *         return self.b
 * 
 *     cdef int cnext(self):             # <<<<<<<<<<<<<<
 *         '''cversion of iterator. Used by IteratorColumn'''
 *         cdef int ret
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("pysam.calignmentfile.IteratorRowAll.cnext", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1850
 *         return ret
 * 
 *     def __next__(self):             # <<<<<<<<<<<<<<
 *         cdef int ret = self.cnext()
 *         if ret >= 0:
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_14IteratorRowAll_5__next__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_14IteratorRowAll_5__next__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__next__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_14IteratorRowAll_4__next__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_14IteratorRowAll_4__next__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll *__pyx_v_self) {
  int __pyx_v_ret;
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("__next__", 0);
  __Pyx_TraceCall("__next__", __pyx_f[0], 1850, 0, __PYX_ERR(0, 1850, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1851
 * 
 *     def __next__(self):
 *         cdef int ret = self.cnext()             # <<<<<<<<<<<<<<
 *         if ret >= 0:
 *             return makeAlignedSegment(self.b, self.samfile)
 */
  __pyx_v_ret = ((struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorRowAll *)__pyx_v_self->__pyx_vtab)->cnext(__pyx_v_self);

  /* "pysam/calignmentfile.pyx":1852
 *     def __next__(self):
 *         cdef int ret = self.cnext()
 *         if ret >= 0:             # <<<<<<<<<<<<<<
 *             return makeAlignedSegment(self.b, self.samfile)
 *         elif ret == -2:
 */
  __pyx_t_1 = ((__pyx_v_ret >= 0) != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":1853
 *         cdef int ret = self.cnext()
 *         if ret >= 0:
 *             return makeAlignedSegment(self.b, self.samfile)             # <<<<<<<<<<<<<<
 *         elif ret == -2:
 *             raise IOError('truncated file')
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = ((PyObject *)__pyx_v_self->__pyx_base.samfile);
    __Pyx_INCREF(__pyx_t_2);
    __pyx_t_3 = __pyx_f_5pysam_15calignedsegment_makeAlignedSegment(__pyx_v_self->__pyx_base.b, ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1853, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L0;

    /* "pysam/calignmentfile.pyx":1852
 *     def __next__(self):
 *         cdef int ret = self.cnext()
 *         if ret >= 0:             # <<<<<<<<<<<<<<
 *             return makeAlignedSegment(self.b, self.samfile)
 *         elif ret == -2:
 */
  }

  /* "pysam/calignmentfile.pyx":1854
 *         if ret >= 0:
 *             return makeAlignedSegment(self.b, self.samfile)
 *         elif ret == -2:             # <<<<<<<<<<<<<<
 *             raise IOError('truncated file')
 *         else:
 */
  __pyx_t_1 = ((__pyx_v_ret == -2L) != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":1855
 *             return makeAlignedSegment(self.b, self.samfile)
 *         elif ret == -2:
 *             raise IOError('truncated file')             # <<<<<<<<<<<<<<
 *         else:
 *             raise StopIteration
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_IOError, __pyx_tuple__61, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1855, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 1855, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":1854
 *         if ret >= 0:
 *             return makeAlignedSegment(self.b, self.samfile)
 *         elif ret == -2:             # <<<<<<<<<<<<<<
 *             raise IOError('truncated file')
 *         else:
 */
  }

  /* "pysam/calignmentfile.pyx":1857
 *             raise IOError('truncated file')
 *         else:
 *             raise StopIteration             # <<<<<<<<<<<<<<
 * 
 * 
 */
  /*else*/ {
    __Pyx_Raise(__pyx_builtin_StopIteration, 0, 0, 0);
    __PYX_ERR(0, 1857, __pyx_L1_error)
  }

  /* "pysam/calignmentfile.pyx":1850
 *         return ret
 * 
 *     def __next__(self):             # <<<<<<<<<<<<<<
 *         cdef int ret = self.cnext()
 *         if ret >= 0:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRowAll.__next__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1871
 *     """
 * 
 *     def __init__(self, AlignmentFile samfile,             # <<<<<<<<<<<<<<
 *                  multiple_iterators=False):
 * 
 */

/* Python wrapper */
static int __pyx_pw_5pysam_14calignmentfile_18IteratorRowAllRefs_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_5pysam_14calignmentfile_18IteratorRowAllRefs_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile = 0;
  PyObject *__pyx_v_multiple_iterators = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_samfile,&__pyx_n_s_multiple_iterators,0};
    PyObject* values[2] = {0,0};

    /* "pysam/calignmentfile.pyx":1872
 * 
 *     def __init__(self, AlignmentFile samfile,
 *                  multiple_iterators=False):             # <<<<<<<<<<<<<<
 * 
 *         IteratorRow.__init__(self, samfile,
 */
    values[1] = ((PyObject *)Py_False);
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_samfile)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_multiple_iterators);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 1871, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_samfile = ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)values[0]);
    __pyx_v_multiple_iterators = values[1];
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1871, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRowAllRefs.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_samfile), __pyx_ptype_5pysam_14calignmentfile_AlignmentFile, 1, "samfile", 0))) __PYX_ERR(0, 1871, __pyx_L1_error)
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_18IteratorRowAllRefs___init__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs *)__pyx_v_self), __pyx_v_samfile, __pyx_v_multiple_iterators);

  /* "pysam/calignmentfile.pyx":1871
 *     """
 * 
 *     def __init__(self, AlignmentFile samfile,             # <<<<<<<<<<<<<<
 *                  multiple_iterators=False):
 * 
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_5pysam_14calignmentfile_18IteratorRowAllRefs___init__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs *__pyx_v_self, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile, PyObject *__pyx_v_multiple_iterators) {
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  __Pyx_RefNannySetupContext("__init__", 0);
  __Pyx_TraceCall("__init__", __pyx_f[0], 1871, 0, __PYX_ERR(0, 1871, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1874
 *                  multiple_iterators=False):
 * 
 *         IteratorRow.__init__(self, samfile,             # <<<<<<<<<<<<<<
 *                              multiple_iterators=multiple_iterators)
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_5pysam_14calignmentfile_IteratorRow), __pyx_n_s_init); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1874, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1874, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_self));
  __Pyx_INCREF(((PyObject *)__pyx_v_samfile));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_samfile));
  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_samfile));

  /* "pysam/calignmentfile.pyx":1875
 * 
 *         IteratorRow.__init__(self, samfile,
 *                              multiple_iterators=multiple_iterators)             # <<<<<<<<<<<<<<
 * 
 *         if not samfile.has_index():
 */
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1875, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_multiple_iterators, __pyx_v_multiple_iterators) < 0) __PYX_ERR(0, 1875, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":1874
 *                  multiple_iterators=False):
 * 
 *         IteratorRow.__init__(self, samfile,             # <<<<<<<<<<<<<<
 *                              multiple_iterators=multiple_iterators)
 * 
 */
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1874, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pysam/calignmentfile.pyx":1877
 *                              multiple_iterators=multiple_iterators)
 * 
 *         if not samfile.has_index():             # <<<<<<<<<<<<<<
 *             raise ValueError("no index available for fetch")
 * 
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_samfile), __pyx_n_s_has_index); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1877, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (__pyx_t_2) {
    __pyx_t_4 = __Pyx_PyObject_CallOneArg(__pyx_t_3, __pyx_t_2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1877, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  } else {
    __pyx_t_4 = __Pyx_PyObject_CallNoArg(__pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1877, __pyx_L1_error)
  }
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 1877, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_6 = ((!__pyx_t_5) != 0);
  if (__pyx_t_6) {

    /* "pysam/calignmentfile.pyx":1878
 * 
 *         if not samfile.has_index():
 *             raise ValueError("no index available for fetch")             # <<<<<<<<<<<<<<
 * 
 *         self.tid = -1
 */
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__62, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1878, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 1878, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":1877
 *                              multiple_iterators=multiple_iterators)
 * 
 *         if not samfile.has_index():             # <<<<<<<<<<<<<<
 *             raise ValueError("no index available for fetch")
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":1880
 *             raise ValueError("no index available for fetch")
 * 
 *         self.tid = -1             # <<<<<<<<<<<<<<
 * 
 *     def nextiter(self):
 */
  __pyx_v_self->tid = -1;

  /* "pysam/calignmentfile.pyx":1871
 *     """
 * 
 *     def __init__(self, AlignmentFile samfile,             # <<<<<<<<<<<<<<
 *                  multiple_iterators=False):
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRowAllRefs.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1882
 *         self.tid = -1
 * 
 *     def nextiter(self):             # <<<<<<<<<<<<<<
 *         # get a new iterator for a chromosome. The file
 *         # will not be re-opened.
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_18IteratorRowAllRefs_3nextiter(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_18IteratorRowAllRefs_2nextiter[] = "IteratorRowAllRefs.nextiter(self)";
static PyObject *__pyx_pw_5pysam_14calignmentfile_18IteratorRowAllRefs_3nextiter(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("nextiter (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_18IteratorRowAllRefs_2nextiter(((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_18IteratorRowAllRefs_2nextiter(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  htsFile *__pyx_t_3;
  bam_hdr_t *__pyx_t_4;
  __Pyx_RefNannySetupContext("nextiter", 0);
  __Pyx_TraceCall("nextiter", __pyx_f[0], 1882, 0, __PYX_ERR(0, 1882, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1886
 *         # will not be re-opened.
 *         self.rowiter = IteratorRowRegion(self.samfile,
 *                                          self.tid,             # <<<<<<<<<<<<<<
 *                                          0,
 *                                          1<<29)
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->tid); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1886, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);

  /* "pysam/calignmentfile.pyx":1885
 *         # get a new iterator for a chromosome. The file
 *         # will not be re-opened.
 *         self.rowiter = IteratorRowRegion(self.samfile,             # <<<<<<<<<<<<<<
 *                                          self.tid,
 *                                          0,
 */
  __pyx_t_2 = PyTuple_New(4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1885, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_v_self->__pyx_base.samfile));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_self->__pyx_base.samfile));
  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_self->__pyx_base.samfile));
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_t_1);
  __Pyx_INCREF(__pyx_int_0);
  __Pyx_GIVEREF(__pyx_int_0);
  PyTuple_SET_ITEM(__pyx_t_2, 2, __pyx_int_0);
  __Pyx_INCREF(__pyx_int_536870912);
  __Pyx_GIVEREF(__pyx_int_536870912);
  PyTuple_SET_ITEM(__pyx_t_2, 3, __pyx_int_536870912);
  __pyx_t_1 = 0;
  __pyx_t_1 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_5pysam_14calignmentfile_IteratorRowRegion), __pyx_t_2, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1885, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_GIVEREF(__pyx_t_1);
  __Pyx_GOTREF(__pyx_v_self->rowiter);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->rowiter));
  __pyx_v_self->rowiter = ((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pysam/calignmentfile.pyx":1891
 *         # set htsfile and header of the rowiter
 *         # to the values in this iterator to reflect multiple_iterators
 *         self.rowiter.htsfile = self.htsfile             # <<<<<<<<<<<<<<
 *         self.rowiter.header = self.header
 * 
 */
  __pyx_t_3 = __pyx_v_self->__pyx_base.htsfile;
  __pyx_v_self->rowiter->__pyx_base.htsfile = __pyx_t_3;

  /* "pysam/calignmentfile.pyx":1892
 *         # to the values in this iterator to reflect multiple_iterators
 *         self.rowiter.htsfile = self.htsfile
 *         self.rowiter.header = self.header             # <<<<<<<<<<<<<<
 * 
 *         # make sure the iterator understand that IteratorRowAllRefs
 */
  __pyx_t_4 = __pyx_v_self->__pyx_base.header;
  __pyx_v_self->rowiter->__pyx_base.header = __pyx_t_4;

  /* "pysam/calignmentfile.pyx":1896
 *         # make sure the iterator understand that IteratorRowAllRefs
 *         # has ownership
 *         self.rowiter.owns_samfile = False             # <<<<<<<<<<<<<<
 * 
 *     def __iter__(self):
 */
  __pyx_v_self->rowiter->__pyx_base.owns_samfile = 0;

  /* "pysam/calignmentfile.pyx":1882
 *         self.tid = -1
 * 
 *     def nextiter(self):             # <<<<<<<<<<<<<<
 *         # get a new iterator for a chromosome. The file
 *         # will not be re-opened.
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRowAllRefs.nextiter", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1898
 *         self.rowiter.owns_samfile = False
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return self
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_18IteratorRowAllRefs_5__iter__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_18IteratorRowAllRefs_5__iter__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__iter__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_18IteratorRowAllRefs_4__iter__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_18IteratorRowAllRefs_4__iter__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__iter__", 0);
  __Pyx_TraceCall("__iter__", __pyx_f[0], 1898, 0, __PYX_ERR(0, 1898, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1899
 * 
 *     def __iter__(self):
 *         return self             # <<<<<<<<<<<<<<
 * 
 *     def __next__(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __pyx_r = ((PyObject *)__pyx_v_self);
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1898
 *         self.rowiter.owns_samfile = False
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return self
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRowAllRefs.__iter__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1901
 *         return self
 * 
 *     def __next__(self):             # <<<<<<<<<<<<<<
 *         # Create an initial iterator
 *         if self.tid == -1:
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_18IteratorRowAllRefs_7__next__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_18IteratorRowAllRefs_7__next__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__next__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_18IteratorRowAllRefs_6__next__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_18IteratorRowAllRefs_6__next__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("__next__", 0);
  __Pyx_TraceCall("__next__", __pyx_f[0], 1901, 0, __PYX_ERR(0, 1901, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1903
 *     def __next__(self):
 *         # Create an initial iterator
 *         if self.tid == -1:             # <<<<<<<<<<<<<<
 *             if not self.samfile.nreferences:
 *                 raise StopIteration
 */
  __pyx_t_1 = ((__pyx_v_self->tid == -1L) != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":1904
 *         # Create an initial iterator
 *         if self.tid == -1:
 *             if not self.samfile.nreferences:             # <<<<<<<<<<<<<<
 *                 raise StopIteration
 *             self.tid = 0
 */
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self->__pyx_base.samfile), __pyx_n_s_nreferences); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1904, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 1904, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_3 = ((!__pyx_t_1) != 0);
    if (__pyx_t_3) {

      /* "pysam/calignmentfile.pyx":1905
 *         if self.tid == -1:
 *             if not self.samfile.nreferences:
 *                 raise StopIteration             # <<<<<<<<<<<<<<
 *             self.tid = 0
 *             self.nextiter()
 */
      __Pyx_Raise(__pyx_builtin_StopIteration, 0, 0, 0);
      __PYX_ERR(0, 1905, __pyx_L1_error)

      /* "pysam/calignmentfile.pyx":1904
 *         # Create an initial iterator
 *         if self.tid == -1:
 *             if not self.samfile.nreferences:             # <<<<<<<<<<<<<<
 *                 raise StopIteration
 *             self.tid = 0
 */
    }

    /* "pysam/calignmentfile.pyx":1906
 *             if not self.samfile.nreferences:
 *                 raise StopIteration
 *             self.tid = 0             # <<<<<<<<<<<<<<
 *             self.nextiter()
 * 
 */
    __pyx_v_self->tid = 0;

    /* "pysam/calignmentfile.pyx":1907
 *                 raise StopIteration
 *             self.tid = 0
 *             self.nextiter()             # <<<<<<<<<<<<<<
 * 
 *         while 1:
 */
    __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_nextiter); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1907, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_5 = NULL;
    if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_4))) {
      __pyx_t_5 = PyMethod_GET_SELF(__pyx_t_4);
      if (likely(__pyx_t_5)) {
        PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_4);
        __Pyx_INCREF(__pyx_t_5);
        __Pyx_INCREF(function);
        __Pyx_DECREF_SET(__pyx_t_4, function);
      }
    }
    if (__pyx_t_5) {
      __pyx_t_2 = __Pyx_PyObject_CallOneArg(__pyx_t_4, __pyx_t_5); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1907, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    } else {
      __pyx_t_2 = __Pyx_PyObject_CallNoArg(__pyx_t_4); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1907, __pyx_L1_error)
    }
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;

    /* "pysam/calignmentfile.pyx":1903
 *     def __next__(self):
 *         # Create an initial iterator
 *         if self.tid == -1:             # <<<<<<<<<<<<<<
 *             if not self.samfile.nreferences:
 *                 raise StopIteration
 */
  }

  /* "pysam/calignmentfile.pyx":1909
 *             self.nextiter()
 * 
 *         while 1:             # <<<<<<<<<<<<<<
 *             self.rowiter.cnext()
 * 
 */
  while (1) {

    /* "pysam/calignmentfile.pyx":1910
 * 
 *         while 1:
 *             self.rowiter.cnext()             # <<<<<<<<<<<<<<
 * 
 *             # If current iterator is not exhausted, return aligned read
 */
    ((struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorRowRegion *)__pyx_v_self->rowiter->__pyx_vtab)->cnext(__pyx_v_self->rowiter);

    /* "pysam/calignmentfile.pyx":1913
 * 
 *             # If current iterator is not exhausted, return aligned read
 *             if self.rowiter.retval > 0:             # <<<<<<<<<<<<<<
 *                 return makeAlignedSegment(self.rowiter.b, self.samfile)
 * 
 */
    __pyx_t_3 = ((__pyx_v_self->rowiter->__pyx_base.retval > 0) != 0);
    if (__pyx_t_3) {

      /* "pysam/calignmentfile.pyx":1914
 *             # If current iterator is not exhausted, return aligned read
 *             if self.rowiter.retval > 0:
 *                 return makeAlignedSegment(self.rowiter.b, self.samfile)             # <<<<<<<<<<<<<<
 * 
 *             self.tid += 1
 */
      __Pyx_XDECREF(__pyx_r);
      __pyx_t_2 = ((PyObject *)__pyx_v_self->__pyx_base.samfile);
      __Pyx_INCREF(__pyx_t_2);
      __pyx_t_4 = __pyx_f_5pysam_15calignedsegment_makeAlignedSegment(__pyx_v_self->rowiter->__pyx_base.b, ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_t_2)); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1914, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_r = __pyx_t_4;
      __pyx_t_4 = 0;
      goto __pyx_L0;

      /* "pysam/calignmentfile.pyx":1913
 * 
 *             # If current iterator is not exhausted, return aligned read
 *             if self.rowiter.retval > 0:             # <<<<<<<<<<<<<<
 *                 return makeAlignedSegment(self.rowiter.b, self.samfile)
 * 
 */
    }

    /* "pysam/calignmentfile.pyx":1916
 *                 return makeAlignedSegment(self.rowiter.b, self.samfile)
 * 
 *             self.tid += 1             # <<<<<<<<<<<<<<
 * 
 *             # Otherwise, proceed to next reference or stop
 */
    __pyx_v_self->tid = (__pyx_v_self->tid + 1);

    /* "pysam/calignmentfile.pyx":1919
 * 
 *             # Otherwise, proceed to next reference or stop
 *             if self.tid < self.samfile.nreferences:             # <<<<<<<<<<<<<<
 *                 self.nextiter()
 *             else:
 */
    __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_self->tid); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1919, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self->__pyx_base.samfile), __pyx_n_s_nreferences); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1919, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_5 = PyObject_RichCompare(__pyx_t_4, __pyx_t_2, Py_LT); __Pyx_XGOTREF(__pyx_t_5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1919, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 1919, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (__pyx_t_3) {

      /* "pysam/calignmentfile.pyx":1920
 *             # Otherwise, proceed to next reference or stop
 *             if self.tid < self.samfile.nreferences:
 *                 self.nextiter()             # <<<<<<<<<<<<<<
 *             else:
 *                 raise StopIteration
 */
      __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_nextiter); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1920, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __pyx_t_4 = NULL;
      if (CYTHON_COMPILING_IN_CPYTHON && likely(PyMethod_Check(__pyx_t_2))) {
        __pyx_t_4 = PyMethod_GET_SELF(__pyx_t_2);
        if (likely(__pyx_t_4)) {
          PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_2);
          __Pyx_INCREF(__pyx_t_4);
          __Pyx_INCREF(function);
          __Pyx_DECREF_SET(__pyx_t_2, function);
        }
      }
      if (__pyx_t_4) {
        __pyx_t_5 = __Pyx_PyObject_CallOneArg(__pyx_t_2, __pyx_t_4); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1920, __pyx_L1_error)
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      } else {
        __pyx_t_5 = __Pyx_PyObject_CallNoArg(__pyx_t_2); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 1920, __pyx_L1_error)
      }
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

      /* "pysam/calignmentfile.pyx":1919
 * 
 *             # Otherwise, proceed to next reference or stop
 *             if self.tid < self.samfile.nreferences:             # <<<<<<<<<<<<<<
 *                 self.nextiter()
 *             else:
 */
      goto __pyx_L8;
    }

    /* "pysam/calignmentfile.pyx":1922
 *                 self.nextiter()
 *             else:
 *                 raise StopIteration             # <<<<<<<<<<<<<<
 * 
 * 
 */
    /*else*/ {
      __Pyx_Raise(__pyx_builtin_StopIteration, 0, 0, 0);
      __PYX_ERR(0, 1922, __pyx_L1_error)
    }
    __pyx_L8:;
  }

  /* "pysam/calignmentfile.pyx":1901
 *         return self
 * 
 *     def __next__(self):             # <<<<<<<<<<<<<<
 *         # Create an initial iterator
 *         if self.tid == -1:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRowAllRefs.__next__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1935
 *     """
 * 
 *     def __init__(self, AlignmentFile samfile, positions, int multiple_iterators=True):             # <<<<<<<<<<<<<<
 * 
 *         IteratorRow.__init__(self, samfile, multiple_iterators=multiple_iterators)
 */

/* Python wrapper */
static int __pyx_pw_5pysam_14calignmentfile_20IteratorRowSelection_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_5pysam_14calignmentfile_20IteratorRowSelection_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile = 0;
  PyObject *__pyx_v_positions = 0;
  int __pyx_v_multiple_iterators;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_samfile,&__pyx_n_s_positions,&__pyx_n_s_multiple_iterators,0};
    PyObject* values[3] = {0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_samfile)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (likely((values[1] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_positions)) != 0)) kw_args--;
        else {
          __Pyx_RaiseArgtupleInvalid("__init__", 0, 2, 3, 1); __PYX_ERR(0, 1935, __pyx_L3_error)
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_multiple_iterators);
          if (value) { values[2] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 1935, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_samfile = ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)values[0]);
    __pyx_v_positions = values[1];
    if (values[2]) {
      __pyx_v_multiple_iterators = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_multiple_iterators == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 1935, __pyx_L3_error)
    } else {
      __pyx_v_multiple_iterators = ((int)1);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 0, 2, 3, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 1935, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRowSelection.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_samfile), __pyx_ptype_5pysam_14calignmentfile_AlignmentFile, 1, "samfile", 0))) __PYX_ERR(0, 1935, __pyx_L1_error)
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_20IteratorRowSelection___init__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *)__pyx_v_self), __pyx_v_samfile, __pyx_v_positions, __pyx_v_multiple_iterators);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_5pysam_14calignmentfile_20IteratorRowSelection___init__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *__pyx_v_self, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile, PyObject *__pyx_v_positions, int __pyx_v_multiple_iterators) {
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("__init__", 0);
  __Pyx_TraceCall("__init__", __pyx_f[0], 1935, 0, __PYX_ERR(0, 1935, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1937
 *     def __init__(self, AlignmentFile samfile, positions, int multiple_iterators=True):
 * 
 *         IteratorRow.__init__(self, samfile, multiple_iterators=multiple_iterators)             # <<<<<<<<<<<<<<
 * 
 *         self.positions = positions
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_ptype_5pysam_14calignmentfile_IteratorRow), __pyx_n_s_init); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1937, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 1937, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
  PyTuple_SET_ITEM(__pyx_t_2, 0, ((PyObject *)__pyx_v_self));
  __Pyx_INCREF(((PyObject *)__pyx_v_samfile));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_samfile));
  PyTuple_SET_ITEM(__pyx_t_2, 1, ((PyObject *)__pyx_v_samfile));
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1937, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_multiple_iterators); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1937, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_multiple_iterators, __pyx_t_4) < 0) __PYX_ERR(0, 1937, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_t_4 = __Pyx_PyObject_Call(__pyx_t_1, __pyx_t_2, __pyx_t_3); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 1937, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pysam/calignmentfile.pyx":1939
 *         IteratorRow.__init__(self, samfile, multiple_iterators=multiple_iterators)
 * 
 *         self.positions = positions             # <<<<<<<<<<<<<<
 *         self.current_pos = 0
 * 
 */
  __Pyx_INCREF(__pyx_v_positions);
  __Pyx_GIVEREF(__pyx_v_positions);
  __Pyx_GOTREF(__pyx_v_self->positions);
  __Pyx_DECREF(__pyx_v_self->positions);
  __pyx_v_self->positions = __pyx_v_positions;

  /* "pysam/calignmentfile.pyx":1940
 * 
 *         self.positions = positions
 *         self.current_pos = 0             # <<<<<<<<<<<<<<
 * 
 *     def __iter__(self):
 */
  __pyx_v_self->current_pos = 0;

  /* "pysam/calignmentfile.pyx":1935
 *     """
 * 
 *     def __init__(self, AlignmentFile samfile, positions, int multiple_iterators=True):             # <<<<<<<<<<<<<<
 * 
 *         IteratorRow.__init__(self, samfile, multiple_iterators=multiple_iterators)
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRowSelection.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1942
 *         self.current_pos = 0
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return self
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_20IteratorRowSelection_3__iter__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_20IteratorRowSelection_3__iter__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__iter__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_20IteratorRowSelection_2__iter__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_20IteratorRowSelection_2__iter__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__iter__", 0);
  __Pyx_TraceCall("__iter__", __pyx_f[0], 1942, 0, __PYX_ERR(0, 1942, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1943
 * 
 *     def __iter__(self):
 *         return self             # <<<<<<<<<<<<<<
 * 
 *     cdef bam1_t * getCurrent(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __pyx_r = ((PyObject *)__pyx_v_self);
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1942
 *         self.current_pos = 0
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return self
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRowSelection.__iter__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1945
 *         return self
 * 
 *     cdef bam1_t * getCurrent(self):             # <<<<<<<<<<<<<<
 *         return self.b
 * 
 */

static bam1_t *__pyx_f_5pysam_14calignmentfile_20IteratorRowSelection_getCurrent(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *__pyx_v_self) {
  bam1_t *__pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getCurrent", 0);
  __Pyx_TraceCall("getCurrent", __pyx_f[0], 1945, 0, __PYX_ERR(0, 1945, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1946
 * 
 *     cdef bam1_t * getCurrent(self):
 *         return self.b             # <<<<<<<<<<<<<<
 * 
 *     cdef int cnext(self):
 */
  __pyx_r = __pyx_v_self->__pyx_base.b;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1945
 *         return self
 * 
 *     cdef bam1_t * getCurrent(self):             # <<<<<<<<<<<<<<
 *         return self.b
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("pysam.calignmentfile.IteratorRowSelection.getCurrent", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1948
 *         return self.b
 * 
 *     cdef int cnext(self):             # <<<<<<<<<<<<<<
 *         '''cversion of iterator'''
 *         # end iteration if out of positions
 */

static int __pyx_f_5pysam_14calignmentfile_20IteratorRowSelection_cnext(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *__pyx_v_self) {
  uint64_t __pyx_v_pos;
  int __pyx_v_ret;
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  Py_ssize_t __pyx_t_2;
  int __pyx_t_3;
  uint64_t __pyx_t_4;
  __Pyx_RefNannySetupContext("cnext", 0);
  __Pyx_TraceCall("cnext", __pyx_f[0], 1948, 0, __PYX_ERR(0, 1948, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1951
 *         '''cversion of iterator'''
 *         # end iteration if out of positions
 *         if self.current_pos >= len(self.positions): return -1             # <<<<<<<<<<<<<<
 * 
 *         cdef uint64_t pos = self.positions[self.current_pos]
 */
  __pyx_t_1 = __pyx_v_self->positions;
  __Pyx_INCREF(__pyx_t_1);
  __pyx_t_2 = PyObject_Length(__pyx_t_1); if (unlikely(__pyx_t_2 == -1)) __PYX_ERR(0, 1951, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = ((__pyx_v_self->current_pos >= __pyx_t_2) != 0);
  if (__pyx_t_3) {
    __pyx_r = -1;
    goto __pyx_L0;
  }

  /* "pysam/calignmentfile.pyx":1953
 *         if self.current_pos >= len(self.positions): return -1
 * 
 *         cdef uint64_t pos = self.positions[self.current_pos]             # <<<<<<<<<<<<<<
 *         with nogil:
 *             bgzf_seek(hts_get_bgzfp(self.htsfile),
 */
  __pyx_t_1 = __Pyx_GetItemInt(__pyx_v_self->positions, __pyx_v_self->current_pos, int, 1, __Pyx_PyInt_From_int, 0, 1, 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1953, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = __Pyx_PyInt_As_uint64_t(__pyx_t_1); if (unlikely((__pyx_t_4 == (uint64_t)-1) && PyErr_Occurred())) __PYX_ERR(0, 1953, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_pos = __pyx_t_4;

  /* "pysam/calignmentfile.pyx":1954
 * 
 *         cdef uint64_t pos = self.positions[self.current_pos]
 *         with nogil:             # <<<<<<<<<<<<<<
 *             bgzf_seek(hts_get_bgzfp(self.htsfile),
 *                       pos,
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "pysam/calignmentfile.pyx":1955
 *         cdef uint64_t pos = self.positions[self.current_pos]
 *         with nogil:
 *             bgzf_seek(hts_get_bgzfp(self.htsfile),             # <<<<<<<<<<<<<<
 *                       pos,
 *                       0)
 */
        bgzf_seek(hts_get_bgzfp(__pyx_v_self->__pyx_base.htsfile), __pyx_v_pos, 0);
      }

      /* "pysam/calignmentfile.pyx":1954
 * 
 *         cdef uint64_t pos = self.positions[self.current_pos]
 *         with nogil:             # <<<<<<<<<<<<<<
 *             bgzf_seek(hts_get_bgzfp(self.htsfile),
 *                       pos,
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L6;
        }
        __pyx_L6:;
      }
  }

  /* "pysam/calignmentfile.pyx":1958
 *                       pos,
 *                       0)
 *         self.current_pos += 1             # <<<<<<<<<<<<<<
 * 
 *         cdef int ret
 */
  __pyx_v_self->current_pos = (__pyx_v_self->current_pos + 1);

  /* "pysam/calignmentfile.pyx":1961
 * 
 *         cdef int ret
 *         with nogil:             # <<<<<<<<<<<<<<
 *             ret = sam_read1(self.htsfile,
 *                             self.samfile.header,
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "pysam/calignmentfile.pyx":1962
 *         cdef int ret
 *         with nogil:
 *             ret = sam_read1(self.htsfile,             # <<<<<<<<<<<<<<
 *                             self.samfile.header,
 *                             self.b)
 */
        __pyx_v_ret = sam_read1(__pyx_v_self->__pyx_base.htsfile, __pyx_v_self->__pyx_base.samfile->header, __pyx_v_self->__pyx_base.b);
      }

      /* "pysam/calignmentfile.pyx":1961
 * 
 *         cdef int ret
 *         with nogil:             # <<<<<<<<<<<<<<
 *             ret = sam_read1(self.htsfile,
 *                             self.samfile.header,
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L9;
        }
        __pyx_L9:;
      }
  }

  /* "pysam/calignmentfile.pyx":1965
 *                             self.samfile.header,
 *                             self.b)
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def __next__(self):
 */
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1948
 *         return self.b
 * 
 *     cdef int cnext(self):             # <<<<<<<<<<<<<<
 *         '''cversion of iterator'''
 *         # end iteration if out of positions
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_WriteUnraisable("pysam.calignmentfile.IteratorRowSelection.cnext", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1967
 *         return ret
 * 
 *     def __next__(self):             # <<<<<<<<<<<<<<
 *         cdef int ret = self.cnext()
 *         if (ret >= 0):
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_20IteratorRowSelection_5__next__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_20IteratorRowSelection_5__next__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__next__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_20IteratorRowSelection_4__next__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_20IteratorRowSelection_4__next__(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *__pyx_v_self) {
  int __pyx_v_ret;
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("__next__", 0);
  __Pyx_TraceCall("__next__", __pyx_f[0], 1967, 0, __PYX_ERR(0, 1967, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1968
 * 
 *     def __next__(self):
 *         cdef int ret = self.cnext()             # <<<<<<<<<<<<<<
 *         if (ret >= 0):
 *             return makeAlignedSegment(self.b, self.samfile)
 */
  __pyx_v_ret = ((struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorRowSelection *)__pyx_v_self->__pyx_vtab)->cnext(__pyx_v_self);

  /* "pysam/calignmentfile.pyx":1969
 *     def __next__(self):
 *         cdef int ret = self.cnext()
 *         if (ret >= 0):             # <<<<<<<<<<<<<<
 *             return makeAlignedSegment(self.b, self.samfile)
 *         elif (ret == -2):
 */
  __pyx_t_1 = ((__pyx_v_ret >= 0) != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":1970
 *         cdef int ret = self.cnext()
 *         if (ret >= 0):
 *             return makeAlignedSegment(self.b, self.samfile)             # <<<<<<<<<<<<<<
 *         elif (ret == -2):
 *             raise IOError('truncated file')
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = ((PyObject *)__pyx_v_self->__pyx_base.samfile);
    __Pyx_INCREF(__pyx_t_2);
    __pyx_t_3 = __pyx_f_5pysam_15calignedsegment_makeAlignedSegment(__pyx_v_self->__pyx_base.b, ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1970, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L0;

    /* "pysam/calignmentfile.pyx":1969
 *     def __next__(self):
 *         cdef int ret = self.cnext()
 *         if (ret >= 0):             # <<<<<<<<<<<<<<
 *             return makeAlignedSegment(self.b, self.samfile)
 *         elif (ret == -2):
 */
  }

  /* "pysam/calignmentfile.pyx":1971
 *         if (ret >= 0):
 *             return makeAlignedSegment(self.b, self.samfile)
 *         elif (ret == -2):             # <<<<<<<<<<<<<<
 *             raise IOError('truncated file')
 *         else:
 */
  __pyx_t_1 = ((__pyx_v_ret == -2L) != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":1972
 *             return makeAlignedSegment(self.b, self.samfile)
 *         elif (ret == -2):
 *             raise IOError('truncated file')             # <<<<<<<<<<<<<<
 *         else:
 *             raise StopIteration
 */
    __pyx_t_3 = __Pyx_PyObject_Call(__pyx_builtin_IOError, __pyx_tuple__63, NULL); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1972, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __PYX_ERR(0, 1972, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":1971
 *         if (ret >= 0):
 *             return makeAlignedSegment(self.b, self.samfile)
 *         elif (ret == -2):             # <<<<<<<<<<<<<<
 *             raise IOError('truncated file')
 *         else:
 */
  }

  /* "pysam/calignmentfile.pyx":1974
 *             raise IOError('truncated file')
 *         else:
 *             raise StopIteration             # <<<<<<<<<<<<<<
 * 
 * 
 */
  /*else*/ {
    __Pyx_Raise(__pyx_builtin_StopIteration, 0, 0, 0);
    __PYX_ERR(0, 1974, __pyx_L1_error)
  }

  /* "pysam/calignmentfile.pyx":1967
 *         return ret
 * 
 *     def __next__(self):             # <<<<<<<<<<<<<<
 *         cdef int ret = self.cnext()
 *         if (ret >= 0):
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorRowSelection.__next__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1977
 * 
 * 
 * cdef int __advance_nofilter(void *data, bam1_t *b):             # <<<<<<<<<<<<<<
 *     '''advance without any read filtering.
 *     '''
 */

static int __pyx_f_5pysam_14calignmentfile___advance_nofilter(void *__pyx_v_data, bam1_t *__pyx_v_b) {
  __pyx_t_5pysam_14calignmentfile___iterdata *__pyx_v_d;
  int __pyx_v_ret;
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__advance_nofilter", 0);
  __Pyx_TraceCall("__advance_nofilter", __pyx_f[0], 1977, 0, __PYX_ERR(0, 1977, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1981
 *     '''
 *     cdef __iterdata * d
 *     d = <__iterdata*>data             # <<<<<<<<<<<<<<
 *     cdef int ret
 *     with nogil:
 */
  __pyx_v_d = ((__pyx_t_5pysam_14calignmentfile___iterdata *)__pyx_v_data);

  /* "pysam/calignmentfile.pyx":1983
 *     d = <__iterdata*>data
 *     cdef int ret
 *     with nogil:             # <<<<<<<<<<<<<<
 *         ret = sam_itr_next(d.htsfile, d.iter, b)
 *     return ret
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "pysam/calignmentfile.pyx":1984
 *     cdef int ret
 *     with nogil:
 *         ret = sam_itr_next(d.htsfile, d.iter, b)             # <<<<<<<<<<<<<<
 *     return ret
 * 
 */
        __pyx_v_ret = sam_itr_next(__pyx_v_d->htsfile, __pyx_v_d->iter, __pyx_v_b);
      }

      /* "pysam/calignmentfile.pyx":1983
 *     d = <__iterdata*>data
 *     cdef int ret
 *     with nogil:             # <<<<<<<<<<<<<<
 *         ret = sam_itr_next(d.htsfile, d.iter, b)
 *     return ret
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L5:;
      }
  }

  /* "pysam/calignmentfile.pyx":1985
 *     with nogil:
 *         ret = sam_itr_next(d.htsfile, d.iter, b)
 *     return ret             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1977
 * 
 * 
 * cdef int __advance_nofilter(void *data, bam1_t *b):             # <<<<<<<<<<<<<<
 *     '''advance without any read filtering.
 *     '''
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("pysam.calignmentfile.__advance_nofilter", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":1988
 * 
 * 
 * cdef int __advance_all(void *data, bam1_t *b):             # <<<<<<<<<<<<<<
 *     '''only use reads for pileup passing basic
 *     filters:
 */

static int __pyx_f_5pysam_14calignmentfile___advance_all(void *__pyx_v_data, bam1_t *__pyx_v_b) {
  __pyx_t_5pysam_14calignmentfile___iterdata *__pyx_v_d;
  PyObject *__pyx_v_mask = 0;
  int __pyx_v_ret;
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("__advance_all", 0);
  __Pyx_TraceCall("__advance_all", __pyx_f[0], 1988, 0, __PYX_ERR(0, 1988, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":1996
 * 
 *     cdef __iterdata * d
 *     cdef mask = BAM_FUNMAP | BAM_FSECONDARY | BAM_FQCFAIL | BAM_FDUP             # <<<<<<<<<<<<<<
 *     d = <__iterdata*>data
 *     cdef int ret
 */
  __pyx_t_1 = __Pyx_PyInt_From_int((((BAM_FUNMAP | BAM_FSECONDARY) | BAM_FQCFAIL) | BAM_FDUP)); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 1996, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_mask = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "pysam/calignmentfile.pyx":1997
 *     cdef __iterdata * d
 *     cdef mask = BAM_FUNMAP | BAM_FSECONDARY | BAM_FQCFAIL | BAM_FDUP
 *     d = <__iterdata*>data             # <<<<<<<<<<<<<<
 *     cdef int ret
 *     with nogil:
 */
  __pyx_v_d = ((__pyx_t_5pysam_14calignmentfile___iterdata *)__pyx_v_data);

  /* "pysam/calignmentfile.pyx":1999
 *     d = <__iterdata*>data
 *     cdef int ret
 *     with nogil:             # <<<<<<<<<<<<<<
 *         ret = sam_itr_next(d.htsfile, d.iter, b)
 *     while ret >= 0 and b.core.flag & mask:
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "pysam/calignmentfile.pyx":2000
 *     cdef int ret
 *     with nogil:
 *         ret = sam_itr_next(d.htsfile, d.iter, b)             # <<<<<<<<<<<<<<
 *     while ret >= 0 and b.core.flag & mask:
 *         with nogil:
 */
        __pyx_v_ret = sam_itr_next(__pyx_v_d->htsfile, __pyx_v_d->iter, __pyx_v_b);
      }

      /* "pysam/calignmentfile.pyx":1999
 *     d = <__iterdata*>data
 *     cdef int ret
 *     with nogil:             # <<<<<<<<<<<<<<
 *         ret = sam_itr_next(d.htsfile, d.iter, b)
 *     while ret >= 0 and b.core.flag & mask:
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L5:;
      }
  }

  /* "pysam/calignmentfile.pyx":2001
 *     with nogil:
 *         ret = sam_itr_next(d.htsfile, d.iter, b)
 *     while ret >= 0 and b.core.flag & mask:             # <<<<<<<<<<<<<<
 *         with nogil:
 *             ret = sam_itr_next(d.htsfile, d.iter, b)
 */
  while (1) {
    __pyx_t_3 = ((__pyx_v_ret >= 0) != 0);
    if (__pyx_t_3) {
    } else {
      __pyx_t_2 = __pyx_t_3;
      goto __pyx_L8_bool_binop_done;
    }
    __pyx_t_1 = __Pyx_PyInt_From_uint16_t(__pyx_v_b->core.flag); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2001, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __pyx_t_4 = PyNumber_And(__pyx_t_1, __pyx_v_mask); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2001, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
    __pyx_t_3 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_3 < 0)) __PYX_ERR(0, 2001, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_2 = __pyx_t_3;
    __pyx_L8_bool_binop_done:;
    if (!__pyx_t_2) break;

    /* "pysam/calignmentfile.pyx":2002
 *         ret = sam_itr_next(d.htsfile, d.iter, b)
 *     while ret >= 0 and b.core.flag & mask:
 *         with nogil:             # <<<<<<<<<<<<<<
 *             ret = sam_itr_next(d.htsfile, d.iter, b)
 *     return ret
 */
    {
        #ifdef WITH_THREAD
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
        #endif
        /*try:*/ {

          /* "pysam/calignmentfile.pyx":2003
 *     while ret >= 0 and b.core.flag & mask:
 *         with nogil:
 *             ret = sam_itr_next(d.htsfile, d.iter, b)             # <<<<<<<<<<<<<<
 *     return ret
 * 
 */
          __pyx_v_ret = sam_itr_next(__pyx_v_d->htsfile, __pyx_v_d->iter, __pyx_v_b);
        }

        /* "pysam/calignmentfile.pyx":2002
 *         ret = sam_itr_next(d.htsfile, d.iter, b)
 *     while ret >= 0 and b.core.flag & mask:
 *         with nogil:             # <<<<<<<<<<<<<<
 *             ret = sam_itr_next(d.htsfile, d.iter, b)
 *     return ret
 */
        /*finally:*/ {
          /*normal exit:*/{
            #ifdef WITH_THREAD
            Py_BLOCK_THREADS
            #endif
            goto __pyx_L14;
          }
          __pyx_L14:;
        }
    }
  }

  /* "pysam/calignmentfile.pyx":2004
 *         with nogil:
 *             ret = sam_itr_next(d.htsfile, d.iter, b)
 *     return ret             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":1988
 * 
 * 
 * cdef int __advance_all(void *data, bam1_t *b):             # <<<<<<<<<<<<<<
 *     '''only use reads for pileup passing basic
 *     filters:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_WriteUnraisable("pysam.calignmentfile.__advance_all", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_mask);
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2007
 * 
 * 
 * cdef int __advance_snpcalls(void * data, bam1_t * b):             # <<<<<<<<<<<<<<
 *     '''advance using same filter and read processing as in
 *     the samtools pileup.
 */

static int __pyx_f_5pysam_14calignmentfile___advance_snpcalls(void *__pyx_v_data, bam1_t *__pyx_v_b) {
  __pyx_t_5pysam_14calignmentfile___iterdata *__pyx_v_d;
  int __pyx_v_ret;
  int __pyx_v_skip;
  int __pyx_v_q;
  int __pyx_v_is_cns;
  int __pyx_v_is_nobaq;
  int __pyx_v_capQ_thres;
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  int32_t __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  __Pyx_RefNannySetupContext("__advance_snpcalls", 0);
  __Pyx_TraceCall("__advance_snpcalls", __pyx_f[0], 2007, 0, __PYX_ERR(0, 2007, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2019
 *     # 2. bam_cap_mapQ
 *     cdef __iterdata * d
 *     d = <__iterdata*>data             # <<<<<<<<<<<<<<
 * 
 *     cdef int ret
 */
  __pyx_v_d = ((__pyx_t_5pysam_14calignmentfile___iterdata *)__pyx_v_data);

  /* "pysam/calignmentfile.pyx":2022
 * 
 *     cdef int ret
 *     cdef int skip = 0             # <<<<<<<<<<<<<<
 *     cdef int q
 *     cdef int is_cns = 1
 */
  __pyx_v_skip = 0;

  /* "pysam/calignmentfile.pyx":2024
 *     cdef int skip = 0
 *     cdef int q
 *     cdef int is_cns = 1             # <<<<<<<<<<<<<<
 *     cdef int is_nobaq = 0
 *     cdef int capQ_thres = 0
 */
  __pyx_v_is_cns = 1;

  /* "pysam/calignmentfile.pyx":2025
 *     cdef int q
 *     cdef int is_cns = 1
 *     cdef int is_nobaq = 0             # <<<<<<<<<<<<<<
 *     cdef int capQ_thres = 0
 * 
 */
  __pyx_v_is_nobaq = 0;

  /* "pysam/calignmentfile.pyx":2026
 *     cdef int is_cns = 1
 *     cdef int is_nobaq = 0
 *     cdef int capQ_thres = 0             # <<<<<<<<<<<<<<
 * 
 *     with nogil:
 */
  __pyx_v_capQ_thres = 0;

  /* "pysam/calignmentfile.pyx":2028
 *     cdef int capQ_thres = 0
 * 
 *     with nogil:             # <<<<<<<<<<<<<<
 *         ret = sam_itr_next(d.htsfile, d.iter, b)
 * 
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "pysam/calignmentfile.pyx":2029
 * 
 *     with nogil:
 *         ret = sam_itr_next(d.htsfile, d.iter, b)             # <<<<<<<<<<<<<<
 * 
 *     # reload sequence
 */
        __pyx_v_ret = sam_itr_next(__pyx_v_d->htsfile, __pyx_v_d->iter, __pyx_v_b);
      }

      /* "pysam/calignmentfile.pyx":2028
 *     cdef int capQ_thres = 0
 * 
 *     with nogil:             # <<<<<<<<<<<<<<
 *         ret = sam_itr_next(d.htsfile, d.iter, b)
 * 
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L5;
        }
        __pyx_L5:;
      }
  }

  /* "pysam/calignmentfile.pyx":2032
 * 
 *     # reload sequence
 *     if d.fastafile != NULL and b.core.tid != d.tid:             # <<<<<<<<<<<<<<
 *         if d.seq != NULL:
 *             free(d.seq)
 */
  __pyx_t_2 = ((__pyx_v_d->fastafile != NULL) != 0);
  if (__pyx_t_2) {
  } else {
    __pyx_t_1 = __pyx_t_2;
    goto __pyx_L7_bool_binop_done;
  }
  __pyx_t_2 = ((__pyx_v_b->core.tid != __pyx_v_d->tid) != 0);
  __pyx_t_1 = __pyx_t_2;
  __pyx_L7_bool_binop_done:;
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":2033
 *     # reload sequence
 *     if d.fastafile != NULL and b.core.tid != d.tid:
 *         if d.seq != NULL:             # <<<<<<<<<<<<<<
 *             free(d.seq)
 *         d.tid = b.core.tid
 */
    __pyx_t_1 = ((__pyx_v_d->seq != NULL) != 0);
    if (__pyx_t_1) {

      /* "pysam/calignmentfile.pyx":2034
 *     if d.fastafile != NULL and b.core.tid != d.tid:
 *         if d.seq != NULL:
 *             free(d.seq)             # <<<<<<<<<<<<<<
 *         d.tid = b.core.tid
 *         with nogil:
 */
      free(__pyx_v_d->seq);

      /* "pysam/calignmentfile.pyx":2033
 *     # reload sequence
 *     if d.fastafile != NULL and b.core.tid != d.tid:
 *         if d.seq != NULL:             # <<<<<<<<<<<<<<
 *             free(d.seq)
 *         d.tid = b.core.tid
 */
    }

    /* "pysam/calignmentfile.pyx":2035
 *         if d.seq != NULL:
 *             free(d.seq)
 *         d.tid = b.core.tid             # <<<<<<<<<<<<<<
 *         with nogil:
 *             d.seq = faidx_fetch_seq(
 */
    __pyx_t_3 = __pyx_v_b->core.tid;
    __pyx_v_d->tid = __pyx_t_3;

    /* "pysam/calignmentfile.pyx":2036
 *             free(d.seq)
 *         d.tid = b.core.tid
 *         with nogil:             # <<<<<<<<<<<<<<
 *             d.seq = faidx_fetch_seq(
 *                 d.fastafile,
 */
    {
        #ifdef WITH_THREAD
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
        #endif
        /*try:*/ {

          /* "pysam/calignmentfile.pyx":2037
 *         d.tid = b.core.tid
 *         with nogil:
 *             d.seq = faidx_fetch_seq(             # <<<<<<<<<<<<<<
 *                 d.fastafile,
 *                 d.header.target_name[d.tid],
 */
          __pyx_v_d->seq = faidx_fetch_seq(__pyx_v_d->fastafile, (__pyx_v_d->header->target_name[__pyx_v_d->tid]), 0, __pyx_v_5pysam_14calignmentfile_MAX_POS, (&__pyx_v_d->seq_len));
        }

        /* "pysam/calignmentfile.pyx":2036
 *             free(d.seq)
 *         d.tid = b.core.tid
 *         with nogil:             # <<<<<<<<<<<<<<
 *             d.seq = faidx_fetch_seq(
 *                 d.fastafile,
 */
        /*finally:*/ {
          /*normal exit:*/{
            #ifdef WITH_THREAD
            Py_BLOCK_THREADS
            #endif
            goto __pyx_L12;
          }
          __pyx_L12:;
        }
    }

    /* "pysam/calignmentfile.pyx":2043
 *                 &d.seq_len)
 * 
 *         if d.seq == NULL:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 "reference sequence for '%s' (tid=%i) not found" % \
 */
    __pyx_t_1 = ((__pyx_v_d->seq == NULL) != 0);
    if (__pyx_t_1) {

      /* "pysam/calignmentfile.pyx":2046
 *             raise ValueError(
 *                 "reference sequence for '%s' (tid=%i) not found" % \
 *                 (d.header.target_name[d.tid],             # <<<<<<<<<<<<<<
 *                  d.tid))
 * 
 */
      __pyx_t_4 = __Pyx_PyBytes_FromString((__pyx_v_d->header->target_name[__pyx_v_d->tid])); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2046, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);

      /* "pysam/calignmentfile.pyx":2047
 *                 "reference sequence for '%s' (tid=%i) not found" % \
 *                 (d.header.target_name[d.tid],
 *                  d.tid))             # <<<<<<<<<<<<<<
 * 
 *     while ret >= 0:
 */
      __pyx_t_5 = __Pyx_PyInt_From_int(__pyx_v_d->tid); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2047, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);

      /* "pysam/calignmentfile.pyx":2046
 *             raise ValueError(
 *                 "reference sequence for '%s' (tid=%i) not found" % \
 *                 (d.header.target_name[d.tid],             # <<<<<<<<<<<<<<
 *                  d.tid))
 * 
 */
      __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2046, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_GIVEREF(__pyx_t_4);
      PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4);
      __Pyx_GIVEREF(__pyx_t_5);
      PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_t_5);
      __pyx_t_4 = 0;
      __pyx_t_5 = 0;

      /* "pysam/calignmentfile.pyx":2045
 *         if d.seq == NULL:
 *             raise ValueError(
 *                 "reference sequence for '%s' (tid=%i) not found" % \             # <<<<<<<<<<<<<<
 *                 (d.header.target_name[d.tid],
 *                  d.tid))
 */
      __pyx_t_5 = __Pyx_PyString_Format(__pyx_kp_s_reference_sequence_for_s_tid_i_n, __pyx_t_6); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2045, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;

      /* "pysam/calignmentfile.pyx":2044
 * 
 *         if d.seq == NULL:
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 "reference sequence for '%s' (tid=%i) not found" % \
 *                 (d.header.target_name[d.tid],
 */
      __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2044, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_GIVEREF(__pyx_t_5);
      PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_5);
      __pyx_t_5 = 0;
      __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_6, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2044, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_Raise(__pyx_t_5, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __PYX_ERR(0, 2044, __pyx_L1_error)

      /* "pysam/calignmentfile.pyx":2043
 *                 &d.seq_len)
 * 
 *         if d.seq == NULL:             # <<<<<<<<<<<<<<
 *             raise ValueError(
 *                 "reference sequence for '%s' (tid=%i) not found" % \
 */
    }

    /* "pysam/calignmentfile.pyx":2032
 * 
 *     # reload sequence
 *     if d.fastafile != NULL and b.core.tid != d.tid:             # <<<<<<<<<<<<<<
 *         if d.seq != NULL:
 *             free(d.seq)
 */
  }

  /* "pysam/calignmentfile.pyx":2049
 *                  d.tid))
 * 
 *     while ret >= 0:             # <<<<<<<<<<<<<<
 *         skip = 0
 * 
 */
  while (1) {
    __pyx_t_1 = ((__pyx_v_ret >= 0) != 0);
    if (!__pyx_t_1) break;

    /* "pysam/calignmentfile.pyx":2050
 * 
 *     while ret >= 0:
 *         skip = 0             # <<<<<<<<<<<<<<
 * 
 *         # realign read - changes base qualities
 */
    __pyx_v_skip = 0;

    /* "pysam/calignmentfile.pyx":2053
 * 
 *         # realign read - changes base qualities
 *         if d.seq != NULL and is_cns and not is_nobaq:             # <<<<<<<<<<<<<<
 *             bam_prob_realn(b, d.seq)
 * 
 */
    __pyx_t_2 = ((__pyx_v_d->seq != NULL) != 0);
    if (__pyx_t_2) {
    } else {
      __pyx_t_1 = __pyx_t_2;
      goto __pyx_L17_bool_binop_done;
    }
    __pyx_t_2 = (__pyx_v_is_cns != 0);
    if (__pyx_t_2) {
    } else {
      __pyx_t_1 = __pyx_t_2;
      goto __pyx_L17_bool_binop_done;
    }
    __pyx_t_2 = ((!(__pyx_v_is_nobaq != 0)) != 0);
    __pyx_t_1 = __pyx_t_2;
    __pyx_L17_bool_binop_done:;
    if (__pyx_t_1) {

      /* "pysam/calignmentfile.pyx":2054
 *         # realign read - changes base qualities
 *         if d.seq != NULL and is_cns and not is_nobaq:
 *             bam_prob_realn(b, d.seq)             # <<<<<<<<<<<<<<
 * 
 *         if d.seq != NULL and capQ_thres > 10:
 */
      bam_prob_realn(__pyx_v_b, __pyx_v_d->seq);

      /* "pysam/calignmentfile.pyx":2053
 * 
 *         # realign read - changes base qualities
 *         if d.seq != NULL and is_cns and not is_nobaq:             # <<<<<<<<<<<<<<
 *             bam_prob_realn(b, d.seq)
 * 
 */
    }

    /* "pysam/calignmentfile.pyx":2056
 *             bam_prob_realn(b, d.seq)
 * 
 *         if d.seq != NULL and capQ_thres > 10:             # <<<<<<<<<<<<<<
 *             q = bam_cap_mapQ(b, d.seq, capQ_thres)
 *             if q < 0:
 */
    __pyx_t_2 = ((__pyx_v_d->seq != NULL) != 0);
    if (__pyx_t_2) {
    } else {
      __pyx_t_1 = __pyx_t_2;
      goto __pyx_L21_bool_binop_done;
    }
    __pyx_t_2 = ((__pyx_v_capQ_thres > 10) != 0);
    __pyx_t_1 = __pyx_t_2;
    __pyx_L21_bool_binop_done:;
    if (__pyx_t_1) {

      /* "pysam/calignmentfile.pyx":2057
 * 
 *         if d.seq != NULL and capQ_thres > 10:
 *             q = bam_cap_mapQ(b, d.seq, capQ_thres)             # <<<<<<<<<<<<<<
 *             if q < 0:
 *                 skip = 1
 */
      __pyx_v_q = bam_cap_mapQ(__pyx_v_b, __pyx_v_d->seq, __pyx_v_capQ_thres);

      /* "pysam/calignmentfile.pyx":2058
 *         if d.seq != NULL and capQ_thres > 10:
 *             q = bam_cap_mapQ(b, d.seq, capQ_thres)
 *             if q < 0:             # <<<<<<<<<<<<<<
 *                 skip = 1
 *             elif b.core.qual > q:
 */
      __pyx_t_1 = ((__pyx_v_q < 0) != 0);
      if (__pyx_t_1) {

        /* "pysam/calignmentfile.pyx":2059
 *             q = bam_cap_mapQ(b, d.seq, capQ_thres)
 *             if q < 0:
 *                 skip = 1             # <<<<<<<<<<<<<<
 *             elif b.core.qual > q:
 *                 b.core.qual = q
 */
        __pyx_v_skip = 1;

        /* "pysam/calignmentfile.pyx":2058
 *         if d.seq != NULL and capQ_thres > 10:
 *             q = bam_cap_mapQ(b, d.seq, capQ_thres)
 *             if q < 0:             # <<<<<<<<<<<<<<
 *                 skip = 1
 *             elif b.core.qual > q:
 */
        goto __pyx_L23;
      }

      /* "pysam/calignmentfile.pyx":2060
 *             if q < 0:
 *                 skip = 1
 *             elif b.core.qual > q:             # <<<<<<<<<<<<<<
 *                 b.core.qual = q
 *         if b.core.flag & BAM_FUNMAP:
 */
      __pyx_t_1 = ((__pyx_v_b->core.qual > __pyx_v_q) != 0);
      if (__pyx_t_1) {

        /* "pysam/calignmentfile.pyx":2061
 *                 skip = 1
 *             elif b.core.qual > q:
 *                 b.core.qual = q             # <<<<<<<<<<<<<<
 *         if b.core.flag & BAM_FUNMAP:
 *             skip = 1
 */
        __pyx_v_b->core.qual = __pyx_v_q;

        /* "pysam/calignmentfile.pyx":2060
 *             if q < 0:
 *                 skip = 1
 *             elif b.core.qual > q:             # <<<<<<<<<<<<<<
 *                 b.core.qual = q
 *         if b.core.flag & BAM_FUNMAP:
 */
      }
      __pyx_L23:;

      /* "pysam/calignmentfile.pyx":2056
 *             bam_prob_realn(b, d.seq)
 * 
 *         if d.seq != NULL and capQ_thres > 10:             # <<<<<<<<<<<<<<
 *             q = bam_cap_mapQ(b, d.seq, capQ_thres)
 *             if q < 0:
 */
    }

    /* "pysam/calignmentfile.pyx":2062
 *             elif b.core.qual > q:
 *                 b.core.qual = q
 *         if b.core.flag & BAM_FUNMAP:             # <<<<<<<<<<<<<<
 *             skip = 1
 *         elif b.core.flag & 1 and not b.core.flag & 2:
 */
    __pyx_t_1 = ((__pyx_v_b->core.flag & BAM_FUNMAP) != 0);
    if (__pyx_t_1) {

      /* "pysam/calignmentfile.pyx":2063
 *                 b.core.qual = q
 *         if b.core.flag & BAM_FUNMAP:
 *             skip = 1             # <<<<<<<<<<<<<<
 *         elif b.core.flag & 1 and not b.core.flag & 2:
 *             skip = 1
 */
      __pyx_v_skip = 1;

      /* "pysam/calignmentfile.pyx":2062
 *             elif b.core.qual > q:
 *                 b.core.qual = q
 *         if b.core.flag & BAM_FUNMAP:             # <<<<<<<<<<<<<<
 *             skip = 1
 *         elif b.core.flag & 1 and not b.core.flag & 2:
 */
      goto __pyx_L24;
    }

    /* "pysam/calignmentfile.pyx":2064
 *         if b.core.flag & BAM_FUNMAP:
 *             skip = 1
 *         elif b.core.flag & 1 and not b.core.flag & 2:             # <<<<<<<<<<<<<<
 *             skip = 1
 * 
 */
    __pyx_t_2 = ((__pyx_v_b->core.flag & 1) != 0);
    if (__pyx_t_2) {
    } else {
      __pyx_t_1 = __pyx_t_2;
      goto __pyx_L25_bool_binop_done;
    }
    __pyx_t_2 = ((!((__pyx_v_b->core.flag & 2) != 0)) != 0);
    __pyx_t_1 = __pyx_t_2;
    __pyx_L25_bool_binop_done:;
    if (__pyx_t_1) {

      /* "pysam/calignmentfile.pyx":2065
 *             skip = 1
 *         elif b.core.flag & 1 and not b.core.flag & 2:
 *             skip = 1             # <<<<<<<<<<<<<<
 * 
 *         if not skip:
 */
      __pyx_v_skip = 1;

      /* "pysam/calignmentfile.pyx":2064
 *         if b.core.flag & BAM_FUNMAP:
 *             skip = 1
 *         elif b.core.flag & 1 and not b.core.flag & 2:             # <<<<<<<<<<<<<<
 *             skip = 1
 * 
 */
    }
    __pyx_L24:;

    /* "pysam/calignmentfile.pyx":2067
 *             skip = 1
 * 
 *         if not skip:             # <<<<<<<<<<<<<<
 *             break
 *         # additional filters
 */
    __pyx_t_1 = ((!(__pyx_v_skip != 0)) != 0);
    if (__pyx_t_1) {

      /* "pysam/calignmentfile.pyx":2068
 * 
 *         if not skip:
 *             break             # <<<<<<<<<<<<<<
 *         # additional filters
 * 
 */
      goto __pyx_L15_break;

      /* "pysam/calignmentfile.pyx":2067
 *             skip = 1
 * 
 *         if not skip:             # <<<<<<<<<<<<<<
 *             break
 *         # additional filters
 */
    }

    /* "pysam/calignmentfile.pyx":2071
 *         # additional filters
 * 
 *         with nogil:             # <<<<<<<<<<<<<<
 *             ret = sam_itr_next(d.htsfile, d.iter, b)
 * 
 */
    {
        #ifdef WITH_THREAD
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
        #endif
        /*try:*/ {

          /* "pysam/calignmentfile.pyx":2072
 * 
 *         with nogil:
 *             ret = sam_itr_next(d.htsfile, d.iter, b)             # <<<<<<<<<<<<<<
 * 
 *     return ret
 */
          __pyx_v_ret = sam_itr_next(__pyx_v_d->htsfile, __pyx_v_d->iter, __pyx_v_b);
        }

        /* "pysam/calignmentfile.pyx":2071
 *         # additional filters
 * 
 *         with nogil:             # <<<<<<<<<<<<<<
 *             ret = sam_itr_next(d.htsfile, d.iter, b)
 * 
 */
        /*finally:*/ {
          /*normal exit:*/{
            #ifdef WITH_THREAD
            Py_BLOCK_THREADS
            #endif
            goto __pyx_L32;
          }
          __pyx_L32:;
        }
    }
  }
  __pyx_L15_break:;

  /* "pysam/calignmentfile.pyx":2074
 *             ret = sam_itr_next(d.htsfile, d.iter, b)
 * 
 *     return ret             # <<<<<<<<<<<<<<
 * 
 * cdef class IteratorColumn:
 */
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":2007
 * 
 * 
 * cdef int __advance_snpcalls(void * data, bam1_t * b):             # <<<<<<<<<<<<<<
 *     '''advance using same filter and read processing as in
 *     the samtools pileup.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_WriteUnraisable("pysam.calignmentfile.__advance_snpcalls", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2122
 *     '''
 * 
 *     def __cinit__( self, AlignmentFile samfile, **kwargs ):             # <<<<<<<<<<<<<<
 *         self.samfile = samfile
 *         self.fastafile = kwargs.get("fastafile", None)
 */

/* Python wrapper */
static int __pyx_pw_5pysam_14calignmentfile_14IteratorColumn_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_5pysam_14calignmentfile_14IteratorColumn_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile = 0;
  PyObject *__pyx_v_kwargs = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return -1;
  __Pyx_GOTREF(__pyx_v_kwargs);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_samfile,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_samfile)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 2122, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_samfile = ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)values[0]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2122, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorColumn.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_samfile), __pyx_ptype_5pysam_14calignmentfile_AlignmentFile, 1, "samfile", 0))) __PYX_ERR(0, 2122, __pyx_L1_error)
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_14IteratorColumn___cinit__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *)__pyx_v_self), __pyx_v_samfile, __pyx_v_kwargs);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_kwargs);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_5pysam_14calignmentfile_14IteratorColumn___cinit__(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile, PyObject *__pyx_v_kwargs) {
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("__cinit__", 0);
  __Pyx_TraceCall("__cinit__", __pyx_f[0], 2122, 0, __PYX_ERR(0, 2122, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2123
 * 
 *     def __cinit__( self, AlignmentFile samfile, **kwargs ):
 *         self.samfile = samfile             # <<<<<<<<<<<<<<
 *         self.fastafile = kwargs.get("fastafile", None)
 *         self.stepper = kwargs.get("stepper", None)
 */
  __Pyx_INCREF(((PyObject *)__pyx_v_samfile));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_samfile));
  __Pyx_GOTREF(__pyx_v_self->samfile);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->samfile));
  __pyx_v_self->samfile = __pyx_v_samfile;

  /* "pysam/calignmentfile.pyx":2124
 *     def __cinit__( self, AlignmentFile samfile, **kwargs ):
 *         self.samfile = samfile
 *         self.fastafile = kwargs.get("fastafile", None)             # <<<<<<<<<<<<<<
 *         self.stepper = kwargs.get("stepper", None)
 *         self.max_depth = kwargs.get("max_depth", 8000)
 */
  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_kwargs, __pyx_n_s_fastafile, Py_None); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2124, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  if (!(likely(((__pyx_t_1) == Py_None) || likely(__Pyx_TypeTest(__pyx_t_1, __pyx_ptype_5pysam_6cfaidx_Fastafile))))) __PYX_ERR(0, 2124, __pyx_L1_error)
  __Pyx_GIVEREF(__pyx_t_1);
  __Pyx_GOTREF(__pyx_v_self->fastafile);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->fastafile));
  __pyx_v_self->fastafile = ((struct __pyx_obj_5pysam_6cfaidx_Fastafile *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "pysam/calignmentfile.pyx":2125
 *         self.samfile = samfile
 *         self.fastafile = kwargs.get("fastafile", None)
 *         self.stepper = kwargs.get("stepper", None)             # <<<<<<<<<<<<<<
 *         self.max_depth = kwargs.get("max_depth", 8000)
 *         self.iterdata.seq = NULL
 */
  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_kwargs, __pyx_n_s_stepper, Py_None); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2125, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_1);
  __Pyx_GOTREF(__pyx_v_self->stepper);
  __Pyx_DECREF(__pyx_v_self->stepper);
  __pyx_v_self->stepper = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "pysam/calignmentfile.pyx":2126
 *         self.fastafile = kwargs.get("fastafile", None)
 *         self.stepper = kwargs.get("stepper", None)
 *         self.max_depth = kwargs.get("max_depth", 8000)             # <<<<<<<<<<<<<<
 *         self.iterdata.seq = NULL
 *         self.tid = 0
 */
  __pyx_t_1 = __Pyx_PyDict_GetItemDefault(__pyx_v_kwargs, __pyx_n_s_max_depth, __pyx_int_8000); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2126, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyInt_As_int(__pyx_t_1); if (unlikely((__pyx_t_2 == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 2126, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_v_self->max_depth = __pyx_t_2;

  /* "pysam/calignmentfile.pyx":2127
 *         self.stepper = kwargs.get("stepper", None)
 *         self.max_depth = kwargs.get("max_depth", 8000)
 *         self.iterdata.seq = NULL             # <<<<<<<<<<<<<<
 *         self.tid = 0
 *         self.pos = 0
 */
  __pyx_v_self->iterdata.seq = NULL;

  /* "pysam/calignmentfile.pyx":2128
 *         self.max_depth = kwargs.get("max_depth", 8000)
 *         self.iterdata.seq = NULL
 *         self.tid = 0             # <<<<<<<<<<<<<<
 *         self.pos = 0
 *         self.n_plp = 0
 */
  __pyx_v_self->tid = 0;

  /* "pysam/calignmentfile.pyx":2129
 *         self.iterdata.seq = NULL
 *         self.tid = 0
 *         self.pos = 0             # <<<<<<<<<<<<<<
 *         self.n_plp = 0
 *         self.plp = NULL
 */
  __pyx_v_self->pos = 0;

  /* "pysam/calignmentfile.pyx":2130
 *         self.tid = 0
 *         self.pos = 0
 *         self.n_plp = 0             # <<<<<<<<<<<<<<
 *         self.plp = NULL
 *         self.pileup_iter = <bam_plp_t>NULL
 */
  __pyx_v_self->n_plp = 0;

  /* "pysam/calignmentfile.pyx":2131
 *         self.pos = 0
 *         self.n_plp = 0
 *         self.plp = NULL             # <<<<<<<<<<<<<<
 *         self.pileup_iter = <bam_plp_t>NULL
 * 
 */
  __pyx_v_self->plp = NULL;

  /* "pysam/calignmentfile.pyx":2132
 *         self.n_plp = 0
 *         self.plp = NULL
 *         self.pileup_iter = <bam_plp_t>NULL             # <<<<<<<<<<<<<<
 * 
 *     def __iter__(self):
 */
  __pyx_v_self->pileup_iter = ((bam_plp_t)NULL);

  /* "pysam/calignmentfile.pyx":2122
 *     '''
 * 
 *     def __cinit__( self, AlignmentFile samfile, **kwargs ):             # <<<<<<<<<<<<<<
 *         self.samfile = samfile
 *         self.fastafile = kwargs.get("fastafile", None)
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorColumn.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2134
 *         self.pileup_iter = <bam_plp_t>NULL
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return self
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_14IteratorColumn_3__iter__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_14IteratorColumn_3__iter__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__iter__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_14IteratorColumn_2__iter__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_14IteratorColumn_2__iter__(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__iter__", 0);
  __Pyx_TraceCall("__iter__", __pyx_f[0], 2134, 0, __PYX_ERR(0, 2134, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2135
 * 
 *     def __iter__(self):
 *         return self             # <<<<<<<<<<<<<<
 * 
 *     cdef int cnext(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __pyx_r = ((PyObject *)__pyx_v_self);
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":2134
 *         self.pileup_iter = <bam_plp_t>NULL
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return self
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorColumn.__iter__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2137
 *         return self
 * 
 *     cdef int cnext(self):             # <<<<<<<<<<<<<<
 *         '''perform next iteration.
 *         '''
 */

static int __pyx_f_5pysam_14calignmentfile_14IteratorColumn_cnext(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self) {
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("cnext", 0);
  __Pyx_TraceCall("cnext", __pyx_f[0], 2137, 0, __PYX_ERR(0, 2137, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2141
 *         '''
 *         # do not release gil here because of call-backs
 *         self.plp = bam_plp_auto(self.pileup_iter,             # <<<<<<<<<<<<<<
 *                                 &self.tid,
 *                                 &self.pos,
 */
  __pyx_v_self->plp = bam_plp_auto(__pyx_v_self->pileup_iter, (&__pyx_v_self->tid), (&__pyx_v_self->pos), (&__pyx_v_self->n_plp));

  /* "pysam/calignmentfile.pyx":2137
 *         return self
 * 
 *     cdef int cnext(self):             # <<<<<<<<<<<<<<
 *         '''perform next iteration.
 *         '''
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("pysam.calignmentfile.IteratorColumn.cnext", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2146
 *                                 &self.n_plp)
 * 
 *     cdef char * getSequence(self):             # <<<<<<<<<<<<<<
 *         '''return current reference sequence underlying the iterator.
 *         '''
 */

static char *__pyx_f_5pysam_14calignmentfile_14IteratorColumn_getSequence(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self) {
  char *__pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("getSequence", 0);
  __Pyx_TraceCall("getSequence", __pyx_f[0], 2146, 0, __PYX_ERR(0, 2146, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2149
 *         '''return current reference sequence underlying the iterator.
 *         '''
 *         return self.iterdata.seq             # <<<<<<<<<<<<<<
 * 
 *     property seq_len:
 */
  __pyx_r = __pyx_v_self->iterdata.seq;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":2146
 *                                 &self.n_plp)
 * 
 *     cdef char * getSequence(self):             # <<<<<<<<<<<<<<
 *         '''return current reference sequence underlying the iterator.
 *         '''
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("pysam.calignmentfile.IteratorColumn.getSequence", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2153
 *     property seq_len:
 *         '''current sequence length.'''
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             return self.iterdata.seq_len
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_14IteratorColumn_7seq_len_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_14IteratorColumn_7seq_len_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_14IteratorColumn_7seq_len___get__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_14IteratorColumn_7seq_len___get__(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[0], 2153, 0, __PYX_ERR(0, 2153, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2154
 *         '''current sequence length.'''
 *         def __get__(self):
 *             return self.iterdata.seq_len             # <<<<<<<<<<<<<<
 * 
 *     def addReference(self, Fastafile fastafile):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->iterdata.seq_len); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2154, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":2153
 *     property seq_len:
 *         '''current sequence length.'''
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             return self.iterdata.seq_len
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorColumn.seq_len.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2156
 *             return self.iterdata.seq_len
 * 
 *     def addReference(self, Fastafile fastafile):             # <<<<<<<<<<<<<<
 *        '''
 *        add reference sequences in `fastafile` to iterator.'''
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_14IteratorColumn_5addReference(PyObject *__pyx_v_self, PyObject *__pyx_v_fastafile); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_14IteratorColumn_4addReference[] = "IteratorColumn.addReference(self, Fastafile fastafile)\n\n       add reference sequences in `fastafile` to iterator.";
static PyObject *__pyx_pw_5pysam_14calignmentfile_14IteratorColumn_5addReference(PyObject *__pyx_v_self, PyObject *__pyx_v_fastafile) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("addReference (wrapper)", 0);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_fastafile), __pyx_ptype_5pysam_6cfaidx_Fastafile, 1, "fastafile", 0))) __PYX_ERR(0, 2156, __pyx_L1_error)
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_14IteratorColumn_4addReference(((struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *)__pyx_v_self), ((struct __pyx_obj_5pysam_6cfaidx_Fastafile *)__pyx_v_fastafile));

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_14IteratorColumn_4addReference(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self, struct __pyx_obj_5pysam_6cfaidx_Fastafile *__pyx_v_fastafile) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  faidx_t *__pyx_t_2;
  __Pyx_RefNannySetupContext("addReference", 0);
  __Pyx_TraceCall("addReference", __pyx_f[0], 2156, 0, __PYX_ERR(0, 2156, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2159
 *        '''
 *        add reference sequences in `fastafile` to iterator.'''
 *        self.fastafile = fastafile             # <<<<<<<<<<<<<<
 *        if self.iterdata.seq != NULL:
 *            free(self.iterdata.seq)
 */
  __Pyx_INCREF(((PyObject *)__pyx_v_fastafile));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_fastafile));
  __Pyx_GOTREF(__pyx_v_self->fastafile);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->fastafile));
  __pyx_v_self->fastafile = __pyx_v_fastafile;

  /* "pysam/calignmentfile.pyx":2160
 *        add reference sequences in `fastafile` to iterator.'''
 *        self.fastafile = fastafile
 *        if self.iterdata.seq != NULL:             # <<<<<<<<<<<<<<
 *            free(self.iterdata.seq)
 *        self.iterdata.tid = -1
 */
  __pyx_t_1 = ((__pyx_v_self->iterdata.seq != NULL) != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":2161
 *        self.fastafile = fastafile
 *        if self.iterdata.seq != NULL:
 *            free(self.iterdata.seq)             # <<<<<<<<<<<<<<
 *        self.iterdata.tid = -1
 *        self.iterdata.fastafile = self.fastafile.fastafile
 */
    free(__pyx_v_self->iterdata.seq);

    /* "pysam/calignmentfile.pyx":2160
 *        add reference sequences in `fastafile` to iterator.'''
 *        self.fastafile = fastafile
 *        if self.iterdata.seq != NULL:             # <<<<<<<<<<<<<<
 *            free(self.iterdata.seq)
 *        self.iterdata.tid = -1
 */
  }

  /* "pysam/calignmentfile.pyx":2162
 *        if self.iterdata.seq != NULL:
 *            free(self.iterdata.seq)
 *        self.iterdata.tid = -1             # <<<<<<<<<<<<<<
 *        self.iterdata.fastafile = self.fastafile.fastafile
 * 
 */
  __pyx_v_self->iterdata.tid = -1;

  /* "pysam/calignmentfile.pyx":2163
 *            free(self.iterdata.seq)
 *        self.iterdata.tid = -1
 *        self.iterdata.fastafile = self.fastafile.fastafile             # <<<<<<<<<<<<<<
 * 
 *     def hasReference(self):
 */
  __pyx_t_2 = __pyx_v_self->fastafile->__pyx_base.fastafile;
  __pyx_v_self->iterdata.fastafile = __pyx_t_2;

  /* "pysam/calignmentfile.pyx":2156
 *             return self.iterdata.seq_len
 * 
 *     def addReference(self, Fastafile fastafile):             # <<<<<<<<<<<<<<
 *        '''
 *        add reference sequences in `fastafile` to iterator.'''
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorColumn.addReference", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2165
 *        self.iterdata.fastafile = self.fastafile.fastafile
 * 
 *     def hasReference(self):             # <<<<<<<<<<<<<<
 *         '''
 *         return true if iterator is associated with a reference'''
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_14IteratorColumn_7hasReference(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_14IteratorColumn_6hasReference[] = "IteratorColumn.hasReference(self)\n\n        return true if iterator is associated with a reference";
static PyObject *__pyx_pw_5pysam_14calignmentfile_14IteratorColumn_7hasReference(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("hasReference (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_14IteratorColumn_6hasReference(((struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_14IteratorColumn_6hasReference(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("hasReference", 0);
  __Pyx_TraceCall("hasReference", __pyx_f[0], 2165, 0, __PYX_ERR(0, 2165, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2168
 *         '''
 *         return true if iterator is associated with a reference'''
 *         return self.fastafile             # <<<<<<<<<<<<<<
 * 
 *     cdef setMask(self, mask):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(((PyObject *)__pyx_v_self->fastafile));
  __pyx_r = ((PyObject *)__pyx_v_self->fastafile);
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":2165
 *        self.iterdata.fastafile = self.fastafile.fastafile
 * 
 *     def hasReference(self):             # <<<<<<<<<<<<<<
 *         '''
 *         return true if iterator is associated with a reference'''
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorColumn.hasReference", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2170
 *         return self.fastafile
 * 
 *     cdef setMask(self, mask):             # <<<<<<<<<<<<<<
 *         '''set masking flag in iterator.
 * 
 */

static PyObject *__pyx_f_5pysam_14calignmentfile_14IteratorColumn_setMask(CYTHON_UNUSED struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self, CYTHON_UNUSED PyObject *__pyx_v_mask) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("setMask", 0);
  __Pyx_TraceCall("setMask", __pyx_f[0], 2170, 0, __PYX_ERR(0, 2170, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2175
 *         reads with bits set in `mask` will be skipped.
 *         '''
 *         raise NotImplementedError()             # <<<<<<<<<<<<<<
 *         # self.mask = mask
 *         # bam_plp_set_mask( self.pileup_iter, self.mask )
 */
  __pyx_t_1 = __Pyx_PyObject_CallNoArg(__pyx_builtin_NotImplementedError); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2175, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_Raise(__pyx_t_1, 0, 0, 0);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __PYX_ERR(0, 2175, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":2170
 *         return self.fastafile
 * 
 *     cdef setMask(self, mask):             # <<<<<<<<<<<<<<
 *         '''set masking flag in iterator.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorColumn.setMask", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2179
 *         # bam_plp_set_mask( self.pileup_iter, self.mask )
 * 
 *     cdef setupIteratorData( self,             # <<<<<<<<<<<<<<
 *                             int tid,
 *                             int start,
 */

static PyObject *__pyx_f_5pysam_14calignmentfile_14IteratorColumn_setupIteratorData(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self, int __pyx_v_tid, int __pyx_v_start, int __pyx_v_end, struct __pyx_opt_args_5pysam_14calignmentfile_14IteratorColumn_setupIteratorData *__pyx_optional_args) {
  int __pyx_v_multiple_iterators = ((int)0);
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  htsFile *__pyx_t_6;
  hts_itr_t *__pyx_t_7;
  bam_hdr_t *__pyx_t_8;
  int __pyx_t_9;
  int __pyx_t_10;
  faidx_t *__pyx_t_11;
  int __pyx_t_12;
  __Pyx_RefNannySetupContext("setupIteratorData", 0);
  __Pyx_TraceCall("setupIteratorData", __pyx_f[0], 2179, 0, __PYX_ERR(0, 2179, __pyx_L1_error));
  if (__pyx_optional_args) {
    if (__pyx_optional_args->__pyx_n > 0) {
      __pyx_v_multiple_iterators = __pyx_optional_args->multiple_iterators;
    }
  }

  /* "pysam/calignmentfile.pyx":2186
 *         '''setup the iterator structure'''
 * 
 *         self.iter = IteratorRowRegion(self.samfile, tid, start, end, multiple_iterators)             # <<<<<<<<<<<<<<
 *         self.iterdata.htsfile = self.samfile.htsfile
 *         self.iterdata.iter = self.iter.iter
 */
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_tid); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2186, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyInt_From_int(__pyx_v_start); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2186, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_end); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2186, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyInt_From_int(__pyx_v_multiple_iterators); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2186, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = PyTuple_New(5); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2186, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_INCREF(((PyObject *)__pyx_v_self->samfile));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_self->samfile));
  PyTuple_SET_ITEM(__pyx_t_5, 0, ((PyObject *)__pyx_v_self->samfile));
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_5, 2, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_5, 3, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_4);
  PyTuple_SET_ITEM(__pyx_t_5, 4, __pyx_t_4);
  __pyx_t_1 = 0;
  __pyx_t_2 = 0;
  __pyx_t_3 = 0;
  __pyx_t_4 = 0;
  __pyx_t_4 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_5pysam_14calignmentfile_IteratorRowRegion), __pyx_t_5, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2186, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  __Pyx_GIVEREF(__pyx_t_4);
  __Pyx_GOTREF(__pyx_v_self->iter);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->iter));
  __pyx_v_self->iter = ((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *)__pyx_t_4);
  __pyx_t_4 = 0;

  /* "pysam/calignmentfile.pyx":2187
 * 
 *         self.iter = IteratorRowRegion(self.samfile, tid, start, end, multiple_iterators)
 *         self.iterdata.htsfile = self.samfile.htsfile             # <<<<<<<<<<<<<<
 *         self.iterdata.iter = self.iter.iter
 *         self.iterdata.seq = NULL
 */
  __pyx_t_6 = __pyx_v_self->samfile->htsfile;
  __pyx_v_self->iterdata.htsfile = __pyx_t_6;

  /* "pysam/calignmentfile.pyx":2188
 *         self.iter = IteratorRowRegion(self.samfile, tid, start, end, multiple_iterators)
 *         self.iterdata.htsfile = self.samfile.htsfile
 *         self.iterdata.iter = self.iter.iter             # <<<<<<<<<<<<<<
 *         self.iterdata.seq = NULL
 *         self.iterdata.tid = -1
 */
  __pyx_t_7 = __pyx_v_self->iter->iter;
  __pyx_v_self->iterdata.iter = __pyx_t_7;

  /* "pysam/calignmentfile.pyx":2189
 *         self.iterdata.htsfile = self.samfile.htsfile
 *         self.iterdata.iter = self.iter.iter
 *         self.iterdata.seq = NULL             # <<<<<<<<<<<<<<
 *         self.iterdata.tid = -1
 *         self.iterdata.header = self.samfile.header
 */
  __pyx_v_self->iterdata.seq = NULL;

  /* "pysam/calignmentfile.pyx":2190
 *         self.iterdata.iter = self.iter.iter
 *         self.iterdata.seq = NULL
 *         self.iterdata.tid = -1             # <<<<<<<<<<<<<<
 *         self.iterdata.header = self.samfile.header
 * 
 */
  __pyx_v_self->iterdata.tid = -1;

  /* "pysam/calignmentfile.pyx":2191
 *         self.iterdata.seq = NULL
 *         self.iterdata.tid = -1
 *         self.iterdata.header = self.samfile.header             # <<<<<<<<<<<<<<
 * 
 *         if self.fastafile is not None:
 */
  __pyx_t_8 = __pyx_v_self->samfile->header;
  __pyx_v_self->iterdata.header = __pyx_t_8;

  /* "pysam/calignmentfile.pyx":2193
 *         self.iterdata.header = self.samfile.header
 * 
 *         if self.fastafile is not None:             # <<<<<<<<<<<<<<
 *             self.iterdata.fastafile = self.fastafile.fastafile
 *         else:
 */
  __pyx_t_9 = (((PyObject *)__pyx_v_self->fastafile) != Py_None);
  __pyx_t_10 = (__pyx_t_9 != 0);
  if (__pyx_t_10) {

    /* "pysam/calignmentfile.pyx":2194
 * 
 *         if self.fastafile is not None:
 *             self.iterdata.fastafile = self.fastafile.fastafile             # <<<<<<<<<<<<<<
 *         else:
 *             self.iterdata.fastafile = NULL
 */
    __pyx_t_11 = __pyx_v_self->fastafile->__pyx_base.fastafile;
    __pyx_v_self->iterdata.fastafile = __pyx_t_11;

    /* "pysam/calignmentfile.pyx":2193
 *         self.iterdata.header = self.samfile.header
 * 
 *         if self.fastafile is not None:             # <<<<<<<<<<<<<<
 *             self.iterdata.fastafile = self.fastafile.fastafile
 *         else:
 */
    goto __pyx_L3;
  }

  /* "pysam/calignmentfile.pyx":2196
 *             self.iterdata.fastafile = self.fastafile.fastafile
 *         else:
 *             self.iterdata.fastafile = NULL             # <<<<<<<<<<<<<<
 * 
 *         # Free any previously allocated memory before reassigning
 */
  /*else*/ {
    __pyx_v_self->iterdata.fastafile = NULL;
  }
  __pyx_L3:;

  /* "pysam/calignmentfile.pyx":2200
 *         # Free any previously allocated memory before reassigning
 *         # pileup_iter
 *         self._free_pileup_iter()             # <<<<<<<<<<<<<<
 * 
 *         if self.stepper is None or self.stepper == "all":
 */
  __pyx_t_4 = ((struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorColumn *)__pyx_v_self->__pyx_vtab)->_free_pileup_iter(__pyx_v_self); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2200, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

  /* "pysam/calignmentfile.pyx":2202
 *         self._free_pileup_iter()
 * 
 *         if self.stepper is None or self.stepper == "all":             # <<<<<<<<<<<<<<
 *             with nogil:
 *                 self.pileup_iter = bam_plp_init(
 */
  __pyx_t_9 = (__pyx_v_self->stepper == Py_None);
  __pyx_t_12 = (__pyx_t_9 != 0);
  if (!__pyx_t_12) {
  } else {
    __pyx_t_10 = __pyx_t_12;
    goto __pyx_L5_bool_binop_done;
  }
  __pyx_t_12 = (__Pyx_PyString_Equals(__pyx_v_self->stepper, __pyx_n_s_all, Py_EQ)); if (unlikely(__pyx_t_12 < 0)) __PYX_ERR(0, 2202, __pyx_L1_error)
  __pyx_t_10 = __pyx_t_12;
  __pyx_L5_bool_binop_done:;
  if (__pyx_t_10) {

    /* "pysam/calignmentfile.pyx":2203
 * 
 *         if self.stepper is None or self.stepper == "all":
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 self.pileup_iter = bam_plp_init(
 *                     <bam_plp_auto_f>&__advance_all,
 */
    {
        #ifdef WITH_THREAD
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
        #endif
        /*try:*/ {

          /* "pysam/calignmentfile.pyx":2204
 *         if self.stepper is None or self.stepper == "all":
 *             with nogil:
 *                 self.pileup_iter = bam_plp_init(             # <<<<<<<<<<<<<<
 *                     <bam_plp_auto_f>&__advance_all,
 *                     &self.iterdata)
 */
          __pyx_v_self->pileup_iter = bam_plp_init(((bam_plp_auto_f)(&__pyx_f_5pysam_14calignmentfile___advance_all)), (&__pyx_v_self->iterdata));
        }

        /* "pysam/calignmentfile.pyx":2203
 * 
 *         if self.stepper is None or self.stepper == "all":
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 self.pileup_iter = bam_plp_init(
 *                     <bam_plp_auto_f>&__advance_all,
 */
        /*finally:*/ {
          /*normal exit:*/{
            #ifdef WITH_THREAD
            Py_BLOCK_THREADS
            #endif
            goto __pyx_L9;
          }
          __pyx_L9:;
        }
    }

    /* "pysam/calignmentfile.pyx":2202
 *         self._free_pileup_iter()
 * 
 *         if self.stepper is None or self.stepper == "all":             # <<<<<<<<<<<<<<
 *             with nogil:
 *                 self.pileup_iter = bam_plp_init(
 */
    goto __pyx_L4;
  }

  /* "pysam/calignmentfile.pyx":2207
 *                     <bam_plp_auto_f>&__advance_all,
 *                     &self.iterdata)
 *         elif self.stepper == "nofilter":             # <<<<<<<<<<<<<<
 *             with nogil:
 *                 self.pileup_iter = bam_plp_init(
 */
  __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_v_self->stepper, __pyx_n_s_nofilter, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 2207, __pyx_L1_error)
  if (__pyx_t_10) {

    /* "pysam/calignmentfile.pyx":2208
 *                     &self.iterdata)
 *         elif self.stepper == "nofilter":
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 self.pileup_iter = bam_plp_init(
 *                     <bam_plp_auto_f>&__advance_nofilter,
 */
    {
        #ifdef WITH_THREAD
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
        #endif
        /*try:*/ {

          /* "pysam/calignmentfile.pyx":2209
 *         elif self.stepper == "nofilter":
 *             with nogil:
 *                 self.pileup_iter = bam_plp_init(             # <<<<<<<<<<<<<<
 *                     <bam_plp_auto_f>&__advance_nofilter,
 *                     &self.iterdata)
 */
          __pyx_v_self->pileup_iter = bam_plp_init(((bam_plp_auto_f)(&__pyx_f_5pysam_14calignmentfile___advance_nofilter)), (&__pyx_v_self->iterdata));
        }

        /* "pysam/calignmentfile.pyx":2208
 *                     &self.iterdata)
 *         elif self.stepper == "nofilter":
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 self.pileup_iter = bam_plp_init(
 *                     <bam_plp_auto_f>&__advance_nofilter,
 */
        /*finally:*/ {
          /*normal exit:*/{
            #ifdef WITH_THREAD
            Py_BLOCK_THREADS
            #endif
            goto __pyx_L12;
          }
          __pyx_L12:;
        }
    }

    /* "pysam/calignmentfile.pyx":2207
 *                     <bam_plp_auto_f>&__advance_all,
 *                     &self.iterdata)
 *         elif self.stepper == "nofilter":             # <<<<<<<<<<<<<<
 *             with nogil:
 *                 self.pileup_iter = bam_plp_init(
 */
    goto __pyx_L4;
  }

  /* "pysam/calignmentfile.pyx":2212
 *                     <bam_plp_auto_f>&__advance_nofilter,
 *                     &self.iterdata)
 *         elif self.stepper == "samtools":             # <<<<<<<<<<<<<<
 *             with nogil:
 *                 self.pileup_iter = bam_plp_init(
 */
  __pyx_t_10 = (__Pyx_PyString_Equals(__pyx_v_self->stepper, __pyx_n_s_samtools, Py_EQ)); if (unlikely(__pyx_t_10 < 0)) __PYX_ERR(0, 2212, __pyx_L1_error)
  if (__pyx_t_10) {

    /* "pysam/calignmentfile.pyx":2213
 *                     &self.iterdata)
 *         elif self.stepper == "samtools":
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 self.pileup_iter = bam_plp_init(
 *                     <bam_plp_auto_f>&__advance_snpcalls,
 */
    {
        #ifdef WITH_THREAD
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
        #endif
        /*try:*/ {

          /* "pysam/calignmentfile.pyx":2214
 *         elif self.stepper == "samtools":
 *             with nogil:
 *                 self.pileup_iter = bam_plp_init(             # <<<<<<<<<<<<<<
 *                     <bam_plp_auto_f>&__advance_snpcalls,
 *                     &self.iterdata)
 */
          __pyx_v_self->pileup_iter = bam_plp_init(((bam_plp_auto_f)(&__pyx_f_5pysam_14calignmentfile___advance_snpcalls)), (&__pyx_v_self->iterdata));
        }

        /* "pysam/calignmentfile.pyx":2213
 *                     &self.iterdata)
 *         elif self.stepper == "samtools":
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 self.pileup_iter = bam_plp_init(
 *                     <bam_plp_auto_f>&__advance_snpcalls,
 */
        /*finally:*/ {
          /*normal exit:*/{
            #ifdef WITH_THREAD
            Py_BLOCK_THREADS
            #endif
            goto __pyx_L15;
          }
          __pyx_L15:;
        }
    }

    /* "pysam/calignmentfile.pyx":2212
 *                     <bam_plp_auto_f>&__advance_nofilter,
 *                     &self.iterdata)
 *         elif self.stepper == "samtools":             # <<<<<<<<<<<<<<
 *             with nogil:
 *                 self.pileup_iter = bam_plp_init(
 */
    goto __pyx_L4;
  }

  /* "pysam/calignmentfile.pyx":2218
 *                     &self.iterdata)
 *         else:
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 "unknown stepper option `%s` in IteratorColumn" % self.stepper)
 * 
 */
  /*else*/ {

    /* "pysam/calignmentfile.pyx":2219
 *         else:
 *             raise ValueError(
 *                 "unknown stepper option `%s` in IteratorColumn" % self.stepper)             # <<<<<<<<<<<<<<
 * 
 *         if self.max_depth:
 */
    __pyx_t_4 = __Pyx_PyString_Format(__pyx_kp_s_unknown_stepper_option_s_in_Iter, __pyx_v_self->stepper); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2219, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);

    /* "pysam/calignmentfile.pyx":2218
 *                     &self.iterdata)
 *         else:
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 "unknown stepper option `%s` in IteratorColumn" % self.stepper)
 * 
 */
    __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2218, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_GIVEREF(__pyx_t_4);
    PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
    __pyx_t_4 = 0;
    __pyx_t_4 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_t_5, NULL); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2218, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __PYX_ERR(0, 2218, __pyx_L1_error)
  }
  __pyx_L4:;

  /* "pysam/calignmentfile.pyx":2221
 *                 "unknown stepper option `%s` in IteratorColumn" % self.stepper)
 * 
 *         if self.max_depth:             # <<<<<<<<<<<<<<
 *             with nogil:
 *                 bam_plp_set_maxcnt(self.pileup_iter, self.max_depth)
 */
  __pyx_t_10 = (__pyx_v_self->max_depth != 0);
  if (__pyx_t_10) {

    /* "pysam/calignmentfile.pyx":2222
 * 
 *         if self.max_depth:
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 bam_plp_set_maxcnt(self.pileup_iter, self.max_depth)
 * 
 */
    {
        #ifdef WITH_THREAD
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
        #endif
        /*try:*/ {

          /* "pysam/calignmentfile.pyx":2223
 *         if self.max_depth:
 *             with nogil:
 *                 bam_plp_set_maxcnt(self.pileup_iter, self.max_depth)             # <<<<<<<<<<<<<<
 * 
 *         # bam_plp_set_mask( self.pileup_iter, self.mask )
 */
          bam_plp_set_maxcnt(__pyx_v_self->pileup_iter, __pyx_v_self->max_depth);
        }

        /* "pysam/calignmentfile.pyx":2222
 * 
 *         if self.max_depth:
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 bam_plp_set_maxcnt(self.pileup_iter, self.max_depth)
 * 
 */
        /*finally:*/ {
          /*normal exit:*/{
            #ifdef WITH_THREAD
            Py_BLOCK_THREADS
            #endif
            goto __pyx_L19;
          }
          __pyx_L19:;
        }
    }

    /* "pysam/calignmentfile.pyx":2221
 *                 "unknown stepper option `%s` in IteratorColumn" % self.stepper)
 * 
 *         if self.max_depth:             # <<<<<<<<<<<<<<
 *             with nogil:
 *                 bam_plp_set_maxcnt(self.pileup_iter, self.max_depth)
 */
  }

  /* "pysam/calignmentfile.pyx":2179
 *         # bam_plp_set_mask( self.pileup_iter, self.mask )
 * 
 *     cdef setupIteratorData( self,             # <<<<<<<<<<<<<<
 *                             int tid,
 *                             int start,
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorColumn.setupIteratorData", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2227
 *         # bam_plp_set_mask( self.pileup_iter, self.mask )
 * 
 *     cdef reset( self, tid, start, end ):             # <<<<<<<<<<<<<<
 *         '''reset iterator position.
 * 
 */

static PyObject *__pyx_f_5pysam_14calignmentfile_14IteratorColumn_reset(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self, PyObject *__pyx_v_tid, PyObject *__pyx_v_start, PyObject *__pyx_v_end) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  hts_itr_t *__pyx_t_4;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("reset", 0);
  __Pyx_TraceCall("reset", __pyx_f[0], 2227, 0, __PYX_ERR(0, 2227, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2233
 *         having to incur the full set-up costs.
 *         '''
 *         self.iter = IteratorRowRegion( self.samfile, tid, start, end, multiple_iterators = 0 )             # <<<<<<<<<<<<<<
 *         self.iterdata.iter = self.iter.iter
 * 
 */
  __pyx_t_1 = PyTuple_New(4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2233, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_INCREF(((PyObject *)__pyx_v_self->samfile));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_self->samfile));
  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)__pyx_v_self->samfile));
  __Pyx_INCREF(__pyx_v_tid);
  __Pyx_GIVEREF(__pyx_v_tid);
  PyTuple_SET_ITEM(__pyx_t_1, 1, __pyx_v_tid);
  __Pyx_INCREF(__pyx_v_start);
  __Pyx_GIVEREF(__pyx_v_start);
  PyTuple_SET_ITEM(__pyx_t_1, 2, __pyx_v_start);
  __Pyx_INCREF(__pyx_v_end);
  __Pyx_GIVEREF(__pyx_v_end);
  PyTuple_SET_ITEM(__pyx_t_1, 3, __pyx_v_end);
  __pyx_t_2 = PyDict_New(); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2233, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  if (PyDict_SetItem(__pyx_t_2, __pyx_n_s_multiple_iterators, __pyx_int_0) < 0) __PYX_ERR(0, 2233, __pyx_L1_error)
  __pyx_t_3 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_5pysam_14calignmentfile_IteratorRowRegion), __pyx_t_1, __pyx_t_2); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2233, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __Pyx_GIVEREF(__pyx_t_3);
  __Pyx_GOTREF(__pyx_v_self->iter);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->iter));
  __pyx_v_self->iter = ((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *)__pyx_t_3);
  __pyx_t_3 = 0;

  /* "pysam/calignmentfile.pyx":2234
 *         '''
 *         self.iter = IteratorRowRegion( self.samfile, tid, start, end, multiple_iterators = 0 )
 *         self.iterdata.iter = self.iter.iter             # <<<<<<<<<<<<<<
 * 
 *         # invalidate sequence if different tid
 */
  __pyx_t_4 = __pyx_v_self->iter->iter;
  __pyx_v_self->iterdata.iter = __pyx_t_4;

  /* "pysam/calignmentfile.pyx":2237
 * 
 *         # invalidate sequence if different tid
 *         if self.tid != tid:             # <<<<<<<<<<<<<<
 *             if self.iterdata.seq != NULL:
 *                 free(self.iterdata.seq)
 */
  __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_self->tid); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2237, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyObject_RichCompare(__pyx_t_3, __pyx_v_tid, Py_NE); __Pyx_XGOTREF(__pyx_t_2); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2237, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely(__pyx_t_5 < 0)) __PYX_ERR(0, 2237, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (__pyx_t_5) {

    /* "pysam/calignmentfile.pyx":2238
 *         # invalidate sequence if different tid
 *         if self.tid != tid:
 *             if self.iterdata.seq != NULL:             # <<<<<<<<<<<<<<
 *                 free(self.iterdata.seq)
 *             self.iterdata.seq = NULL
 */
    __pyx_t_5 = ((__pyx_v_self->iterdata.seq != NULL) != 0);
    if (__pyx_t_5) {

      /* "pysam/calignmentfile.pyx":2239
 *         if self.tid != tid:
 *             if self.iterdata.seq != NULL:
 *                 free(self.iterdata.seq)             # <<<<<<<<<<<<<<
 *             self.iterdata.seq = NULL
 *             self.iterdata.tid = -1
 */
      free(__pyx_v_self->iterdata.seq);

      /* "pysam/calignmentfile.pyx":2238
 *         # invalidate sequence if different tid
 *         if self.tid != tid:
 *             if self.iterdata.seq != NULL:             # <<<<<<<<<<<<<<
 *                 free(self.iterdata.seq)
 *             self.iterdata.seq = NULL
 */
    }

    /* "pysam/calignmentfile.pyx":2240
 *             if self.iterdata.seq != NULL:
 *                 free(self.iterdata.seq)
 *             self.iterdata.seq = NULL             # <<<<<<<<<<<<<<
 *             self.iterdata.tid = -1
 * 
 */
    __pyx_v_self->iterdata.seq = NULL;

    /* "pysam/calignmentfile.pyx":2241
 *                 free(self.iterdata.seq)
 *             self.iterdata.seq = NULL
 *             self.iterdata.tid = -1             # <<<<<<<<<<<<<<
 * 
 *         # self.pileup_iter = bam_plp_init( &__advancepileup, &self.iterdata )
 */
    __pyx_v_self->iterdata.tid = -1;

    /* "pysam/calignmentfile.pyx":2237
 * 
 *         # invalidate sequence if different tid
 *         if self.tid != tid:             # <<<<<<<<<<<<<<
 *             if self.iterdata.seq != NULL:
 *                 free(self.iterdata.seq)
 */
  }

  /* "pysam/calignmentfile.pyx":2244
 * 
 *         # self.pileup_iter = bam_plp_init( &__advancepileup, &self.iterdata )
 *         with nogil:             # <<<<<<<<<<<<<<
 *             bam_plp_reset(self.pileup_iter)
 * 
 */
  {
      #ifdef WITH_THREAD
      PyThreadState *_save;
      Py_UNBLOCK_THREADS
      #endif
      /*try:*/ {

        /* "pysam/calignmentfile.pyx":2245
 *         # self.pileup_iter = bam_plp_init( &__advancepileup, &self.iterdata )
 *         with nogil:
 *             bam_plp_reset(self.pileup_iter)             # <<<<<<<<<<<<<<
 * 
 *     cdef _free_pileup_iter(self):
 */
        bam_plp_reset(__pyx_v_self->pileup_iter);
      }

      /* "pysam/calignmentfile.pyx":2244
 * 
 *         # self.pileup_iter = bam_plp_init( &__advancepileup, &self.iterdata )
 *         with nogil:             # <<<<<<<<<<<<<<
 *             bam_plp_reset(self.pileup_iter)
 * 
 */
      /*finally:*/ {
        /*normal exit:*/{
          #ifdef WITH_THREAD
          Py_BLOCK_THREADS
          #endif
          goto __pyx_L7;
        }
        __pyx_L7:;
      }
  }

  /* "pysam/calignmentfile.pyx":2227
 *         # bam_plp_set_mask( self.pileup_iter, self.mask )
 * 
 *     cdef reset( self, tid, start, end ):             # <<<<<<<<<<<<<<
 *         '''reset iterator position.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorColumn.reset", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2247
 *             bam_plp_reset(self.pileup_iter)
 * 
 *     cdef _free_pileup_iter(self):             # <<<<<<<<<<<<<<
 *         '''free the memory alloc'd by bam_plp_init.
 * 
 */

static PyObject *__pyx_f_5pysam_14calignmentfile_14IteratorColumn__free_pileup_iter(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("_free_pileup_iter", 0);
  __Pyx_TraceCall("_free_pileup_iter", __pyx_f[0], 2247, 0, __PYX_ERR(0, 2247, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2253
 *         another pileup_iter, or else memory will be lost.
 *         '''
 *         if self.pileup_iter != <bam_plp_t>NULL:             # <<<<<<<<<<<<<<
 *             with nogil:
 *                 bam_plp_reset(self.pileup_iter)
 */
  __pyx_t_1 = ((__pyx_v_self->pileup_iter != ((bam_plp_t)NULL)) != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":2254
 *         '''
 *         if self.pileup_iter != <bam_plp_t>NULL:
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 bam_plp_reset(self.pileup_iter)
 *                 bam_plp_destroy(self.pileup_iter)
 */
    {
        #ifdef WITH_THREAD
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
        #endif
        /*try:*/ {

          /* "pysam/calignmentfile.pyx":2255
 *         if self.pileup_iter != <bam_plp_t>NULL:
 *             with nogil:
 *                 bam_plp_reset(self.pileup_iter)             # <<<<<<<<<<<<<<
 *                 bam_plp_destroy(self.pileup_iter)
 *                 self.pileup_iter = <bam_plp_t>NULL
 */
          bam_plp_reset(__pyx_v_self->pileup_iter);

          /* "pysam/calignmentfile.pyx":2256
 *             with nogil:
 *                 bam_plp_reset(self.pileup_iter)
 *                 bam_plp_destroy(self.pileup_iter)             # <<<<<<<<<<<<<<
 *                 self.pileup_iter = <bam_plp_t>NULL
 * 
 */
          bam_plp_destroy(__pyx_v_self->pileup_iter);

          /* "pysam/calignmentfile.pyx":2257
 *                 bam_plp_reset(self.pileup_iter)
 *                 bam_plp_destroy(self.pileup_iter)
 *                 self.pileup_iter = <bam_plp_t>NULL             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
          __pyx_v_self->pileup_iter = ((bam_plp_t)NULL);
        }

        /* "pysam/calignmentfile.pyx":2254
 *         '''
 *         if self.pileup_iter != <bam_plp_t>NULL:
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 bam_plp_reset(self.pileup_iter)
 *                 bam_plp_destroy(self.pileup_iter)
 */
        /*finally:*/ {
          /*normal exit:*/{
            #ifdef WITH_THREAD
            Py_BLOCK_THREADS
            #endif
            goto __pyx_L6;
          }
          __pyx_L6:;
        }
    }

    /* "pysam/calignmentfile.pyx":2253
 *         another pileup_iter, or else memory will be lost.
 *         '''
 *         if self.pileup_iter != <bam_plp_t>NULL:             # <<<<<<<<<<<<<<
 *             with nogil:
 *                 bam_plp_reset(self.pileup_iter)
 */
  }

  /* "pysam/calignmentfile.pyx":2247
 *             bam_plp_reset(self.pileup_iter)
 * 
 *     cdef _free_pileup_iter(self):             # <<<<<<<<<<<<<<
 *         '''free the memory alloc'd by bam_plp_init.
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorColumn._free_pileup_iter", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2259
 *                 self.pileup_iter = <bam_plp_t>NULL
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         # reset in order to avoid memory leak messages for iterators
 *         # that have not been fully consumed
 */

/* Python wrapper */
static void __pyx_pw_5pysam_14calignmentfile_14IteratorColumn_9__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_5pysam_14calignmentfile_14IteratorColumn_9__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_5pysam_14calignmentfile_14IteratorColumn_8__dealloc__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_5pysam_14calignmentfile_14IteratorColumn_8__dealloc__(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *__pyx_v_self) {
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("__dealloc__", 0);
  __Pyx_TraceCall("__dealloc__", __pyx_f[0], 2259, 0, __PYX_ERR(0, 2259, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2262
 *         # reset in order to avoid memory leak messages for iterators
 *         # that have not been fully consumed
 *         self._free_pileup_iter()             # <<<<<<<<<<<<<<
 *         self.plp = <bam_pileup1_t*>NULL
 * 
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorColumn *)__pyx_v_self->__pyx_vtab)->_free_pileup_iter(__pyx_v_self); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2262, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pysam/calignmentfile.pyx":2263
 *         # that have not been fully consumed
 *         self._free_pileup_iter()
 *         self.plp = <bam_pileup1_t*>NULL             # <<<<<<<<<<<<<<
 * 
 *         if self.iterdata.seq != NULL:
 */
  __pyx_v_self->plp = ((bam_pileup1_t *)NULL);

  /* "pysam/calignmentfile.pyx":2265
 *         self.plp = <bam_pileup1_t*>NULL
 * 
 *         if self.iterdata.seq != NULL:             # <<<<<<<<<<<<<<
 *             free(self.iterdata.seq)
 *             self.iterdata.seq = NULL
 */
  __pyx_t_2 = ((__pyx_v_self->iterdata.seq != NULL) != 0);
  if (__pyx_t_2) {

    /* "pysam/calignmentfile.pyx":2266
 * 
 *         if self.iterdata.seq != NULL:
 *             free(self.iterdata.seq)             # <<<<<<<<<<<<<<
 *             self.iterdata.seq = NULL
 * 
 */
    free(__pyx_v_self->iterdata.seq);

    /* "pysam/calignmentfile.pyx":2267
 *         if self.iterdata.seq != NULL:
 *             free(self.iterdata.seq)
 *             self.iterdata.seq = NULL             # <<<<<<<<<<<<<<
 * 
 * 
 */
    __pyx_v_self->iterdata.seq = NULL;

    /* "pysam/calignmentfile.pyx":2265
 *         self.plp = <bam_pileup1_t*>NULL
 * 
 *         if self.iterdata.seq != NULL:             # <<<<<<<<<<<<<<
 *             free(self.iterdata.seq)
 *             self.iterdata.seq = NULL
 */
  }

  /* "pysam/calignmentfile.pyx":2259
 *                 self.pileup_iter = <bam_plp_t>NULL
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         # reset in order to avoid memory leak messages for iterators
 *         # that have not been fully consumed
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_WriteUnraisable("pysam.calignmentfile.IteratorColumn.__dealloc__", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
}

/* "pysam/calignmentfile.pyx":2273
 *     '''iterates over a region only.
 *     '''
 *     def __cinit__(self, AlignmentFile samfile,             # <<<<<<<<<<<<<<
 *                   int tid = 0,
 *                   int start = 0,
 */

/* Python wrapper */
static int __pyx_pw_5pysam_14calignmentfile_20IteratorColumnRegion_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_5pysam_14calignmentfile_20IteratorColumnRegion_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  CYTHON_UNUSED struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile = 0;
  int __pyx_v_tid;
  int __pyx_v_start;
  int __pyx_v_end;
  int __pyx_v_truncate;
  CYTHON_UNUSED PyObject *__pyx_v_kwargs = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return -1;
  __Pyx_GOTREF(__pyx_v_kwargs);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_samfile,&__pyx_n_s_tid,&__pyx_n_s_start,&__pyx_n_s_end,&__pyx_n_s_truncate,0};
    PyObject* values[5] = {0,0,0,0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_samfile)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_tid);
          if (value) { values[1] = value; kw_args--; }
        }
        case  2:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_start);
          if (value) { values[2] = value; kw_args--; }
        }
        case  3:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_end);
          if (value) { values[3] = value; kw_args--; }
        }
        case  4:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_truncate);
          if (value) { values[4] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 2273, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
        case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
        case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_samfile = ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)values[0]);
    if (values[1]) {
      __pyx_v_tid = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_tid == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 2274, __pyx_L3_error)
    } else {
      __pyx_v_tid = ((int)0);
    }
    if (values[2]) {
      __pyx_v_start = __Pyx_PyInt_As_int(values[2]); if (unlikely((__pyx_v_start == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 2275, __pyx_L3_error)
    } else {
      __pyx_v_start = ((int)0);
    }
    if (values[3]) {
      __pyx_v_end = __Pyx_PyInt_As_int(values[3]); if (unlikely((__pyx_v_end == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 2276, __pyx_L3_error)
    } else {
      __pyx_v_end = __pyx_k__64;
    }
    if (values[4]) {
      __pyx_v_truncate = __Pyx_PyInt_As_int(values[4]); if (unlikely((__pyx_v_truncate == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 2277, __pyx_L3_error)
    } else {

      /* "pysam/calignmentfile.pyx":2277
 *                   int start = 0,
 *                   int end = MAX_POS,
 *                   int truncate = False,             # <<<<<<<<<<<<<<
 *                   **kwargs ):
 * 
 */
      __pyx_v_truncate = ((int)0);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 1, 5, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2273, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorColumnRegion.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_samfile), __pyx_ptype_5pysam_14calignmentfile_AlignmentFile, 1, "samfile", 0))) __PYX_ERR(0, 2273, __pyx_L1_error)
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_20IteratorColumnRegion___cinit__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnRegion *)__pyx_v_self), __pyx_v_samfile, __pyx_v_tid, __pyx_v_start, __pyx_v_end, __pyx_v_truncate, __pyx_v_kwargs);

  /* "pysam/calignmentfile.pyx":2273
 *     '''iterates over a region only.
 *     '''
 *     def __cinit__(self, AlignmentFile samfile,             # <<<<<<<<<<<<<<
 *                   int tid = 0,
 *                   int start = 0,
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_kwargs);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_5pysam_14calignmentfile_20IteratorColumnRegion___cinit__(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnRegion *__pyx_v_self, CYTHON_UNUSED struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile, int __pyx_v_tid, int __pyx_v_start, int __pyx_v_end, int __pyx_v_truncate, CYTHON_UNUSED PyObject *__pyx_v_kwargs) {
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  struct __pyx_opt_args_5pysam_14calignmentfile_14IteratorColumn_setupIteratorData __pyx_t_2;
  __Pyx_RefNannySetupContext("__cinit__", 0);
  __Pyx_TraceCall("__cinit__", __pyx_f[0], 2273, 0, __PYX_ERR(0, 2273, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2281
 * 
 *         # initialize iterator
 *         self.setupIteratorData(tid, start, end, 1)             # <<<<<<<<<<<<<<
 *         self.start = start
 *         self.end = end
 */
  __pyx_t_2.__pyx_n = 1;
  __pyx_t_2.multiple_iterators = 1;
  __pyx_t_1 = ((struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorColumnRegion *)__pyx_v_self->__pyx_base.__pyx_vtab)->__pyx_base.setupIteratorData(((struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *)__pyx_v_self), __pyx_v_tid, __pyx_v_start, __pyx_v_end, &__pyx_t_2); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2281, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pysam/calignmentfile.pyx":2282
 *         # initialize iterator
 *         self.setupIteratorData(tid, start, end, 1)
 *         self.start = start             # <<<<<<<<<<<<<<
 *         self.end = end
 *         self.truncate = truncate
 */
  __pyx_v_self->start = __pyx_v_start;

  /* "pysam/calignmentfile.pyx":2283
 *         self.setupIteratorData(tid, start, end, 1)
 *         self.start = start
 *         self.end = end             # <<<<<<<<<<<<<<
 *         self.truncate = truncate
 * 
 */
  __pyx_v_self->end = __pyx_v_end;

  /* "pysam/calignmentfile.pyx":2284
 *         self.start = start
 *         self.end = end
 *         self.truncate = truncate             # <<<<<<<<<<<<<<
 * 
 *     def __next__(self):
 */
  __pyx_v_self->truncate = __pyx_v_truncate;

  /* "pysam/calignmentfile.pyx":2273
 *     '''iterates over a region only.
 *     '''
 *     def __cinit__(self, AlignmentFile samfile,             # <<<<<<<<<<<<<<
 *                   int tid = 0,
 *                   int start = 0,
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorColumnRegion.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2286
 *         self.truncate = truncate
 * 
 *     def __next__(self):             # <<<<<<<<<<<<<<
 * 
 *         while 1:
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_20IteratorColumnRegion_3__next__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_20IteratorColumnRegion_3__next__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__next__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_20IteratorColumnRegion_2__next__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnRegion *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_20IteratorColumnRegion_2__next__(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnRegion *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("__next__", 0);
  __Pyx_TraceCall("__next__", __pyx_f[0], 2286, 0, __PYX_ERR(0, 2286, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2288
 *     def __next__(self):
 * 
 *         while 1:             # <<<<<<<<<<<<<<
 *             self.cnext()
 *             if self.n_plp < 0:
 */
  while (1) {

    /* "pysam/calignmentfile.pyx":2289
 * 
 *         while 1:
 *             self.cnext()             # <<<<<<<<<<<<<<
 *             if self.n_plp < 0:
 *                 raise ValueError("error during iteration" )
 */
    ((struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorColumnRegion *)__pyx_v_self->__pyx_base.__pyx_vtab)->__pyx_base.cnext(((struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *)__pyx_v_self));

    /* "pysam/calignmentfile.pyx":2290
 *         while 1:
 *             self.cnext()
 *             if self.n_plp < 0:             # <<<<<<<<<<<<<<
 *                 raise ValueError("error during iteration" )
 * 
 */
    __pyx_t_1 = ((__pyx_v_self->__pyx_base.n_plp < 0) != 0);
    if (__pyx_t_1) {

      /* "pysam/calignmentfile.pyx":2291
 *             self.cnext()
 *             if self.n_plp < 0:
 *                 raise ValueError("error during iteration" )             # <<<<<<<<<<<<<<
 * 
 *             if self.plp == NULL:
 */
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__65, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2291, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_Raise(__pyx_t_2, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __PYX_ERR(0, 2291, __pyx_L1_error)

      /* "pysam/calignmentfile.pyx":2290
 *         while 1:
 *             self.cnext()
 *             if self.n_plp < 0:             # <<<<<<<<<<<<<<
 *                 raise ValueError("error during iteration" )
 * 
 */
    }

    /* "pysam/calignmentfile.pyx":2293
 *                 raise ValueError("error during iteration" )
 * 
 *             if self.plp == NULL:             # <<<<<<<<<<<<<<
 *                 raise StopIteration
 * 
 */
    __pyx_t_1 = ((__pyx_v_self->__pyx_base.plp == NULL) != 0);
    if (__pyx_t_1) {

      /* "pysam/calignmentfile.pyx":2294
 * 
 *             if self.plp == NULL:
 *                 raise StopIteration             # <<<<<<<<<<<<<<
 * 
 *             if self.truncate:
 */
      __Pyx_Raise(__pyx_builtin_StopIteration, 0, 0, 0);
      __PYX_ERR(0, 2294, __pyx_L1_error)

      /* "pysam/calignmentfile.pyx":2293
 *                 raise ValueError("error during iteration" )
 * 
 *             if self.plp == NULL:             # <<<<<<<<<<<<<<
 *                 raise StopIteration
 * 
 */
    }

    /* "pysam/calignmentfile.pyx":2296
 *                 raise StopIteration
 * 
 *             if self.truncate:             # <<<<<<<<<<<<<<
 *                 if self.start > self.pos: continue
 *                 if self.pos >= self.end: raise StopIteration
 */
    __pyx_t_1 = (__pyx_v_self->truncate != 0);
    if (__pyx_t_1) {

      /* "pysam/calignmentfile.pyx":2297
 * 
 *             if self.truncate:
 *                 if self.start > self.pos: continue             # <<<<<<<<<<<<<<
 *                 if self.pos >= self.end: raise StopIteration
 * 
 */
      __pyx_t_1 = ((__pyx_v_self->start > __pyx_v_self->__pyx_base.pos) != 0);
      if (__pyx_t_1) {
        goto __pyx_L3_continue;
      }

      /* "pysam/calignmentfile.pyx":2298
 *             if self.truncate:
 *                 if self.start > self.pos: continue
 *                 if self.pos >= self.end: raise StopIteration             # <<<<<<<<<<<<<<
 * 
 *             return makePileupColumn(&self.plp,
 */
      __pyx_t_1 = ((__pyx_v_self->__pyx_base.pos >= __pyx_v_self->end) != 0);
      if (__pyx_t_1) {
        __Pyx_Raise(__pyx_builtin_StopIteration, 0, 0, 0);
        __PYX_ERR(0, 2298, __pyx_L1_error)
      }

      /* "pysam/calignmentfile.pyx":2296
 *                 raise StopIteration
 * 
 *             if self.truncate:             # <<<<<<<<<<<<<<
 *                 if self.start > self.pos: continue
 *                 if self.pos >= self.end: raise StopIteration
 */
    }

    /* "pysam/calignmentfile.pyx":2300
 *                 if self.pos >= self.end: raise StopIteration
 * 
 *             return makePileupColumn(&self.plp,             # <<<<<<<<<<<<<<
 *                                    self.tid,
 *                                    self.pos,
 */
    __Pyx_XDECREF(__pyx_r);

    /* "pysam/calignmentfile.pyx":2304
 *                                    self.pos,
 *                                    self.n_plp,
 *                                    self.samfile)             # <<<<<<<<<<<<<<
 * 
 * 
 */
    __pyx_t_2 = ((PyObject *)__pyx_v_self->__pyx_base.samfile);
    __Pyx_INCREF(__pyx_t_2);

    /* "pysam/calignmentfile.pyx":2300
 *                 if self.pos >= self.end: raise StopIteration
 * 
 *             return makePileupColumn(&self.plp,             # <<<<<<<<<<<<<<
 *                                    self.tid,
 *                                    self.pos,
 */
    __pyx_t_3 = __pyx_f_5pysam_15calignedsegment_makePileupColumn((&__pyx_v_self->__pyx_base.plp), __pyx_v_self->__pyx_base.tid, __pyx_v_self->__pyx_base.pos, __pyx_v_self->__pyx_base.n_plp, ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2300, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_r = __pyx_t_3;
    __pyx_t_3 = 0;
    goto __pyx_L0;
    __pyx_L3_continue:;
  }

  /* "pysam/calignmentfile.pyx":2286
 *         self.truncate = truncate
 * 
 *     def __next__(self):             # <<<<<<<<<<<<<<
 * 
 *         while 1:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorColumnRegion.__next__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2311
 *     """
 * 
 *     def __cinit__(self,             # <<<<<<<<<<<<<<
 *                   AlignmentFile samfile,
 *                   **kwargs):
 */

/* Python wrapper */
static int __pyx_pw_5pysam_14calignmentfile_21IteratorColumnAllRefs_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_5pysam_14calignmentfile_21IteratorColumnAllRefs_1__cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile = 0;
  CYTHON_UNUSED PyObject *__pyx_v_kwargs = 0;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__cinit__ (wrapper)", 0);
  __pyx_v_kwargs = PyDict_New(); if (unlikely(!__pyx_v_kwargs)) return -1;
  __Pyx_GOTREF(__pyx_v_kwargs);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_samfile,0};
    PyObject* values[1] = {0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_samfile)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, __pyx_v_kwargs, values, pos_args, "__cinit__") < 0)) __PYX_ERR(0, 2311, __pyx_L3_error)
      }
    } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
      goto __pyx_L5_argtuple_error;
    } else {
      values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
    }
    __pyx_v_samfile = ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)values[0]);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2311, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_DECREF(__pyx_v_kwargs); __pyx_v_kwargs = 0;
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorColumnAllRefs.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_samfile), __pyx_ptype_5pysam_14calignmentfile_AlignmentFile, 1, "samfile", 0))) __PYX_ERR(0, 2312, __pyx_L1_error)
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_21IteratorColumnAllRefs___cinit__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnAllRefs *)__pyx_v_self), __pyx_v_samfile, __pyx_v_kwargs);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_kwargs);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_5pysam_14calignmentfile_21IteratorColumnAllRefs___cinit__(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnAllRefs *__pyx_v_self, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile, CYTHON_UNUSED PyObject *__pyx_v_kwargs) {
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  struct __pyx_opt_args_5pysam_14calignmentfile_14IteratorColumn_setupIteratorData __pyx_t_4;
  __Pyx_RefNannySetupContext("__cinit__", 0);
  __Pyx_TraceCall("__cinit__", __pyx_f[0], 2311, 0, __PYX_ERR(0, 2311, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2316
 * 
 *         # no iteration over empty files
 *         if not samfile.nreferences:             # <<<<<<<<<<<<<<
 *             raise StopIteration
 * 
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_samfile), __pyx_n_s_nreferences); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2316, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) __PYX_ERR(0, 2316, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_3 = ((!__pyx_t_2) != 0);
  if (__pyx_t_3) {

    /* "pysam/calignmentfile.pyx":2317
 *         # no iteration over empty files
 *         if not samfile.nreferences:
 *             raise StopIteration             # <<<<<<<<<<<<<<
 * 
 *         # initialize iterator
 */
    __Pyx_Raise(__pyx_builtin_StopIteration, 0, 0, 0);
    __PYX_ERR(0, 2317, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":2316
 * 
 *         # no iteration over empty files
 *         if not samfile.nreferences:             # <<<<<<<<<<<<<<
 *             raise StopIteration
 * 
 */
  }

  /* "pysam/calignmentfile.pyx":2320
 * 
 *         # initialize iterator
 *         self.setupIteratorData(self.tid, 0, MAX_POS, 1)             # <<<<<<<<<<<<<<
 * 
 *     def __next__(self):
 */
  __pyx_t_4.__pyx_n = 1;
  __pyx_t_4.multiple_iterators = 1;
  __pyx_t_1 = ((struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorColumnAllRefs *)__pyx_v_self->__pyx_base.__pyx_vtab)->__pyx_base.setupIteratorData(((struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *)__pyx_v_self), __pyx_v_self->__pyx_base.tid, 0, __pyx_v_5pysam_14calignmentfile_MAX_POS, &__pyx_t_4); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2320, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "pysam/calignmentfile.pyx":2311
 *     """
 * 
 *     def __cinit__(self,             # <<<<<<<<<<<<<<
 *                   AlignmentFile samfile,
 *                   **kwargs):
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorColumnAllRefs.__cinit__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2322
 *         self.setupIteratorData(self.tid, 0, MAX_POS, 1)
 * 
 *     def __next__(self):             # <<<<<<<<<<<<<<
 * 
 *         while 1:
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_21IteratorColumnAllRefs_3__next__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_21IteratorColumnAllRefs_3__next__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__next__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_21IteratorColumnAllRefs_2__next__(((struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnAllRefs *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_21IteratorColumnAllRefs_2__next__(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnAllRefs *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  struct __pyx_opt_args_5pysam_14calignmentfile_14IteratorColumn_setupIteratorData __pyx_t_5;
  __Pyx_RefNannySetupContext("__next__", 0);
  __Pyx_TraceCall("__next__", __pyx_f[0], 2322, 0, __PYX_ERR(0, 2322, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2324
 *     def __next__(self):
 * 
 *         while 1:             # <<<<<<<<<<<<<<
 *             self.cnext()
 * 
 */
  while (1) {

    /* "pysam/calignmentfile.pyx":2325
 * 
 *         while 1:
 *             self.cnext()             # <<<<<<<<<<<<<<
 * 
 *             if self.n_plp < 0:
 */
    ((struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorColumnAllRefs *)__pyx_v_self->__pyx_base.__pyx_vtab)->__pyx_base.cnext(((struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *)__pyx_v_self));

    /* "pysam/calignmentfile.pyx":2327
 *             self.cnext()
 * 
 *             if self.n_plp < 0:             # <<<<<<<<<<<<<<
 *                 raise ValueError("error during iteration" )
 * 
 */
    __pyx_t_1 = ((__pyx_v_self->__pyx_base.n_plp < 0) != 0);
    if (__pyx_t_1) {

      /* "pysam/calignmentfile.pyx":2328
 * 
 *             if self.n_plp < 0:
 *                 raise ValueError("error during iteration" )             # <<<<<<<<<<<<<<
 * 
 *             # return result, if within same reference
 */
      __pyx_t_2 = __Pyx_PyObject_Call(__pyx_builtin_ValueError, __pyx_tuple__66, NULL); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2328, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_Raise(__pyx_t_2, 0, 0, 0);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __PYX_ERR(0, 2328, __pyx_L1_error)

      /* "pysam/calignmentfile.pyx":2327
 *             self.cnext()
 * 
 *             if self.n_plp < 0:             # <<<<<<<<<<<<<<
 *                 raise ValueError("error during iteration" )
 * 
 */
    }

    /* "pysam/calignmentfile.pyx":2331
 * 
 *             # return result, if within same reference
 *             if self.plp != NULL:             # <<<<<<<<<<<<<<
 *                 return makePileupColumn(&self.plp,
 *                                         self.tid,
 */
    __pyx_t_1 = ((__pyx_v_self->__pyx_base.plp != NULL) != 0);
    if (__pyx_t_1) {

      /* "pysam/calignmentfile.pyx":2332
 *             # return result, if within same reference
 *             if self.plp != NULL:
 *                 return makePileupColumn(&self.plp,             # <<<<<<<<<<<<<<
 *                                         self.tid,
 *                                         self.pos,
 */
      __Pyx_XDECREF(__pyx_r);

      /* "pysam/calignmentfile.pyx":2336
 *                                         self.pos,
 *                                         self.n_plp,
 *                                         self.samfile)             # <<<<<<<<<<<<<<
 * 
 *             # otherwise, proceed to next reference or stop
 */
      __pyx_t_2 = ((PyObject *)__pyx_v_self->__pyx_base.samfile);
      __Pyx_INCREF(__pyx_t_2);

      /* "pysam/calignmentfile.pyx":2332
 *             # return result, if within same reference
 *             if self.plp != NULL:
 *                 return makePileupColumn(&self.plp,             # <<<<<<<<<<<<<<
 *                                         self.tid,
 *                                         self.pos,
 */
      __pyx_t_3 = __pyx_f_5pysam_15calignedsegment_makePileupColumn((&__pyx_v_self->__pyx_base.plp), __pyx_v_self->__pyx_base.tid, __pyx_v_self->__pyx_base.pos, __pyx_v_self->__pyx_base.n_plp, ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)__pyx_t_2)); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2332, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __pyx_r = __pyx_t_3;
      __pyx_t_3 = 0;
      goto __pyx_L0;

      /* "pysam/calignmentfile.pyx":2331
 * 
 *             # return result, if within same reference
 *             if self.plp != NULL:             # <<<<<<<<<<<<<<
 *                 return makePileupColumn(&self.plp,
 *                                         self.tid,
 */
    }

    /* "pysam/calignmentfile.pyx":2339
 * 
 *             # otherwise, proceed to next reference or stop
 *             self.tid += 1             # <<<<<<<<<<<<<<
 *             if self.tid < self.samfile.nreferences:
 *                 self.setupIteratorData(self.tid, 0, MAX_POS, 0)
 */
    __pyx_v_self->__pyx_base.tid = (__pyx_v_self->__pyx_base.tid + 1);

    /* "pysam/calignmentfile.pyx":2340
 *             # otherwise, proceed to next reference or stop
 *             self.tid += 1
 *             if self.tid < self.samfile.nreferences:             # <<<<<<<<<<<<<<
 *                 self.setupIteratorData(self.tid, 0, MAX_POS, 0)
 *             else:
 */
    __pyx_t_3 = __Pyx_PyInt_From_int(__pyx_v_self->__pyx_base.tid); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2340, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self->__pyx_base.samfile), __pyx_n_s_nreferences); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2340, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = PyObject_RichCompare(__pyx_t_3, __pyx_t_2, Py_LT); __Pyx_XGOTREF(__pyx_t_4); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2340, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 2340, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    if (__pyx_t_1) {

      /* "pysam/calignmentfile.pyx":2341
 *             self.tid += 1
 *             if self.tid < self.samfile.nreferences:
 *                 self.setupIteratorData(self.tid, 0, MAX_POS, 0)             # <<<<<<<<<<<<<<
 *             else:
 *                 raise StopIteration
 */
      __pyx_t_5.__pyx_n = 1;
      __pyx_t_5.multiple_iterators = 0;
      __pyx_t_4 = ((struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorColumnAllRefs *)__pyx_v_self->__pyx_base.__pyx_vtab)->__pyx_base.setupIteratorData(((struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *)__pyx_v_self), __pyx_v_self->__pyx_base.tid, 0, __pyx_v_5pysam_14calignmentfile_MAX_POS, &__pyx_t_5); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2341, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

      /* "pysam/calignmentfile.pyx":2340
 *             # otherwise, proceed to next reference or stop
 *             self.tid += 1
 *             if self.tid < self.samfile.nreferences:             # <<<<<<<<<<<<<<
 *                 self.setupIteratorData(self.tid, 0, MAX_POS, 0)
 *             else:
 */
      goto __pyx_L7;
    }

    /* "pysam/calignmentfile.pyx":2343
 *                 self.setupIteratorData(self.tid, 0, MAX_POS, 0)
 *             else:
 *                 raise StopIteration             # <<<<<<<<<<<<<<
 * 
 * 
 */
    /*else*/ {
      __Pyx_Raise(__pyx_builtin_StopIteration, 0, 0, 0);
      __PYX_ERR(0, 2343, __pyx_L1_error)
    }
    __pyx_L7:;
  }

  /* "pysam/calignmentfile.pyx":2322
 *         self.setupIteratorData(self.tid, 0, MAX_POS, 1)
 * 
 *     def __next__(self):             # <<<<<<<<<<<<<<
 * 
 *         while 1:
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pysam.calignmentfile.IteratorColumnAllRefs.__next__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2359
 *     property tid:
 *         '''the chromosome ID as is defined in the header'''
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             return self._tid
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_7SNPCall_3tid_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_7SNPCall_3tid_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_7SNPCall_3tid___get__(((struct __pyx_obj_5pysam_14calignmentfile_SNPCall *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_7SNPCall_3tid___get__(struct __pyx_obj_5pysam_14calignmentfile_SNPCall *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[0], 2359, 0, __PYX_ERR(0, 2359, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2360
 *         '''the chromosome ID as is defined in the header'''
 *         def __get__(self):
 *             return self._tid             # <<<<<<<<<<<<<<
 * 
 *     property pos:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->_tid); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2360, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":2359
 *     property tid:
 *         '''the chromosome ID as is defined in the header'''
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             return self._tid
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pysam.calignmentfile.SNPCall.tid.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2364
 *     property pos:
 *        '''nucleotide position of SNP.'''
 *        def __get__(self): return self._pos             # <<<<<<<<<<<<<<
 * 
 *     property reference_base:
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_7SNPCall_3pos_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_7SNPCall_3pos_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_7SNPCall_3pos___get__(((struct __pyx_obj_5pysam_14calignmentfile_SNPCall *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_7SNPCall_3pos___get__(struct __pyx_obj_5pysam_14calignmentfile_SNPCall *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[0], 2364, 0, __PYX_ERR(0, 2364, __pyx_L1_error));
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->_pos); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2364, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pysam.calignmentfile.SNPCall.pos.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2368
 *     property reference_base:
 *        '''reference base at pos. ``N`` if no reference sequence supplied.'''
 *        def __get__(self): return from_string_and_size( &self._reference_base, 1 )             # <<<<<<<<<<<<<<
 * 
 *     property genotype:
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_7SNPCall_14reference_base_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_7SNPCall_14reference_base_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_7SNPCall_14reference_base___get__(((struct __pyx_obj_5pysam_14calignmentfile_SNPCall *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_7SNPCall_14reference_base___get__(struct __pyx_obj_5pysam_14calignmentfile_SNPCall *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[0], 2368, 0, __PYX_ERR(0, 2368, __pyx_L1_error));
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_5pysam_6cutils_from_string_and_size((&__pyx_v_self->_reference_base), 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2368, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pysam.calignmentfile.SNPCall.reference_base.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2372
 *     property genotype:
 *        '''the genotype called.'''
 *        def __get__(self): return from_string_and_size( &self._genotype, 1 )             # <<<<<<<<<<<<<<
 * 
 *     property consensus_quality:
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_7SNPCall_8genotype_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_7SNPCall_8genotype_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_7SNPCall_8genotype___get__(((struct __pyx_obj_5pysam_14calignmentfile_SNPCall *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_7SNPCall_8genotype___get__(struct __pyx_obj_5pysam_14calignmentfile_SNPCall *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[0], 2372, 0, __PYX_ERR(0, 2372, __pyx_L1_error));
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __pyx_f_5pysam_6cutils_from_string_and_size((&__pyx_v_self->_genotype), 1); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2372, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pysam.calignmentfile.SNPCall.genotype.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2376
 *     property consensus_quality:
 *        '''the genotype quality (Phred-scaled).'''
 *        def __get__(self): return self._consensus_quality             # <<<<<<<<<<<<<<
 * 
 *     property snp_quality:
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_7SNPCall_17consensus_quality_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_7SNPCall_17consensus_quality_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_7SNPCall_17consensus_quality___get__(((struct __pyx_obj_5pysam_14calignmentfile_SNPCall *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_7SNPCall_17consensus_quality___get__(struct __pyx_obj_5pysam_14calignmentfile_SNPCall *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[0], 2376, 0, __PYX_ERR(0, 2376, __pyx_L1_error));
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->_consensus_quality); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2376, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pysam.calignmentfile.SNPCall.consensus_quality.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2381
 *        '''the snp quality (Phred scaled) - probability of consensus being
 *        identical to reference sequence.'''
 *        def __get__(self): return self._snp_quality             # <<<<<<<<<<<<<<
 * 
 *     property mapping_quality:
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_7SNPCall_11snp_quality_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_7SNPCall_11snp_quality_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_7SNPCall_11snp_quality___get__(((struct __pyx_obj_5pysam_14calignmentfile_SNPCall *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_7SNPCall_11snp_quality___get__(struct __pyx_obj_5pysam_14calignmentfile_SNPCall *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[0], 2381, 0, __PYX_ERR(0, 2381, __pyx_L1_error));
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->_snp_quality); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2381, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pysam.calignmentfile.SNPCall.snp_quality.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2386
 *        '''the root mean square (rms) of the mapping quality of all reads
 *        involved in the call.'''
 *        def __get__(self): return self._rms_mapping_quality             # <<<<<<<<<<<<<<
 * 
 *     property coverage:
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_7SNPCall_15mapping_quality_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_7SNPCall_15mapping_quality_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_7SNPCall_15mapping_quality___get__(((struct __pyx_obj_5pysam_14calignmentfile_SNPCall *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_7SNPCall_15mapping_quality___get__(struct __pyx_obj_5pysam_14calignmentfile_SNPCall *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[0], 2386, 0, __PYX_ERR(0, 2386, __pyx_L1_error));
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->_rms_mapping_quality); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2386, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pysam.calignmentfile.SNPCall.mapping_quality.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2390
 *     property coverage:
 *        '''coverage or read depth - the number of reads involved in the call.'''
 *        def __get__(self): return self._coverage             # <<<<<<<<<<<<<<
 * 
 *     def __str__(self):
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_7SNPCall_8coverage_1__get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_7SNPCall_8coverage_1__get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__get__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_7SNPCall_8coverage___get__(((struct __pyx_obj_5pysam_14calignmentfile_SNPCall *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_7SNPCall_8coverage___get__(struct __pyx_obj_5pysam_14calignmentfile_SNPCall *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__", 0);
  __Pyx_TraceCall("__get__", __pyx_f[0], 2390, 0, __PYX_ERR(0, 2390, __pyx_L1_error));
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_From_int(__pyx_v_self->_coverage); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2390, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("pysam.calignmentfile.SNPCall.coverage.__get__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2392
 *        def __get__(self): return self._coverage
 * 
 *     def __str__(self):             # <<<<<<<<<<<<<<
 * 
 *         return "\t".join( map(str, (
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_7SNPCall_1__str__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pw_5pysam_14calignmentfile_7SNPCall_1__str__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__str__ (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_7SNPCall___str__(((struct __pyx_obj_5pysam_14calignmentfile_SNPCall *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_7SNPCall___str__(struct __pyx_obj_5pysam_14calignmentfile_SNPCall *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  PyObject *__pyx_t_9 = NULL;
  __Pyx_RefNannySetupContext("__str__", 0);
  __Pyx_TraceCall("__str__", __pyx_f[0], 2392, 0, __PYX_ERR(0, 2392, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2394
 *     def __str__(self):
 * 
 *         return "\t".join( map(str, (             # <<<<<<<<<<<<<<
 *                     self.tid,
 *                     self.pos,
 */
  __Pyx_XDECREF(__pyx_r);

  /* "pysam/calignmentfile.pyx":2395
 * 
 *         return "\t".join( map(str, (
 *                     self.tid,             # <<<<<<<<<<<<<<
 *                     self.pos,
 *                     self.reference_base,
 */
  __pyx_t_1 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_tid); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2395, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);

  /* "pysam/calignmentfile.pyx":2396
 *         return "\t".join( map(str, (
 *                     self.tid,
 *                     self.pos,             # <<<<<<<<<<<<<<
 *                     self.reference_base,
 *                     self.genotype,
 */
  __pyx_t_2 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_pos); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2396, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);

  /* "pysam/calignmentfile.pyx":2397
 *                     self.tid,
 *                     self.pos,
 *                     self.reference_base,             # <<<<<<<<<<<<<<
 *                     self.genotype,
 *                     self.consensus_quality,
 */
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_reference_base); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2397, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);

  /* "pysam/calignmentfile.pyx":2398
 *                     self.pos,
 *                     self.reference_base,
 *                     self.genotype,             # <<<<<<<<<<<<<<
 *                     self.consensus_quality,
 *                     self.snp_quality,
 */
  __pyx_t_4 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_genotype); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2398, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);

  /* "pysam/calignmentfile.pyx":2399
 *                     self.reference_base,
 *                     self.genotype,
 *                     self.consensus_quality,             # <<<<<<<<<<<<<<
 *                     self.snp_quality,
 *                     self.mapping_quality,
 */
  __pyx_t_5 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_consensus_quality); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2399, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);

  /* "pysam/calignmentfile.pyx":2400
 *                     self.genotype,
 *                     self.consensus_quality,
 *                     self.snp_quality,             # <<<<<<<<<<<<<<
 *                     self.mapping_quality,
 *                     self.coverage ) ) )
 */
  __pyx_t_6 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_snp_quality); if (unlikely(!__pyx_t_6)) __PYX_ERR(0, 2400, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_6);

  /* "pysam/calignmentfile.pyx":2401
 *                     self.consensus_quality,
 *                     self.snp_quality,
 *                     self.mapping_quality,             # <<<<<<<<<<<<<<
 *                     self.coverage ) ) )
 * 
 */
  __pyx_t_7 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_mapping_quality); if (unlikely(!__pyx_t_7)) __PYX_ERR(0, 2401, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_7);

  /* "pysam/calignmentfile.pyx":2402
 *                     self.snp_quality,
 *                     self.mapping_quality,
 *                     self.coverage ) ) )             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_8 = __Pyx_PyObject_GetAttrStr(((PyObject *)__pyx_v_self), __pyx_n_s_coverage); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 2402, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);

  /* "pysam/calignmentfile.pyx":2395
 * 
 *         return "\t".join( map(str, (
 *                     self.tid,             # <<<<<<<<<<<<<<
 *                     self.pos,
 *                     self.reference_base,
 */
  __pyx_t_9 = PyTuple_New(8); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 2395, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_9);
  __Pyx_GIVEREF(__pyx_t_1);
  PyTuple_SET_ITEM(__pyx_t_9, 0, __pyx_t_1);
  __Pyx_GIVEREF(__pyx_t_2);
  PyTuple_SET_ITEM(__pyx_t_9, 1, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_9, 2, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_4);
  PyTuple_SET_ITEM(__pyx_t_9, 3, __pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_5);
  PyTuple_SET_ITEM(__pyx_t_9, 4, __pyx_t_5);
  __Pyx_GIVEREF(__pyx_t_6);
  PyTuple_SET_ITEM(__pyx_t_9, 5, __pyx_t_6);
  __Pyx_GIVEREF(__pyx_t_7);
  PyTuple_SET_ITEM(__pyx_t_9, 6, __pyx_t_7);
  __Pyx_GIVEREF(__pyx_t_8);
  PyTuple_SET_ITEM(__pyx_t_9, 7, __pyx_t_8);
  __pyx_t_1 = 0;
  __pyx_t_2 = 0;
  __pyx_t_3 = 0;
  __pyx_t_4 = 0;
  __pyx_t_5 = 0;
  __pyx_t_6 = 0;
  __pyx_t_7 = 0;
  __pyx_t_8 = 0;

  /* "pysam/calignmentfile.pyx":2394
 *     def __str__(self):
 * 
 *         return "\t".join( map(str, (             # <<<<<<<<<<<<<<
 *                     self.tid,
 *                     self.pos,
 */
  __pyx_t_8 = PyTuple_New(2); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 2394, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __Pyx_INCREF(((PyObject *)(&PyString_Type)));
  __Pyx_GIVEREF(((PyObject *)(&PyString_Type)));
  PyTuple_SET_ITEM(__pyx_t_8, 0, ((PyObject *)(&PyString_Type)));
  __Pyx_GIVEREF(__pyx_t_9);
  PyTuple_SET_ITEM(__pyx_t_8, 1, __pyx_t_9);
  __pyx_t_9 = 0;
  __pyx_t_9 = __Pyx_PyObject_Call(__pyx_builtin_map, __pyx_t_8, NULL); if (unlikely(!__pyx_t_9)) __PYX_ERR(0, 2394, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_9);
  __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
  __pyx_t_8 = __Pyx_PyString_Join(__pyx_kp_s__2, __pyx_t_9); if (unlikely(!__pyx_t_8)) __PYX_ERR(0, 2394, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_8);
  __Pyx_DECREF(__pyx_t_9); __pyx_t_9 = 0;
  __pyx_r = __pyx_t_8;
  __pyx_t_8 = 0;
  goto __pyx_L0;

  /* "pysam/calignmentfile.pyx":2392
 *        def __get__(self): return self._coverage
 * 
 *     def __str__(self):             # <<<<<<<<<<<<<<
 * 
 *         return "\t".join( map(str, (
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_XDECREF(__pyx_t_9);
  __Pyx_AddTraceback("pysam.calignmentfile.SNPCall.__str__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2429
 *     """
 * 
 *     def __init__(self, AlignmentFile samfile, int multiple_iterators=True):             # <<<<<<<<<<<<<<
 *         cdef char *cfilename
 * 
 */

/* Python wrapper */
static int __pyx_pw_5pysam_14calignmentfile_12IndexedReads_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pw_5pysam_14calignmentfile_12IndexedReads_1__init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile = 0;
  int __pyx_v_multiple_iterators;
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__init__ (wrapper)", 0);
  {
    static PyObject **__pyx_pyargnames[] = {&__pyx_n_s_samfile,&__pyx_n_s_multiple_iterators,0};
    PyObject* values[2] = {0,0};
    if (unlikely(__pyx_kwds)) {
      Py_ssize_t kw_args;
      const Py_ssize_t pos_args = PyTuple_GET_SIZE(__pyx_args);
      switch (pos_args) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        case  0: break;
        default: goto __pyx_L5_argtuple_error;
      }
      kw_args = PyDict_Size(__pyx_kwds);
      switch (pos_args) {
        case  0:
        if (likely((values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s_samfile)) != 0)) kw_args--;
        else goto __pyx_L5_argtuple_error;
        case  1:
        if (kw_args > 0) {
          PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_n_s_multiple_iterators);
          if (value) { values[1] = value; kw_args--; }
        }
      }
      if (unlikely(kw_args > 0)) {
        if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, pos_args, "__init__") < 0)) __PYX_ERR(0, 2429, __pyx_L3_error)
      }
    } else {
      switch (PyTuple_GET_SIZE(__pyx_args)) {
        case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
        case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
        break;
        default: goto __pyx_L5_argtuple_error;
      }
    }
    __pyx_v_samfile = ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)values[0]);
    if (values[1]) {
      __pyx_v_multiple_iterators = __Pyx_PyInt_As_int(values[1]); if (unlikely((__pyx_v_multiple_iterators == (int)-1) && PyErr_Occurred())) __PYX_ERR(0, 2429, __pyx_L3_error)
    } else {
      __pyx_v_multiple_iterators = ((int)1);
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 0, 1, 2, PyTuple_GET_SIZE(__pyx_args)); __PYX_ERR(0, 2429, __pyx_L3_error)
  __pyx_L3_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.IndexedReads.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_samfile), __pyx_ptype_5pysam_14calignmentfile_AlignmentFile, 1, "samfile", 0))) __PYX_ERR(0, 2429, __pyx_L1_error)
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_12IndexedReads___init__(((struct __pyx_obj_5pysam_14calignmentfile_IndexedReads *)__pyx_v_self), __pyx_v_samfile, __pyx_v_multiple_iterators);

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_5pysam_14calignmentfile_12IndexedReads___init__(struct __pyx_obj_5pysam_14calignmentfile_IndexedReads *__pyx_v_self, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *__pyx_v_samfile, int __pyx_v_multiple_iterators) {
  char *__pyx_v_cfilename;
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  char *__pyx_t_2;
  htsFile *__pyx_t_3;
  bam_hdr_t *__pyx_t_4;
  __Pyx_RefNannySetupContext("__init__", 0);
  __Pyx_TraceCall("__init__", __pyx_f[0], 2429, 0, __PYX_ERR(0, 2429, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2434
 *         # makes sure that samfile stays alive as long as this
 *         # object is alive.
 *         self.samfile = samfile             # <<<<<<<<<<<<<<
 * 
 *         assert samfile.is_bam, "can only IndexReads on bam files"
 */
  __Pyx_INCREF(((PyObject *)__pyx_v_samfile));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_samfile));
  __Pyx_GOTREF(__pyx_v_self->samfile);
  __Pyx_DECREF(((PyObject *)__pyx_v_self->samfile));
  __pyx_v_self->samfile = __pyx_v_samfile;

  /* "pysam/calignmentfile.pyx":2436
 *         self.samfile = samfile
 * 
 *         assert samfile.is_bam, "can only IndexReads on bam files"             # <<<<<<<<<<<<<<
 * 
 *         # multiple_iterators the file - note that this makes the iterator
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!Py_OptimizeFlag)) {
    if (unlikely(!(__pyx_v_samfile->is_bam != 0))) {
      PyErr_SetObject(PyExc_AssertionError, __pyx_kp_s_can_only_IndexReads_on_bam_files);
      __PYX_ERR(0, 2436, __pyx_L1_error)
    }
  }
  #endif

  /* "pysam/calignmentfile.pyx":2440
 *         # multiple_iterators the file - note that this makes the iterator
 *         # slow and causes pileup to slow down significantly.
 *         if multiple_iterators:             # <<<<<<<<<<<<<<
 *             cfilename = samfile._filename
 *             with nogil:
 */
  __pyx_t_1 = (__pyx_v_multiple_iterators != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":2441
 *         # slow and causes pileup to slow down significantly.
 *         if multiple_iterators:
 *             cfilename = samfile._filename             # <<<<<<<<<<<<<<
 *             with nogil:
 *                 self.htsfile = hts_open(cfilename, 'r')
 */
    __pyx_t_2 = __Pyx_PyObject_AsString(__pyx_v_samfile->_filename); if (unlikely((!__pyx_t_2) && PyErr_Occurred())) __PYX_ERR(0, 2441, __pyx_L1_error)
    __pyx_v_cfilename = __pyx_t_2;

    /* "pysam/calignmentfile.pyx":2442
 *         if multiple_iterators:
 *             cfilename = samfile._filename
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 self.htsfile = hts_open(cfilename, 'r')
 *             assert self.htsfile != NULL
 */
    {
        #ifdef WITH_THREAD
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
        #endif
        /*try:*/ {

          /* "pysam/calignmentfile.pyx":2443
 *             cfilename = samfile._filename
 *             with nogil:
 *                 self.htsfile = hts_open(cfilename, 'r')             # <<<<<<<<<<<<<<
 *             assert self.htsfile != NULL
 *             # read header - required for accurate positioning
 */
          __pyx_v_self->htsfile = hts_open(__pyx_v_cfilename, ((char const *)"r"));
        }

        /* "pysam/calignmentfile.pyx":2442
 *         if multiple_iterators:
 *             cfilename = samfile._filename
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 self.htsfile = hts_open(cfilename, 'r')
 *             assert self.htsfile != NULL
 */
        /*finally:*/ {
          /*normal exit:*/{
            #ifdef WITH_THREAD
            Py_BLOCK_THREADS
            #endif
            goto __pyx_L6;
          }
          __pyx_L6:;
        }
    }

    /* "pysam/calignmentfile.pyx":2444
 *             with nogil:
 *                 self.htsfile = hts_open(cfilename, 'r')
 *             assert self.htsfile != NULL             # <<<<<<<<<<<<<<
 *             # read header - required for accurate positioning
 *             with nogil:
 */
    #ifndef CYTHON_WITHOUT_ASSERTIONS
    if (unlikely(!Py_OptimizeFlag)) {
      if (unlikely(!((__pyx_v_self->htsfile != NULL) != 0))) {
        PyErr_SetNone(PyExc_AssertionError);
        __PYX_ERR(0, 2444, __pyx_L1_error)
      }
    }
    #endif

    /* "pysam/calignmentfile.pyx":2446
 *             assert self.htsfile != NULL
 *             # read header - required for accurate positioning
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 self.header = sam_hdr_read(self.htsfile)
 *             self.owns_samfile = True
 */
    {
        #ifdef WITH_THREAD
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
        #endif
        /*try:*/ {

          /* "pysam/calignmentfile.pyx":2447
 *             # read header - required for accurate positioning
 *             with nogil:
 *                 self.header = sam_hdr_read(self.htsfile)             # <<<<<<<<<<<<<<
 *             self.owns_samfile = True
 *         else:
 */
          __pyx_v_self->header = sam_hdr_read(__pyx_v_self->htsfile);
        }

        /* "pysam/calignmentfile.pyx":2446
 *             assert self.htsfile != NULL
 *             # read header - required for accurate positioning
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 self.header = sam_hdr_read(self.htsfile)
 *             self.owns_samfile = True
 */
        /*finally:*/ {
          /*normal exit:*/{
            #ifdef WITH_THREAD
            Py_BLOCK_THREADS
            #endif
            goto __pyx_L9;
          }
          __pyx_L9:;
        }
    }

    /* "pysam/calignmentfile.pyx":2448
 *             with nogil:
 *                 self.header = sam_hdr_read(self.htsfile)
 *             self.owns_samfile = True             # <<<<<<<<<<<<<<
 *         else:
 *             self.htsfile = self.samfile.htsfile
 */
    __pyx_v_self->owns_samfile = 1;

    /* "pysam/calignmentfile.pyx":2440
 *         # multiple_iterators the file - note that this makes the iterator
 *         # slow and causes pileup to slow down significantly.
 *         if multiple_iterators:             # <<<<<<<<<<<<<<
 *             cfilename = samfile._filename
 *             with nogil:
 */
    goto __pyx_L3;
  }

  /* "pysam/calignmentfile.pyx":2450
 *             self.owns_samfile = True
 *         else:
 *             self.htsfile = self.samfile.htsfile             # <<<<<<<<<<<<<<
 *             self.header = self.samfile.header
 *             self.owns_samfile = False
 */
  /*else*/ {
    __pyx_t_3 = __pyx_v_self->samfile->htsfile;
    __pyx_v_self->htsfile = __pyx_t_3;

    /* "pysam/calignmentfile.pyx":2451
 *         else:
 *             self.htsfile = self.samfile.htsfile
 *             self.header = self.samfile.header             # <<<<<<<<<<<<<<
 *             self.owns_samfile = False
 * 
 */
    __pyx_t_4 = __pyx_v_self->samfile->header;
    __pyx_v_self->header = __pyx_t_4;

    /* "pysam/calignmentfile.pyx":2452
 *             self.htsfile = self.samfile.htsfile
 *             self.header = self.samfile.header
 *             self.owns_samfile = False             # <<<<<<<<<<<<<<
 * 
 *     def build(self):
 */
    __pyx_v_self->owns_samfile = 0;
  }
  __pyx_L3:;

  /* "pysam/calignmentfile.pyx":2429
 *     """
 * 
 *     def __init__(self, AlignmentFile samfile, int multiple_iterators=True):             # <<<<<<<<<<<<<<
 *         cdef char *cfilename
 * 
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("pysam.calignmentfile.IndexedReads.__init__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2454
 *             self.owns_samfile = False
 * 
 *     def build(self):             # <<<<<<<<<<<<<<
 *         '''build the index.'''
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_12IndexedReads_3build(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_12IndexedReads_2build[] = "IndexedReads.build(self)\nbuild the index.";
static PyObject *__pyx_pw_5pysam_14calignmentfile_12IndexedReads_3build(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("build (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_12IndexedReads_2build(((struct __pyx_obj_5pysam_14calignmentfile_IndexedReads *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_12IndexedReads_2build(struct __pyx_obj_5pysam_14calignmentfile_IndexedReads *__pyx_v_self) {
  int __pyx_v_ret;
  bam1_t *__pyx_v_b;
  uint64_t __pyx_v_pos;
  PyObject *__pyx_v_qname = NULL;
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  int __pyx_t_6;
  __Pyx_RefNannySetupContext("build", 0);
  __Pyx_TraceCall("build", __pyx_f[0], 2454, 0, __PYX_ERR(0, 2454, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2457
 *         '''build the index.'''
 * 
 *         self.index = collections.defaultdict(list)             # <<<<<<<<<<<<<<
 * 
 *         # this method will start indexing from the current file
 */
  __pyx_t_2 = __Pyx_GetModuleGlobalName(__pyx_n_s_collections); if (unlikely(!__pyx_t_2)) __PYX_ERR(0, 2457, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_3 = __Pyx_PyObject_GetAttrStr(__pyx_t_2, __pyx_n_s_defaultdict); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2457, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_2 = NULL;
  if (CYTHON_COMPILING_IN_CPYTHON && unlikely(PyMethod_Check(__pyx_t_3))) {
    __pyx_t_2 = PyMethod_GET_SELF(__pyx_t_3);
    if (likely(__pyx_t_2)) {
      PyObject* function = PyMethod_GET_FUNCTION(__pyx_t_3);
      __Pyx_INCREF(__pyx_t_2);
      __Pyx_INCREF(function);
      __Pyx_DECREF_SET(__pyx_t_3, function);
    }
  }
  if (!__pyx_t_2) {
    __pyx_t_1 = __Pyx_PyObject_CallOneArg(__pyx_t_3, ((PyObject *)(&PyList_Type))); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2457, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
  } else {
    __pyx_t_4 = PyTuple_New(1+1); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2457, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_2); PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_2); __pyx_t_2 = NULL;
    __Pyx_INCREF(((PyObject *)(&PyList_Type)));
    __Pyx_GIVEREF(((PyObject *)(&PyList_Type)));
    PyTuple_SET_ITEM(__pyx_t_4, 0+1, ((PyObject *)(&PyList_Type)));
    __pyx_t_1 = __Pyx_PyObject_Call(__pyx_t_3, __pyx_t_4, NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2457, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_1);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __Pyx_GIVEREF(__pyx_t_1);
  __Pyx_GOTREF(__pyx_v_self->index);
  __Pyx_DECREF(__pyx_v_self->index);
  __pyx_v_self->index = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "pysam/calignmentfile.pyx":2461
 *         # this method will start indexing from the current file
 *         # position if you decide
 *         cdef int ret = 1             # <<<<<<<<<<<<<<
 *         cdef bam1_t * b = <bam1_t*>calloc(1, sizeof( bam1_t))
 * 
 */
  __pyx_v_ret = 1;

  /* "pysam/calignmentfile.pyx":2462
 *         # position if you decide
 *         cdef int ret = 1
 *         cdef bam1_t * b = <bam1_t*>calloc(1, sizeof( bam1_t))             # <<<<<<<<<<<<<<
 * 
 *         cdef uint64_t pos
 */
  __pyx_v_b = ((bam1_t *)calloc(1, (sizeof(bam1_t))));

  /* "pysam/calignmentfile.pyx":2466
 *         cdef uint64_t pos
 * 
 *         while ret > 0:             # <<<<<<<<<<<<<<
 *             with nogil:
 *                 pos = bgzf_tell(hts_get_bgzfp(self.htsfile))
 */
  while (1) {
    __pyx_t_5 = ((__pyx_v_ret > 0) != 0);
    if (!__pyx_t_5) break;

    /* "pysam/calignmentfile.pyx":2467
 * 
 *         while ret > 0:
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 pos = bgzf_tell(hts_get_bgzfp(self.htsfile))
 *                 ret = sam_read1(self.htsfile,
 */
    {
        #ifdef WITH_THREAD
        PyThreadState *_save;
        Py_UNBLOCK_THREADS
        #endif
        /*try:*/ {

          /* "pysam/calignmentfile.pyx":2468
 *         while ret > 0:
 *             with nogil:
 *                 pos = bgzf_tell(hts_get_bgzfp(self.htsfile))             # <<<<<<<<<<<<<<
 *                 ret = sam_read1(self.htsfile,
 *                                 self.samfile.header,
 */
          __pyx_v_pos = bgzf_tell(hts_get_bgzfp(__pyx_v_self->htsfile));

          /* "pysam/calignmentfile.pyx":2469
 *             with nogil:
 *                 pos = bgzf_tell(hts_get_bgzfp(self.htsfile))
 *                 ret = sam_read1(self.htsfile,             # <<<<<<<<<<<<<<
 *                                 self.samfile.header,
 *                                 b)
 */
          __pyx_v_ret = sam_read1(__pyx_v_self->htsfile, __pyx_v_self->samfile->header, __pyx_v_b);
        }

        /* "pysam/calignmentfile.pyx":2467
 * 
 *         while ret > 0:
 *             with nogil:             # <<<<<<<<<<<<<<
 *                 pos = bgzf_tell(hts_get_bgzfp(self.htsfile))
 *                 ret = sam_read1(self.htsfile,
 */
        /*finally:*/ {
          /*normal exit:*/{
            #ifdef WITH_THREAD
            Py_BLOCK_THREADS
            #endif
            goto __pyx_L9;
          }
          __pyx_L9:;
        }
    }

    /* "pysam/calignmentfile.pyx":2472
 *                                 self.samfile.header,
 *                                 b)
 *             if ret > 0:             # <<<<<<<<<<<<<<
 *                 qname = charptr_to_str(pysam_bam_get_qname(b))
 *                 self.index[qname].append(pos)
 */
    __pyx_t_5 = ((__pyx_v_ret > 0) != 0);
    if (__pyx_t_5) {

      /* "pysam/calignmentfile.pyx":2473
 *                                 b)
 *             if ret > 0:
 *                 qname = charptr_to_str(pysam_bam_get_qname(b))             # <<<<<<<<<<<<<<
 *                 self.index[qname].append(pos)
 * 
 */
      __pyx_t_1 = __pyx_f_5pysam_6cutils_charptr_to_str(pysam_bam_get_qname(__pyx_v_b), NULL); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2473, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_XDECREF_SET(__pyx_v_qname, __pyx_t_1);
      __pyx_t_1 = 0;

      /* "pysam/calignmentfile.pyx":2474
 *             if ret > 0:
 *                 qname = charptr_to_str(pysam_bam_get_qname(b))
 *                 self.index[qname].append(pos)             # <<<<<<<<<<<<<<
 * 
 *         bam_destroy1(b)
 */
      __pyx_t_1 = PyObject_GetItem(__pyx_v_self->index, __pyx_v_qname); if (unlikely(!__pyx_t_1)) __PYX_ERR(0, 2474, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_3 = __Pyx_PyInt_From_uint64_t(__pyx_v_pos); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2474, __pyx_L1_error)
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_6 = __Pyx_PyObject_Append(__pyx_t_1, __pyx_t_3); if (unlikely(__pyx_t_6 == -1)) __PYX_ERR(0, 2474, __pyx_L1_error)
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

      /* "pysam/calignmentfile.pyx":2472
 *                                 self.samfile.header,
 *                                 b)
 *             if ret > 0:             # <<<<<<<<<<<<<<
 *                 qname = charptr_to_str(pysam_bam_get_qname(b))
 *                 self.index[qname].append(pos)
 */
    }
  }

  /* "pysam/calignmentfile.pyx":2476
 *                 self.index[qname].append(pos)
 * 
 *         bam_destroy1(b)             # <<<<<<<<<<<<<<
 * 
 *     def find(self, query_name):
 */
  bam_destroy1(__pyx_v_b);

  /* "pysam/calignmentfile.pyx":2454
 *             self.owns_samfile = False
 * 
 *     def build(self):             # <<<<<<<<<<<<<<
 *         '''build the index.'''
 * 
 */

  /* function exit code */
  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("pysam.calignmentfile.IndexedReads.build", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XDECREF(__pyx_v_qname);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2478
 *         bam_destroy1(b)
 * 
 *     def find(self, query_name):             # <<<<<<<<<<<<<<
 *         '''find `query_name` in index.
 * 
 */

/* Python wrapper */
static PyObject *__pyx_pw_5pysam_14calignmentfile_12IndexedReads_5find(PyObject *__pyx_v_self, PyObject *__pyx_v_query_name); /*proto*/
static char __pyx_doc_5pysam_14calignmentfile_12IndexedReads_4find[] = "IndexedReads.find(self, query_name)\nfind `query_name` in index.\n\n        Returns\n        -------\n\n        IteratorRowSelection\n            Returns an iterator over all reads with query_name.\n\n        Raises\n        ------\n        \n        KeyError\n            if the `query_name` is not in the index.\n\n        ";
static PyObject *__pyx_pw_5pysam_14calignmentfile_12IndexedReads_5find(PyObject *__pyx_v_self, PyObject *__pyx_v_query_name) {
  PyObject *__pyx_r = 0;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("find (wrapper)", 0);
  __pyx_r = __pyx_pf_5pysam_14calignmentfile_12IndexedReads_4find(((struct __pyx_obj_5pysam_14calignmentfile_IndexedReads *)__pyx_v_self), ((PyObject *)__pyx_v_query_name));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static PyObject *__pyx_pf_5pysam_14calignmentfile_12IndexedReads_4find(struct __pyx_obj_5pysam_14calignmentfile_IndexedReads *__pyx_v_self, PyObject *__pyx_v_query_name) {
  PyObject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("find", 0);
  __Pyx_TraceCall("find", __pyx_f[0], 2478, 0, __PYX_ERR(0, 2478, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2494
 * 
 *         '''
 *         if query_name in self.index:             # <<<<<<<<<<<<<<
 *             return IteratorRowSelection(
 *                 self.samfile,
 */
  __pyx_t_1 = (__Pyx_PySequence_ContainsTF(__pyx_v_query_name, __pyx_v_self->index, Py_EQ)); if (unlikely(__pyx_t_1 < 0)) __PYX_ERR(0, 2494, __pyx_L1_error)
  __pyx_t_2 = (__pyx_t_1 != 0);
  if (__pyx_t_2) {

    /* "pysam/calignmentfile.pyx":2495
 *         '''
 *         if query_name in self.index:
 *             return IteratorRowSelection(             # <<<<<<<<<<<<<<
 *                 self.samfile,
 *                 self.index[query_name],
 */
    __Pyx_XDECREF(__pyx_r);

    /* "pysam/calignmentfile.pyx":2497
 *             return IteratorRowSelection(
 *                 self.samfile,
 *                 self.index[query_name],             # <<<<<<<<<<<<<<
 *                 multiple_iterators = False)
 *         else:
 */
    __pyx_t_3 = PyObject_GetItem(__pyx_v_self->index, __pyx_v_query_name); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2497, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);

    /* "pysam/calignmentfile.pyx":2495
 *         '''
 *         if query_name in self.index:
 *             return IteratorRowSelection(             # <<<<<<<<<<<<<<
 *                 self.samfile,
 *                 self.index[query_name],
 */
    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) __PYX_ERR(0, 2495, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_INCREF(((PyObject *)__pyx_v_self->samfile));
    __Pyx_GIVEREF(((PyObject *)__pyx_v_self->samfile));
    PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)__pyx_v_self->samfile));
    __Pyx_GIVEREF(__pyx_t_3);
    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_3);
    __pyx_t_3 = 0;

    /* "pysam/calignmentfile.pyx":2498
 *                 self.samfile,
 *                 self.index[query_name],
 *                 multiple_iterators = False)             # <<<<<<<<<<<<<<
 *         else:
 *             raise KeyError("read %s not found" % query_name)
 */
    __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2498, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_multiple_iterators, Py_False) < 0) __PYX_ERR(0, 2498, __pyx_L1_error)

    /* "pysam/calignmentfile.pyx":2495
 *         '''
 *         if query_name in self.index:
 *             return IteratorRowSelection(             # <<<<<<<<<<<<<<
 *                 self.samfile,
 *                 self.index[query_name],
 */
    __pyx_t_5 = __Pyx_PyObject_Call(((PyObject *)__pyx_ptype_5pysam_14calignmentfile_IteratorRowSelection), __pyx_t_4, __pyx_t_3); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2495, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_r = __pyx_t_5;
    __pyx_t_5 = 0;
    goto __pyx_L0;

    /* "pysam/calignmentfile.pyx":2494
 * 
 *         '''
 *         if query_name in self.index:             # <<<<<<<<<<<<<<
 *             return IteratorRowSelection(
 *                 self.samfile,
 */
  }

  /* "pysam/calignmentfile.pyx":2500
 *                 multiple_iterators = False)
 *         else:
 *             raise KeyError("read %s not found" % query_name)             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  /*else*/ {
    __pyx_t_5 = __Pyx_PyString_Format(__pyx_kp_s_read_s_not_found, __pyx_v_query_name); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2500, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2500, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_5);
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_5);
    __pyx_t_5 = 0;
    __pyx_t_5 = __Pyx_PyObject_Call(__pyx_builtin_KeyError, __pyx_t_3, NULL); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 2500, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_5, 0, 0, 0);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __PYX_ERR(0, 2500, __pyx_L1_error)
  }

  /* "pysam/calignmentfile.pyx":2478
 *         bam_destroy1(b)
 * 
 *     def find(self, query_name):             # <<<<<<<<<<<<<<
 *         '''find `query_name` in index.
 * 
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("pysam.calignmentfile.IndexedReads.find", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "pysam/calignmentfile.pyx":2502
 *             raise KeyError("read %s not found" % query_name)
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         if self.owns_samfile:
 *             hts_close(self.htsfile)
 */

/* Python wrapper */
static void __pyx_pw_5pysam_14calignmentfile_12IndexedReads_7__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pw_5pysam_14calignmentfile_12IndexedReads_7__dealloc__(PyObject *__pyx_v_self) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__dealloc__ (wrapper)", 0);
  __pyx_pf_5pysam_14calignmentfile_12IndexedReads_6__dealloc__(((struct __pyx_obj_5pysam_14calignmentfile_IndexedReads *)__pyx_v_self));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_5pysam_14calignmentfile_12IndexedReads_6__dealloc__(struct __pyx_obj_5pysam_14calignmentfile_IndexedReads *__pyx_v_self) {
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("__dealloc__", 0);
  __Pyx_TraceCall("__dealloc__", __pyx_f[0], 2502, 0, __PYX_ERR(0, 2502, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":2503
 * 
 *     def __dealloc__(self):
 *         if self.owns_samfile:             # <<<<<<<<<<<<<<
 *             hts_close(self.htsfile)
 *             bam_hdr_destroy(self.header)
 */
  __pyx_t_1 = (__pyx_v_self->owns_samfile != 0);
  if (__pyx_t_1) {

    /* "pysam/calignmentfile.pyx":2504
 *     def __dealloc__(self):
 *         if self.owns_samfile:
 *             hts_close(self.htsfile)             # <<<<<<<<<<<<<<
 *             bam_hdr_destroy(self.header)
 * 
 */
    hts_close(__pyx_v_self->htsfile);

    /* "pysam/calignmentfile.pyx":2505
 *         if self.owns_samfile:
 *             hts_close(self.htsfile)
 *             bam_hdr_destroy(self.header)             # <<<<<<<<<<<<<<
 * 
 * __all__ = [
 */
    bam_hdr_destroy(__pyx_v_self->header);

    /* "pysam/calignmentfile.pyx":2503
 * 
 *     def __dealloc__(self):
 *         if self.owns_samfile:             # <<<<<<<<<<<<<<
 *             hts_close(self.htsfile)
 *             bam_hdr_destroy(self.header)
 */
  }

  /* "pysam/calignmentfile.pyx":2502
 *             raise KeyError("read %s not found" % query_name)
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         if self.owns_samfile:
 *             hts_close(self.htsfile)
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("pysam.calignmentfile.IndexedReads.__dealloc__", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
}

/* "array.pxd":91
 *             __data_union data
 * 
 *         def __getbuffer__(self, Py_buffer* info, int flags):             # <<<<<<<<<<<<<<
 *             # This implementation of getbuffer is geared towards Cython
 *             # requirements, and does not yet fullfill the PEP.
 */

/* Python wrapper */
static CYTHON_UNUSED int __pyx_pw_7cpython_5array_5array_1__getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags); /*proto*/
static CYTHON_UNUSED int __pyx_pw_7cpython_5array_5array_1__getbuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info, int __pyx_v_flags) {
  int __pyx_r;
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__getbuffer__ (wrapper)", 0);
  __pyx_r = __pyx_pf_7cpython_5array_5array___getbuffer__(((arrayobject *)__pyx_v_self), ((Py_buffer *)__pyx_v_info), ((int)__pyx_v_flags));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

static int __pyx_pf_7cpython_5array_5array___getbuffer__(arrayobject *__pyx_v_self, Py_buffer *__pyx_v_info, CYTHON_UNUSED int __pyx_v_flags) {
  PyObject *__pyx_v_item_count = NULL;
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  char *__pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  Py_ssize_t __pyx_t_5;
  int __pyx_t_6;
  __Pyx_RefNannySetupContext("__getbuffer__", 0);
  if (__pyx_v_info != NULL) {
    __pyx_v_info->obj = Py_None; __Pyx_INCREF(Py_None);
    __Pyx_GIVEREF(__pyx_v_info->obj);
  }
  __Pyx_TraceCall("__getbuffer__", __pyx_f[2], 91, 0, __PYX_ERR(2, 91, __pyx_L1_error));

  /* "array.pxd":96
 *             # In particular strided access is always provided regardless
 *             # of flags
 *             item_count = Py_SIZE(self)             # <<<<<<<<<<<<<<
 * 
 *             info.suboffsets = NULL
 */
  __pyx_t_1 = PyInt_FromSsize_t(Py_SIZE(((PyObject *)__pyx_v_self))); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 96, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_item_count = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "array.pxd":98
 *             item_count = Py_SIZE(self)
 * 
 *             info.suboffsets = NULL             # <<<<<<<<<<<<<<
 *             info.buf = self.data.as_chars
 *             info.readonly = 0
 */
  __pyx_v_info->suboffsets = NULL;

  /* "array.pxd":99
 * 
 *             info.suboffsets = NULL
 *             info.buf = self.data.as_chars             # <<<<<<<<<<<<<<
 *             info.readonly = 0
 *             info.ndim = 1
 */
  __pyx_t_2 = __pyx_v_self->data.as_chars;
  __pyx_v_info->buf = __pyx_t_2;

  /* "array.pxd":100
 *             info.suboffsets = NULL
 *             info.buf = self.data.as_chars
 *             info.readonly = 0             # <<<<<<<<<<<<<<
 *             info.ndim = 1
 *             info.itemsize = self.ob_descr.itemsize   # e.g. sizeof(float)
 */
  __pyx_v_info->readonly = 0;

  /* "array.pxd":101
 *             info.buf = self.data.as_chars
 *             info.readonly = 0
 *             info.ndim = 1             # <<<<<<<<<<<<<<
 *             info.itemsize = self.ob_descr.itemsize   # e.g. sizeof(float)
 *             info.len = info.itemsize * item_count
 */
  __pyx_v_info->ndim = 1;

  /* "array.pxd":102
 *             info.readonly = 0
 *             info.ndim = 1
 *             info.itemsize = self.ob_descr.itemsize   # e.g. sizeof(float)             # <<<<<<<<<<<<<<
 *             info.len = info.itemsize * item_count
 * 
 */
  __pyx_t_3 = __pyx_v_self->ob_descr->itemsize;
  __pyx_v_info->itemsize = __pyx_t_3;

  /* "array.pxd":103
 *             info.ndim = 1
 *             info.itemsize = self.ob_descr.itemsize   # e.g. sizeof(float)
 *             info.len = info.itemsize * item_count             # <<<<<<<<<<<<<<
 * 
 *             info.shape = <Py_ssize_t*> PyObject_Malloc(sizeof(Py_ssize_t) + 2)
 */
  __pyx_t_1 = PyInt_FromSsize_t(__pyx_v_info->itemsize); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 103, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_4 = PyNumber_Multiply(__pyx_t_1, __pyx_v_item_count); if (unlikely(!__pyx_t_4)) __PYX_ERR(2, 103, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_5 = __Pyx_PyIndex_AsSsize_t(__pyx_t_4); if (unlikely((__pyx_t_5 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 103, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  __pyx_v_info->len = __pyx_t_5;

  /* "array.pxd":105
 *             info.len = info.itemsize * item_count
 * 
 *             info.shape = <Py_ssize_t*> PyObject_Malloc(sizeof(Py_ssize_t) + 2)             # <<<<<<<<<<<<<<
 *             if not info.shape:
 *                 raise MemoryError()
 */
  __pyx_v_info->shape = ((Py_ssize_t *)PyObject_Malloc(((sizeof(Py_ssize_t)) + 2)));

  /* "array.pxd":106
 * 
 *             info.shape = <Py_ssize_t*> PyObject_Malloc(sizeof(Py_ssize_t) + 2)
 *             if not info.shape:             # <<<<<<<<<<<<<<
 *                 raise MemoryError()
 *             info.shape[0] = item_count      # constant regardless of resizing
 */
  __pyx_t_6 = ((!(__pyx_v_info->shape != 0)) != 0);
  if (__pyx_t_6) {

    /* "array.pxd":107
 *             info.shape = <Py_ssize_t*> PyObject_Malloc(sizeof(Py_ssize_t) + 2)
 *             if not info.shape:
 *                 raise MemoryError()             # <<<<<<<<<<<<<<
 *             info.shape[0] = item_count      # constant regardless of resizing
 *             info.strides = &info.itemsize
 */
    PyErr_NoMemory(); __PYX_ERR(2, 107, __pyx_L1_error)

    /* "array.pxd":106
 * 
 *             info.shape = <Py_ssize_t*> PyObject_Malloc(sizeof(Py_ssize_t) + 2)
 *             if not info.shape:             # <<<<<<<<<<<<<<
 *                 raise MemoryError()
 *             info.shape[0] = item_count      # constant regardless of resizing
 */
  }

  /* "array.pxd":108
 *             if not info.shape:
 *                 raise MemoryError()
 *             info.shape[0] = item_count      # constant regardless of resizing             # <<<<<<<<<<<<<<
 *             info.strides = &info.itemsize
 * 
 */
  __pyx_t_5 = __Pyx_PyIndex_AsSsize_t(__pyx_v_item_count); if (unlikely((__pyx_t_5 == (Py_ssize_t)-1) && PyErr_Occurred())) __PYX_ERR(2, 108, __pyx_L1_error)
  (__pyx_v_info->shape[0]) = __pyx_t_5;

  /* "array.pxd":109
 *                 raise MemoryError()
 *             info.shape[0] = item_count      # constant regardless of resizing
 *             info.strides = &info.itemsize             # <<<<<<<<<<<<<<
 * 
 *             info.format = <char*> (info.shape + 1)
 */
  __pyx_v_info->strides = (&__pyx_v_info->itemsize);

  /* "array.pxd":111
 *             info.strides = &info.itemsize
 * 
 *             info.format = <char*> (info.shape + 1)             # <<<<<<<<<<<<<<
 *             info.format[0] = self.ob_descr.typecode
 *             info.format[1] = 0
 */
  __pyx_v_info->format = ((char *)(__pyx_v_info->shape + 1));

  /* "array.pxd":112
 * 
 *             info.format = <char*> (info.shape + 1)
 *             info.format[0] = self.ob_descr.typecode             # <<<<<<<<<<<<<<
 *             info.format[1] = 0
 *             info.obj = self
 */
  __pyx_t_3 = __pyx_v_self->ob_descr->typecode;
  (__pyx_v_info->format[0]) = __pyx_t_3;

  /* "array.pxd":113
 *             info.format = <char*> (info.shape + 1)
 *             info.format[0] = self.ob_descr.typecode
 *             info.format[1] = 0             # <<<<<<<<<<<<<<
 *             info.obj = self
 * 
 */
  (__pyx_v_info->format[1]) = 0;

  /* "array.pxd":114
 *             info.format[0] = self.ob_descr.typecode
 *             info.format[1] = 0
 *             info.obj = self             # <<<<<<<<<<<<<<
 * 
 *         def __releasebuffer__(self, Py_buffer* info):
 */
  __Pyx_INCREF(((PyObject *)__pyx_v_self));
  __Pyx_GIVEREF(((PyObject *)__pyx_v_self));
  __Pyx_GOTREF(__pyx_v_info->obj);
  __Pyx_DECREF(__pyx_v_info->obj);
  __pyx_v_info->obj = ((PyObject *)__pyx_v_self);

  /* "array.pxd":91
 *             __data_union data
 * 
 *         def __getbuffer__(self, Py_buffer* info, int flags):             # <<<<<<<<<<<<<<
 *             # This implementation of getbuffer is geared towards Cython
 *             # requirements, and does not yet fullfill the PEP.
 */

  /* function exit code */
  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("cpython.array.array.__getbuffer__", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  if (__pyx_v_info != NULL && __pyx_v_info->obj != NULL) {
    __Pyx_GOTREF(__pyx_v_info->obj);
    __Pyx_DECREF(__pyx_v_info->obj); __pyx_v_info->obj = NULL;
  }
  goto __pyx_L2;
  __pyx_L0:;
  if (__pyx_v_info != NULL && __pyx_v_info->obj == Py_None) {
    __Pyx_GOTREF(Py_None);
    __Pyx_DECREF(Py_None); __pyx_v_info->obj = NULL;
  }
  __pyx_L2:;
  __Pyx_XDECREF(__pyx_v_item_count);
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "array.pxd":116
 *             info.obj = self
 * 
 *         def __releasebuffer__(self, Py_buffer* info):             # <<<<<<<<<<<<<<
 *             PyObject_Free(info.shape)
 * 
 */

/* Python wrapper */
static CYTHON_UNUSED void __pyx_pw_7cpython_5array_5array_3__releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info); /*proto*/
static CYTHON_UNUSED void __pyx_pw_7cpython_5array_5array_3__releasebuffer__(PyObject *__pyx_v_self, Py_buffer *__pyx_v_info) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__releasebuffer__ (wrapper)", 0);
  __pyx_pf_7cpython_5array_5array_2__releasebuffer__(((arrayobject *)__pyx_v_self), ((Py_buffer *)__pyx_v_info));

  /* function exit code */
  __Pyx_RefNannyFinishContext();
}

static void __pyx_pf_7cpython_5array_5array_2__releasebuffer__(CYTHON_UNUSED arrayobject *__pyx_v_self, Py_buffer *__pyx_v_info) {
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__releasebuffer__", 0);
  __Pyx_TraceCall("__releasebuffer__", __pyx_f[2], 116, 0, __PYX_ERR(2, 116, __pyx_L1_error));

  /* "array.pxd":117
 * 
 *         def __releasebuffer__(self, Py_buffer* info):
 *             PyObject_Free(info.shape)             # <<<<<<<<<<<<<<
 * 
 *     array newarrayobject(PyTypeObject* type, Py_ssize_t size, arraydescr *descr)
 */
  PyObject_Free(__pyx_v_info->shape);

  /* "array.pxd":116
 *             info.obj = self
 * 
 *         def __releasebuffer__(self, Py_buffer* info):             # <<<<<<<<<<<<<<
 *             PyObject_Free(info.shape)
 * 
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("cpython.array.array.__releasebuffer__", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
}

/* "array.pxd":128
 * 
 * 
 * cdef inline array clone(array template, Py_ssize_t length, bint zero):             # <<<<<<<<<<<<<<
 *     """ fast creation of a new array, given a template array.
 *     type will be same as template.
 */

static CYTHON_INLINE arrayobject *__pyx_f_7cpython_5array_clone(arrayobject *__pyx_v_template, Py_ssize_t __pyx_v_length, int __pyx_v_zero) {
  arrayobject *__pyx_v_op = NULL;
  arrayobject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  __Pyx_RefNannySetupContext("clone", 0);
  __Pyx_TraceCall("clone", __pyx_f[2], 128, 0, __PYX_ERR(2, 128, __pyx_L1_error));

  /* "array.pxd":132
 *     type will be same as template.
 *     if zero is true, new array will be initialized with zeroes."""
 *     op = newarrayobject(Py_TYPE(template), length, template.ob_descr)             # <<<<<<<<<<<<<<
 *     if zero and op is not None:
 *         memset(op.data.as_chars, 0, length * op.ob_descr.itemsize)
 */
  __pyx_t_1 = ((PyObject *)newarrayobject(Py_TYPE(((PyObject *)__pyx_v_template)), __pyx_v_length, __pyx_v_template->ob_descr)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 132, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_op = ((arrayobject *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "array.pxd":133
 *     if zero is true, new array will be initialized with zeroes."""
 *     op = newarrayobject(Py_TYPE(template), length, template.ob_descr)
 *     if zero and op is not None:             # <<<<<<<<<<<<<<
 *         memset(op.data.as_chars, 0, length * op.ob_descr.itemsize)
 *     return op
 */
  __pyx_t_3 = (__pyx_v_zero != 0);
  if (__pyx_t_3) {
  } else {
    __pyx_t_2 = __pyx_t_3;
    goto __pyx_L4_bool_binop_done;
  }
  __pyx_t_3 = (((PyObject *)__pyx_v_op) != Py_None);
  __pyx_t_4 = (__pyx_t_3 != 0);
  __pyx_t_2 = __pyx_t_4;
  __pyx_L4_bool_binop_done:;
  if (__pyx_t_2) {

    /* "array.pxd":134
 *     op = newarrayobject(Py_TYPE(template), length, template.ob_descr)
 *     if zero and op is not None:
 *         memset(op.data.as_chars, 0, length * op.ob_descr.itemsize)             # <<<<<<<<<<<<<<
 *     return op
 * 
 */
    memset(__pyx_v_op->data.as_chars, 0, (__pyx_v_length * __pyx_v_op->ob_descr->itemsize));

    /* "array.pxd":133
 *     if zero is true, new array will be initialized with zeroes."""
 *     op = newarrayobject(Py_TYPE(template), length, template.ob_descr)
 *     if zero and op is not None:             # <<<<<<<<<<<<<<
 *         memset(op.data.as_chars, 0, length * op.ob_descr.itemsize)
 *     return op
 */
  }

  /* "array.pxd":135
 *     if zero and op is not None:
 *         memset(op.data.as_chars, 0, length * op.ob_descr.itemsize)
 *     return op             # <<<<<<<<<<<<<<
 * 
 * cdef inline array copy(array self):
 */
  __Pyx_XDECREF(((PyObject *)__pyx_r));
  __Pyx_INCREF(((PyObject *)__pyx_v_op));
  __pyx_r = __pyx_v_op;
  goto __pyx_L0;

  /* "array.pxd":128
 * 
 * 
 * cdef inline array clone(array template, Py_ssize_t length, bint zero):             # <<<<<<<<<<<<<<
 *     """ fast creation of a new array, given a template array.
 *     type will be same as template.
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("cpython.array.clone", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_op);
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "array.pxd":137
 *     return op
 * 
 * cdef inline array copy(array self):             # <<<<<<<<<<<<<<
 *     """ make a copy of an array. """
 *     op = newarrayobject(Py_TYPE(self), Py_SIZE(self), self.ob_descr)
 */

static CYTHON_INLINE arrayobject *__pyx_f_7cpython_5array_copy(arrayobject *__pyx_v_self) {
  arrayobject *__pyx_v_op = NULL;
  arrayobject *__pyx_r = NULL;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("copy", 0);
  __Pyx_TraceCall("copy", __pyx_f[2], 137, 0, __PYX_ERR(2, 137, __pyx_L1_error));

  /* "array.pxd":139
 * cdef inline array copy(array self):
 *     """ make a copy of an array. """
 *     op = newarrayobject(Py_TYPE(self), Py_SIZE(self), self.ob_descr)             # <<<<<<<<<<<<<<
 *     memcpy(op.data.as_chars, self.data.as_chars, Py_SIZE(op) * op.ob_descr.itemsize)
 *     return op
 */
  __pyx_t_1 = ((PyObject *)newarrayobject(Py_TYPE(((PyObject *)__pyx_v_self)), Py_SIZE(((PyObject *)__pyx_v_self)), __pyx_v_self->ob_descr)); if (unlikely(!__pyx_t_1)) __PYX_ERR(2, 139, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_v_op = ((arrayobject *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "array.pxd":140
 *     """ make a copy of an array. """
 *     op = newarrayobject(Py_TYPE(self), Py_SIZE(self), self.ob_descr)
 *     memcpy(op.data.as_chars, self.data.as_chars, Py_SIZE(op) * op.ob_descr.itemsize)             # <<<<<<<<<<<<<<
 *     return op
 * 
 */
  memcpy(__pyx_v_op->data.as_chars, __pyx_v_self->data.as_chars, (Py_SIZE(((PyObject *)__pyx_v_op)) * __pyx_v_op->ob_descr->itemsize));

  /* "array.pxd":141
 *     op = newarrayobject(Py_TYPE(self), Py_SIZE(self), self.ob_descr)
 *     memcpy(op.data.as_chars, self.data.as_chars, Py_SIZE(op) * op.ob_descr.itemsize)
 *     return op             # <<<<<<<<<<<<<<
 * 
 * cdef inline int extend_buffer(array self, char* stuff, Py_ssize_t n) except -1:
 */
  __Pyx_XDECREF(((PyObject *)__pyx_r));
  __Pyx_INCREF(((PyObject *)__pyx_v_op));
  __pyx_r = __pyx_v_op;
  goto __pyx_L0;

  /* "array.pxd":137
 *     return op
 * 
 * cdef inline array copy(array self):             # <<<<<<<<<<<<<<
 *     """ make a copy of an array. """
 *     op = newarrayobject(Py_TYPE(self), Py_SIZE(self), self.ob_descr)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("cpython.array.copy", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XDECREF((PyObject *)__pyx_v_op);
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_TraceReturn(__pyx_r, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "array.pxd":143
 *     return op
 * 
 * cdef inline int extend_buffer(array self, char* stuff, Py_ssize_t n) except -1:             # <<<<<<<<<<<<<<
 *     """ efficent appending of new stuff of same type
 *     (e.g. of same array type)
 */

static CYTHON_INLINE int __pyx_f_7cpython_5array_extend_buffer(arrayobject *__pyx_v_self, char *__pyx_v_stuff, Py_ssize_t __pyx_v_n) {
  Py_ssize_t __pyx_v_itemsize;
  Py_ssize_t __pyx_v_origsize;
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("extend_buffer", 0);
  __Pyx_TraceCall("extend_buffer", __pyx_f[2], 143, 0, __PYX_ERR(2, 143, __pyx_L1_error));

  /* "array.pxd":147
 *     (e.g. of same array type)
 *     n: number of elements (not number of bytes!) """
 *     cdef Py_ssize_t itemsize = self.ob_descr.itemsize             # <<<<<<<<<<<<<<
 *     cdef Py_ssize_t origsize = Py_SIZE(self)
 *     resize_smart(self, origsize + n)
 */
  __pyx_t_1 = __pyx_v_self->ob_descr->itemsize;
  __pyx_v_itemsize = __pyx_t_1;

  /* "array.pxd":148
 *     n: number of elements (not number of bytes!) """
 *     cdef Py_ssize_t itemsize = self.ob_descr.itemsize
 *     cdef Py_ssize_t origsize = Py_SIZE(self)             # <<<<<<<<<<<<<<
 *     resize_smart(self, origsize + n)
 *     memcpy(self.data.as_chars + origsize * itemsize, stuff, n * itemsize)
 */
  __pyx_v_origsize = Py_SIZE(((PyObject *)__pyx_v_self));

  /* "array.pxd":149
 *     cdef Py_ssize_t itemsize = self.ob_descr.itemsize
 *     cdef Py_ssize_t origsize = Py_SIZE(self)
 *     resize_smart(self, origsize + n)             # <<<<<<<<<<<<<<
 *     memcpy(self.data.as_chars + origsize * itemsize, stuff, n * itemsize)
 *     return 0
 */
  __pyx_t_1 = resize_smart(__pyx_v_self, (__pyx_v_origsize + __pyx_v_n)); if (unlikely(__pyx_t_1 == -1)) __PYX_ERR(2, 149, __pyx_L1_error)

  /* "array.pxd":150
 *     cdef Py_ssize_t origsize = Py_SIZE(self)
 *     resize_smart(self, origsize + n)
 *     memcpy(self.data.as_chars + origsize * itemsize, stuff, n * itemsize)             # <<<<<<<<<<<<<<
 *     return 0
 * 
 */
  memcpy((__pyx_v_self->data.as_chars + (__pyx_v_origsize * __pyx_v_itemsize)), __pyx_v_stuff, (__pyx_v_n * __pyx_v_itemsize));

  /* "array.pxd":151
 *     resize_smart(self, origsize + n)
 *     memcpy(self.data.as_chars + origsize * itemsize, stuff, n * itemsize)
 *     return 0             # <<<<<<<<<<<<<<
 * 
 * cdef inline int extend(array self, array other) except -1:
 */
  __pyx_r = 0;
  goto __pyx_L0;

  /* "array.pxd":143
 *     return op
 * 
 * cdef inline int extend_buffer(array self, char* stuff, Py_ssize_t n) except -1:             # <<<<<<<<<<<<<<
 *     """ efficent appending of new stuff of same type
 *     (e.g. of same array type)
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("cpython.array.extend_buffer", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "array.pxd":153
 *     return 0
 * 
 * cdef inline int extend(array self, array other) except -1:             # <<<<<<<<<<<<<<
 *     """ extend array with data from another array; types must match. """
 *     if self.ob_descr.typecode != other.ob_descr.typecode:
 */

static CYTHON_INLINE int __pyx_f_7cpython_5array_extend(arrayobject *__pyx_v_self, arrayobject *__pyx_v_other) {
  int __pyx_r;
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  int __pyx_t_1;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("extend", 0);
  __Pyx_TraceCall("extend", __pyx_f[2], 153, 0, __PYX_ERR(2, 153, __pyx_L1_error));

  /* "array.pxd":155
 * cdef inline int extend(array self, array other) except -1:
 *     """ extend array with data from another array; types must match. """
 *     if self.ob_descr.typecode != other.ob_descr.typecode:             # <<<<<<<<<<<<<<
 *         PyErr_BadArgument()
 *     return extend_buffer(self, other.data.as_chars, Py_SIZE(other))
 */
  __pyx_t_1 = ((__pyx_v_self->ob_descr->typecode != __pyx_v_other->ob_descr->typecode) != 0);
  if (__pyx_t_1) {

    /* "array.pxd":156
 *     """ extend array with data from another array; types must match. """
 *     if self.ob_descr.typecode != other.ob_descr.typecode:
 *         PyErr_BadArgument()             # <<<<<<<<<<<<<<
 *     return extend_buffer(self, other.data.as_chars, Py_SIZE(other))
 * 
 */
    __pyx_t_2 = PyErr_BadArgument(); if (unlikely(__pyx_t_2 == 0)) __PYX_ERR(2, 156, __pyx_L1_error)

    /* "array.pxd":155
 * cdef inline int extend(array self, array other) except -1:
 *     """ extend array with data from another array; types must match. """
 *     if self.ob_descr.typecode != other.ob_descr.typecode:             # <<<<<<<<<<<<<<
 *         PyErr_BadArgument()
 *     return extend_buffer(self, other.data.as_chars, Py_SIZE(other))
 */
  }

  /* "array.pxd":157
 *     if self.ob_descr.typecode != other.ob_descr.typecode:
 *         PyErr_BadArgument()
 *     return extend_buffer(self, other.data.as_chars, Py_SIZE(other))             # <<<<<<<<<<<<<<
 * 
 * cdef inline void zero(array self):
 */
  __pyx_t_2 = __pyx_f_7cpython_5array_extend_buffer(__pyx_v_self, __pyx_v_other->data.as_chars, Py_SIZE(((PyObject *)__pyx_v_other))); if (unlikely(__pyx_t_2 == -1)) __PYX_ERR(2, 157, __pyx_L1_error)
  __pyx_r = __pyx_t_2;
  goto __pyx_L0;

  /* "array.pxd":153
 *     return 0
 * 
 * cdef inline int extend(array self, array other) except -1:             # <<<<<<<<<<<<<<
 *     """ extend array with data from another array; types must match. """
 *     if self.ob_descr.typecode != other.ob_descr.typecode:
 */

  /* function exit code */
  __pyx_L1_error:;
  __Pyx_AddTraceback("cpython.array.extend", __pyx_clineno, __pyx_lineno, __pyx_filename);
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "array.pxd":159
 *     return extend_buffer(self, other.data.as_chars, Py_SIZE(other))
 * 
 * cdef inline void zero(array self):             # <<<<<<<<<<<<<<
 *     """ set all elements of array to zero. """
 *     memset(self.data.as_chars, 0, Py_SIZE(self) * self.ob_descr.itemsize)
 */

static CYTHON_INLINE void __pyx_f_7cpython_5array_zero(arrayobject *__pyx_v_self) {
  __Pyx_TraceDeclarations
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("zero", 0);
  __Pyx_TraceCall("zero", __pyx_f[2], 159, 0, __PYX_ERR(2, 159, __pyx_L1_error));

  /* "array.pxd":161
 * cdef inline void zero(array self):
 *     """ set all elements of array to zero. """
 *     memset(self.data.as_chars, 0, Py_SIZE(self) * self.ob_descr.itemsize)             # <<<<<<<<<<<<<<
 */
  memset(__pyx_v_self->data.as_chars, 0, (Py_SIZE(((PyObject *)__pyx_v_self)) * __pyx_v_self->ob_descr->itemsize));

  /* "array.pxd":159
 *     return extend_buffer(self, other.data.as_chars, Py_SIZE(other))
 * 
 * cdef inline void zero(array self):             # <<<<<<<<<<<<<<
 *     """ set all elements of array to zero. """
 *     memset(self.data.as_chars, 0, Py_SIZE(self) * self.ob_descr.itemsize)
 */

  /* function exit code */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_WriteUnraisable("cpython.array.zero", __pyx_clineno, __pyx_lineno, __pyx_filename, 0, 0);
  __pyx_L0:;
  __Pyx_TraceReturn(Py_None, 0);
  __Pyx_RefNannyFinishContext();
}
static struct __pyx_vtabstruct_5pysam_14calignmentfile_AlignmentFile __pyx_vtable_5pysam_14calignmentfile_AlignmentFile;

static PyObject *__pyx_tp_new_5pysam_14calignmentfile_AlignmentFile(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)o);
  p->__pyx_vtab = __pyx_vtabptr_5pysam_14calignmentfile_AlignmentFile;
  p->_filename = Py_None; Py_INCREF(Py_None);
  if (unlikely(__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_1__cinit__(o, a, k) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_5pysam_14calignmentfile_AlignmentFile(PyObject *o) {
  struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *p = (struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)o;
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_37__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  Py_CLEAR(p->_filename);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_5pysam_14calignmentfile_AlignmentFile(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *p = (struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)o;
  if (p->_filename) {
    e = (*v)(p->_filename, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_5pysam_14calignmentfile_AlignmentFile(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *p = (struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)o;
  tmp = ((PyObject*)p->_filename);
  p->_filename = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_closed(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_6closed_1__get__(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_filename(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_8filename_1__get__(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_nreferences(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_11nreferences_1__get__(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_references(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_10references_1__get__(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_lengths(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_7lengths_1__get__(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_mapped(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_6mapped_1__get__(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_unmapped(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_8unmapped_1__get__(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_nocoordinate(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_12nocoordinate_1__get__(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_format(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_6format_1__get__(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_text(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_4text_1__get__(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_header(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_6header_1__get__(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_is_bam(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_6is_bam_1__get__(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_is_cram(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_7is_cram_1__get__(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_is_stream(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_9is_stream_1__get__(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_is_remote(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_9is_remote_1__get__(o);
}

static PyMethodDef __pyx_methods_5pysam_14calignmentfile_AlignmentFile[] = {
  {"is_open", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_3is_open, METH_NOARGS, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_2is_open},
  {"has_index", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_5has_index, METH_NOARGS, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_4has_index},
  {"check_index", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_7check_index, METH_NOARGS, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_6check_index},
  {"_open", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_9_open, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_8_open},
  {"get_tid", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_11get_tid, METH_O, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_10get_tid},
  {"get_reference_name", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_13get_reference_name, METH_O, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_12get_reference_name},
  {"reset", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_15reset, METH_NOARGS, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_14reset},
  {"seek", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_17seek, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_16seek},
  {"tell", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_19tell, METH_NOARGS, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_18tell},
  {"parse_region", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_21parse_region, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_20parse_region},
  {"fetch", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_23fetch, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_22fetch},
  {"head", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_25head, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_24head},
  {"mate", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_27mate, METH_O, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_26mate},
  {"pileup", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_29pileup, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_28pileup},
  {"count", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_31count, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_30count},
  {"count_coverage", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_33count_coverage, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_32count_coverage},
  {"close", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_35close, METH_NOARGS, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_34close},
  {"write", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_39write, METH_O, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_38write},
  {"__enter__", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_41__enter__, METH_NOARGS, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_40__enter__},
  {"__exit__", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_43__exit__, METH_VARARGS|METH_KEYWORDS, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_42__exit__},
  {"__next__", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_47__next__, METH_NOARGS|METH_COEXIST, 0},
  {"gettid", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_49gettid, METH_O, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_48gettid},
  {"getrname", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_13AlignmentFile_51getrname, METH_O, __pyx_doc_5pysam_14calignmentfile_13AlignmentFile_50getrname},
  {0, 0, 0, 0}
};

static struct PyGetSetDef __pyx_getsets_5pysam_14calignmentfile_AlignmentFile[] = {
  {(char *)"closed", __pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_closed, 0, (char *)"bool indicating the current state of the file object. \n        This is a read-only attribute; the close() method changes the value. \n        ", 0},
  {(char *)"filename", __pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_filename, 0, (char *)"filename associated with this object. This is a read-only attribute.", 0},
  {(char *)"nreferences", __pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_nreferences, 0, (char *)"\"int with the number of :term:`reference` sequences in the file.\n        This is a read-only attribute.", 0},
  {(char *)"references", __pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_references, 0, (char *)"tuple with the names of :term:`reference` sequences. This is a \n        read-only attribute", 0},
  {(char *)"lengths", __pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_lengths, 0, (char *)"tuple of the lengths of the :term:`reference` sequences. This is a\n        read-only attribute. The lengths are in the same order as\n        :attr:`pysam.AlignmentFile.references`\n\n        ", 0},
  {(char *)"mapped", __pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_mapped, 0, (char *)"int with total number of mapped alignments according to the\n        statistics recorded in the index. This is a read-only\n        attribute.\n        ", 0},
  {(char *)"unmapped", __pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_unmapped, 0, (char *)"int with total number of unmapped reads according to the statistics\n        recorded in the index. This number of reads includes the number of reads\n        without coordinates. This is a read-only attribute.\n        ", 0},
  {(char *)"nocoordinate", __pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_nocoordinate, 0, (char *)"int with total number of reads without coordinates according to the\n        statistics recorded in the index. This is a read-only attribute.\n        ", 0},
  {(char *)"format", __pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_format, 0, (char *)"string describing the file format", 0},
  {(char *)"text", __pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_text, 0, (char *)"string with the full contents of the :term:`sam file` header as a\n        string. \n\n        This is a read-only attribute.\n        \n        See :attr:`pysam.AlignmentFile.header` to get a parsed\n        representation of the header.\n        ", 0},
  {(char *)"header", __pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_header, 0, (char *)"two-level dictionay with header information from the file. \n        \n        This is a read-only attribute.\n\n        The first level contains the record (``HD``, ``SQ``, etc) and\n        the second level contains the fields (``VN``, ``LN``, etc).\n        \n        The parser is validating and will raise an AssertionError if\n        if encounters any record or field tags that are not part of\n        the SAM specification. Use the\n        :attr:`pysam.AlignmentFile.text` attribute to get the unparsed\n        header.\n\n        The parsing follows the SAM format specification with the\n        exception of the ``CL`` field. This option will consume the\n        rest of a header line irrespective of any additional fields.\n        This behaviour has been added to accommodate command line\n        options that contain characters that are not valid field\n        separators.\n\n        ", 0},
  {(char *)"is_bam", __pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_is_bam, 0, (char *)0, 0},
  {(char *)"is_cram", __pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_is_cram, 0, (char *)0, 0},
  {(char *)"is_stream", __pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_is_stream, 0, (char *)0, 0},
  {(char *)"is_remote", __pyx_getprop_5pysam_14calignmentfile_13AlignmentFile_is_remote, 0, (char *)0, 0},
  {0, 0, 0, 0, 0}
};

static PyTypeObject __pyx_type_5pysam_14calignmentfile_AlignmentFile = {
  PyVarObject_HEAD_INIT(0, 0)
  "pysam.calignmentfile.AlignmentFile", /*tp_name*/
  sizeof(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pysam_14calignmentfile_AlignmentFile, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "AlignmentFile(filepath_or_object, mode=None, template=None,\n    reference_names=None, reference_lengths=None, text=NULL,\n    header=None, add_sq_text=False, check_header=True, check_sq=True,\n    filename=None)\n\n    A :term:`SAM`/:term:`BAM` formatted file. \n\n    If `filepath_or_object` is a string, the file is automatically\n    opened. If `filepath_or_object` is a python File object, the\n    already opened file will be used.\n\n    If the file is opened for reading an index for a BAM file exists\n    (.bai), it will be opened automatically. Without an index random\n    access via :meth:`~pysam.AlignmentFile.fetch` and\n    :meth:`~pysam.AlignmentFile.pileup` is disabled.\n\n    For writing, the header of a :term:`SAM` file/:term:`BAM` file can\n    be constituted from several sources (see also the samtools format\n    specification):\n\n        1. If `template` is given, the header is copied from a another\n           `AlignmentFile` (`template` must be a\n           :class:`~pysam.AlignmentFile`).\n\n        2. If `header` is given, the header is built from a\n           multi-level dictionary. \n\n        3. If `text` is given, new header text is copied from raw\n           text.\n\n        4. The names (`reference_names`) and lengths\n           (`reference_lengths`) are supplied directly as lists.\n\n    For writing a CRAM file, the filename of the reference can be \n    added through a fasta formatted file (`reference_filename`)\n\n    By default, if a file is opened in mode 'r', it is checked\n    for a valid header (`check_header` = True) and a definition of\n    chromosome names (`check_sq` = True).\n\n    Parameters\n    ----------\n    mode : string\n        `mode` should be ``r`` for reading or ``w`` for writing. The\n        default is text mode (:term:`SAM`). For binary (:term:`BAM`)\n        I/O you should append ``b`` for compressed or ``u`` for\n        uncompressed :term:`BAM` output.  Use ``h`` to output header\n        information in text"" (:term:`TAM`) mode. Use ``c`` for\n        :term:`CRAM` formatted files.\n\n        If ``b`` is present, it must immediately follow ``r`` or\n        ``w``.  Valid modes are ``r``, ``w``, ``wh``, ``rb``, ``wb``,\n        ``wbu``, ``wb0``, ``rc`` and ``wc``. For instance, to open a\n        :term:`BAM` formatted file for reading, type::\n\n           f = pysam.AlignmentFile('ex1.bam','rb')\n\n        If mode is not specified, the method will try to auto-detect\n        in the order 'rb', 'r', thus both the following should work::\n\n            f1 = pysam.AlignmentFile('ex1.bam')\n            f2 = pysam.AlignmentFile('ex1.sam')\n\n    template : AlignmentFile\n        when writing, copy  header frem `template`.\n\n    header :  dict\n        when writing, build header from a multi-level dictionary. The\n        first level are the four types ('HD', 'SQ', ...). The second\n        level are a list of lines, with each line being a list of\n        tag-value pairs. The header is constructed first from all the\n        defined fields, followed by user tags in alphabetical order.\n\n    text : string\n        when writing, use the string provided as the header\n\n    reference_names : list\n        see referece_lengths\n\n    reference_lengths : list\n        when writing, build header from list of chromosome names and\n        lengths.  By default, 'SQ' and 'LN' tags will be added to the\n        header text. This option can be changed by unsetting the flag\n        `add_sq_text`.\n\n    add_sq_text : bool\n        do not add 'SQ' and 'LN' tags to header. This option permits\n        construction :term:`SAM` formatted files without a header.\n\n    check_header : bool\n        when reading, check if header is present (default=True)\n\n    check_sq : bool\n        when reading, check if SQ entries are present in header\n        (default=True)\n\n    filename : string\n        Alternative to filepath_or_object. Filename of the file\n        to be opened.\n\n    ", /*tp_doc*/
  __pyx_tp_traverse_5pysam_14calignmentfile_AlignmentFile, /*tp_traverse*/
  __pyx_tp_clear_5pysam_14calignmentfile_AlignmentFile, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_45__iter__, /*tp_iter*/
  __pyx_pw_5pysam_14calignmentfile_13AlignmentFile_47__next__, /*tp_iternext*/
  __pyx_methods_5pysam_14calignmentfile_AlignmentFile, /*tp_methods*/
  0, /*tp_members*/
  __pyx_getsets_5pysam_14calignmentfile_AlignmentFile, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pysam_14calignmentfile_AlignmentFile, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_5pysam_14calignmentfile_PileupColumn(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  return o;
}

static void __pyx_tp_dealloc_5pysam_14calignmentfile_PileupColumn(PyObject *o) {
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  (*Py_TYPE(o)->tp_free)(o);
}

static PyTypeObject __pyx_type_5pysam_14calignmentfile_PileupColumn = {
  PyVarObject_HEAD_INIT(0, 0)
  "pysam.calignmentfile.PileupColumn", /*tp_name*/
  sizeof(struct __pyx_obj_5pysam_14calignmentfile_PileupColumn), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pysam_14calignmentfile_PileupColumn, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  0, /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pysam_14calignmentfile_PileupColumn, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_5pysam_14calignmentfile_PileupRead(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_5pysam_14calignmentfile_PileupRead *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_5pysam_14calignmentfile_PileupRead *)o);
  p->_alignment = ((struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *)Py_None); Py_INCREF(Py_None);
  return o;
}

static void __pyx_tp_dealloc_5pysam_14calignmentfile_PileupRead(PyObject *o) {
  struct __pyx_obj_5pysam_14calignmentfile_PileupRead *p = (struct __pyx_obj_5pysam_14calignmentfile_PileupRead *)o;
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->_alignment);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_5pysam_14calignmentfile_PileupRead(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_5pysam_14calignmentfile_PileupRead *p = (struct __pyx_obj_5pysam_14calignmentfile_PileupRead *)o;
  if (p->_alignment) {
    e = (*v)(((PyObject*)p->_alignment), a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_5pysam_14calignmentfile_PileupRead(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_5pysam_14calignmentfile_PileupRead *p = (struct __pyx_obj_5pysam_14calignmentfile_PileupRead *)o;
  tmp = ((PyObject*)p->_alignment);
  p->_alignment = ((struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyTypeObject __pyx_type_5pysam_14calignmentfile_PileupRead = {
  PyVarObject_HEAD_INIT(0, 0)
  "pysam.calignmentfile.PileupRead", /*tp_name*/
  sizeof(struct __pyx_obj_5pysam_14calignmentfile_PileupRead), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pysam_14calignmentfile_PileupRead, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  0, /*tp_doc*/
  __pyx_tp_traverse_5pysam_14calignmentfile_PileupRead, /*tp_traverse*/
  __pyx_tp_clear_5pysam_14calignmentfile_PileupRead, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  0, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pysam_14calignmentfile_PileupRead, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_5pysam_14calignmentfile_IteratorRow(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRow *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_5pysam_14calignmentfile_IteratorRow *)o);
  p->samfile = ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)Py_None); Py_INCREF(Py_None);
  return o;
}

static void __pyx_tp_dealloc_5pysam_14calignmentfile_IteratorRow(PyObject *o) {
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRow *p = (struct __pyx_obj_5pysam_14calignmentfile_IteratorRow *)o;
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_5pysam_14calignmentfile_11IteratorRow_3__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  Py_CLEAR(p->samfile);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_5pysam_14calignmentfile_IteratorRow(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRow *p = (struct __pyx_obj_5pysam_14calignmentfile_IteratorRow *)o;
  if (p->samfile) {
    e = (*v)(((PyObject*)p->samfile), a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_5pysam_14calignmentfile_IteratorRow(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRow *p = (struct __pyx_obj_5pysam_14calignmentfile_IteratorRow *)o;
  tmp = ((PyObject*)p->samfile);
  p->samfile = ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyMethodDef __pyx_methods_5pysam_14calignmentfile_IteratorRow[] = {
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_5pysam_14calignmentfile_IteratorRow = {
  PyVarObject_HEAD_INIT(0, 0)
  "pysam.calignmentfile.IteratorRow", /*tp_name*/
  sizeof(struct __pyx_obj_5pysam_14calignmentfile_IteratorRow), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pysam_14calignmentfile_IteratorRow, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "IteratorRow(AlignmentFile samfile, int multiple_iterators=False)\nabstract base class for iterators over mapped reads.\n\n    Various iterators implement different behaviours for wrapping around\n    contig boundaries. Examples include:\n\n    :class:`pysam.IteratorRowRegion`\n        iterate within a single contig and a defined region.\n\n    :class:`pysam.IteratorRowAll`\n        iterate until EOF. This iterator will also include unmapped reads.\n\n    :class:`pysam.IteratorRowAllRefs`\n        iterate over all reads in all reference sequences.\n\n    The method :meth:`AlignmentFile.fetch` returns an IteratorRow.\n\n    .. note::\n\n        It is usually not necessary to create an object of this class\n        explicitly. It is returned as a result of call to a\n        :meth:`AlignmentFile.fetch`.\n\n    ", /*tp_doc*/
  __pyx_tp_traverse_5pysam_14calignmentfile_IteratorRow, /*tp_traverse*/
  __pyx_tp_clear_5pysam_14calignmentfile_IteratorRow, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_5pysam_14calignmentfile_IteratorRow, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_5pysam_14calignmentfile_11IteratorRow_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pysam_14calignmentfile_IteratorRow, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorRowRegion __pyx_vtable_5pysam_14calignmentfile_IteratorRowRegion;

static PyObject *__pyx_tp_new_5pysam_14calignmentfile_IteratorRowRegion(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *p;
  PyObject *o = __pyx_tp_new_5pysam_14calignmentfile_IteratorRow(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *)o);
  p->__pyx_vtab = __pyx_vtabptr_5pysam_14calignmentfile_IteratorRowRegion;
  return o;
}

static void __pyx_tp_dealloc_5pysam_14calignmentfile_IteratorRowRegion(PyObject *o) {
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_5pysam_14calignmentfile_17IteratorRowRegion_7__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  PyObject_GC_Track(o);
  __pyx_tp_dealloc_5pysam_14calignmentfile_IteratorRow(o);
}

static PyMethodDef __pyx_methods_5pysam_14calignmentfile_IteratorRowRegion[] = {
  {"__next__", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_17IteratorRowRegion_5__next__, METH_NOARGS|METH_COEXIST, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_5pysam_14calignmentfile_IteratorRowRegion = {
  PyVarObject_HEAD_INIT(0, 0)
  "pysam.calignmentfile.IteratorRowRegion", /*tp_name*/
  sizeof(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pysam_14calignmentfile_IteratorRowRegion, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "IteratorRowRegion(AlignmentFile samfile, int tid, int beg, int end, int multiple_iterators=False)\n*(AlignmentFile samfile, int tid, int beg, int end,\n    int multiple_iterators=False)*\n\n    iterate over mapped reads in a region.\n\n    .. note::\n\n        It is usually not necessary to create an object of this class\n        explicitly. It is returned as a result of call to a\n        :meth:`AlignmentFile.fetch`.\n\n    ", /*tp_doc*/
  __pyx_tp_traverse_5pysam_14calignmentfile_IteratorRow, /*tp_traverse*/
  __pyx_tp_clear_5pysam_14calignmentfile_IteratorRow, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_pw_5pysam_14calignmentfile_17IteratorRowRegion_3__iter__, /*tp_iter*/
  __pyx_pw_5pysam_14calignmentfile_17IteratorRowRegion_5__next__, /*tp_iternext*/
  __pyx_methods_5pysam_14calignmentfile_IteratorRowRegion, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_5pysam_14calignmentfile_17IteratorRowRegion_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pysam_14calignmentfile_IteratorRowRegion, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorRowHead __pyx_vtable_5pysam_14calignmentfile_IteratorRowHead;

static PyObject *__pyx_tp_new_5pysam_14calignmentfile_IteratorRowHead(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead *p;
  PyObject *o = __pyx_tp_new_5pysam_14calignmentfile_IteratorRow(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead *)o);
  p->__pyx_vtab = __pyx_vtabptr_5pysam_14calignmentfile_IteratorRowHead;
  return o;
}

static PyMethodDef __pyx_methods_5pysam_14calignmentfile_IteratorRowHead[] = {
  {"__next__", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_15IteratorRowHead_5__next__, METH_NOARGS|METH_COEXIST, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_5pysam_14calignmentfile_IteratorRowHead = {
  PyVarObject_HEAD_INIT(0, 0)
  "pysam.calignmentfile.IteratorRowHead", /*tp_name*/
  sizeof(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pysam_14calignmentfile_IteratorRow, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "IteratorRowHead(AlignmentFile samfile, int n, int multiple_iterators=False)\n*(AlignmentFile samfile, n, int multiple_iterators=False)*\n\n    iterate over first n reads in `samfile`\n\n    .. note::\n        It is usually not necessary to create an object of this class\n        explicitly. It is returned as a result of call to a\n        :meth:`AlignmentFile.head`.\n\n    ", /*tp_doc*/
  __pyx_tp_traverse_5pysam_14calignmentfile_IteratorRow, /*tp_traverse*/
  __pyx_tp_clear_5pysam_14calignmentfile_IteratorRow, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_pw_5pysam_14calignmentfile_15IteratorRowHead_3__iter__, /*tp_iter*/
  __pyx_pw_5pysam_14calignmentfile_15IteratorRowHead_5__next__, /*tp_iternext*/
  __pyx_methods_5pysam_14calignmentfile_IteratorRowHead, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_5pysam_14calignmentfile_15IteratorRowHead_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pysam_14calignmentfile_IteratorRowHead, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorRowAll __pyx_vtable_5pysam_14calignmentfile_IteratorRowAll;

static PyObject *__pyx_tp_new_5pysam_14calignmentfile_IteratorRowAll(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll *p;
  PyObject *o = __pyx_tp_new_5pysam_14calignmentfile_IteratorRow(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll *)o);
  p->__pyx_vtab = __pyx_vtabptr_5pysam_14calignmentfile_IteratorRowAll;
  return o;
}

static PyMethodDef __pyx_methods_5pysam_14calignmentfile_IteratorRowAll[] = {
  {"__next__", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_14IteratorRowAll_5__next__, METH_NOARGS|METH_COEXIST, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_5pysam_14calignmentfile_IteratorRowAll = {
  PyVarObject_HEAD_INIT(0, 0)
  "pysam.calignmentfile.IteratorRowAll", /*tp_name*/
  sizeof(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pysam_14calignmentfile_IteratorRow, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "IteratorRowAll(AlignmentFile samfile, int multiple_iterators=False)\n*(AlignmentFile samfile, int multiple_iterators=False)*\n\n    iterate over all reads in `samfile`\n\n    .. note::\n\n        It is usually not necessary to create an object of this class\n        explicitly. It is returned as a result of call to a\n        :meth:`AlignmentFile.fetch`.\n\n    ", /*tp_doc*/
  __pyx_tp_traverse_5pysam_14calignmentfile_IteratorRow, /*tp_traverse*/
  __pyx_tp_clear_5pysam_14calignmentfile_IteratorRow, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_pw_5pysam_14calignmentfile_14IteratorRowAll_3__iter__, /*tp_iter*/
  __pyx_pw_5pysam_14calignmentfile_14IteratorRowAll_5__next__, /*tp_iternext*/
  __pyx_methods_5pysam_14calignmentfile_IteratorRowAll, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_5pysam_14calignmentfile_14IteratorRowAll_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pysam_14calignmentfile_IteratorRowAll, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_5pysam_14calignmentfile_IteratorRowAllRefs(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs *p;
  PyObject *o = __pyx_tp_new_5pysam_14calignmentfile_IteratorRow(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs *)o);
  p->rowiter = ((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *)Py_None); Py_INCREF(Py_None);
  return o;
}

static void __pyx_tp_dealloc_5pysam_14calignmentfile_IteratorRowAllRefs(PyObject *o) {
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs *p = (struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs *)o;
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->rowiter);
  PyObject_GC_Track(o);
  __pyx_tp_dealloc_5pysam_14calignmentfile_IteratorRow(o);
}

static int __pyx_tp_traverse_5pysam_14calignmentfile_IteratorRowAllRefs(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs *p = (struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs *)o;
  e = __pyx_tp_traverse_5pysam_14calignmentfile_IteratorRow(o, v, a); if (e) return e;
  if (p->rowiter) {
    e = (*v)(((PyObject*)p->rowiter), a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_5pysam_14calignmentfile_IteratorRowAllRefs(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs *p = (struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs *)o;
  __pyx_tp_clear_5pysam_14calignmentfile_IteratorRow(o);
  tmp = ((PyObject*)p->rowiter);
  p->rowiter = ((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyMethodDef __pyx_methods_5pysam_14calignmentfile_IteratorRowAllRefs[] = {
  {"nextiter", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_18IteratorRowAllRefs_3nextiter, METH_NOARGS, __pyx_doc_5pysam_14calignmentfile_18IteratorRowAllRefs_2nextiter},
  {"__next__", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_18IteratorRowAllRefs_7__next__, METH_NOARGS|METH_COEXIST, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_5pysam_14calignmentfile_IteratorRowAllRefs = {
  PyVarObject_HEAD_INIT(0, 0)
  "pysam.calignmentfile.IteratorRowAllRefs", /*tp_name*/
  sizeof(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAllRefs), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pysam_14calignmentfile_IteratorRowAllRefs, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "IteratorRowAllRefs(AlignmentFile samfile, multiple_iterators=False)\niterates over all mapped reads by chaining iterators over each\n    reference\n\n    .. note::\n        It is usually not necessary to create an object of this class\n        explicitly. It is returned as a result of call to a\n        :meth:`AlignmentFile.fetch`.\n\n    ", /*tp_doc*/
  __pyx_tp_traverse_5pysam_14calignmentfile_IteratorRowAllRefs, /*tp_traverse*/
  __pyx_tp_clear_5pysam_14calignmentfile_IteratorRowAllRefs, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_pw_5pysam_14calignmentfile_18IteratorRowAllRefs_5__iter__, /*tp_iter*/
  __pyx_pw_5pysam_14calignmentfile_18IteratorRowAllRefs_7__next__, /*tp_iternext*/
  __pyx_methods_5pysam_14calignmentfile_IteratorRowAllRefs, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_5pysam_14calignmentfile_18IteratorRowAllRefs_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pysam_14calignmentfile_IteratorRowAllRefs, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorRowSelection __pyx_vtable_5pysam_14calignmentfile_IteratorRowSelection;

static PyObject *__pyx_tp_new_5pysam_14calignmentfile_IteratorRowSelection(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *p;
  PyObject *o = __pyx_tp_new_5pysam_14calignmentfile_IteratorRow(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *)o);
  p->__pyx_vtab = __pyx_vtabptr_5pysam_14calignmentfile_IteratorRowSelection;
  p->positions = Py_None; Py_INCREF(Py_None);
  return o;
}

static void __pyx_tp_dealloc_5pysam_14calignmentfile_IteratorRowSelection(PyObject *o) {
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *p = (struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *)o;
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  Py_CLEAR(p->positions);
  PyObject_GC_Track(o);
  __pyx_tp_dealloc_5pysam_14calignmentfile_IteratorRow(o);
}

static int __pyx_tp_traverse_5pysam_14calignmentfile_IteratorRowSelection(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *p = (struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *)o;
  e = __pyx_tp_traverse_5pysam_14calignmentfile_IteratorRow(o, v, a); if (e) return e;
  if (p->positions) {
    e = (*v)(p->positions, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_5pysam_14calignmentfile_IteratorRowSelection(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *p = (struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *)o;
  __pyx_tp_clear_5pysam_14calignmentfile_IteratorRow(o);
  tmp = ((PyObject*)p->positions);
  p->positions = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyMethodDef __pyx_methods_5pysam_14calignmentfile_IteratorRowSelection[] = {
  {"__next__", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_20IteratorRowSelection_5__next__, METH_NOARGS|METH_COEXIST, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_5pysam_14calignmentfile_IteratorRowSelection = {
  PyVarObject_HEAD_INIT(0, 0)
  "pysam.calignmentfile.IteratorRowSelection", /*tp_name*/
  sizeof(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pysam_14calignmentfile_IteratorRowSelection, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "IteratorRowSelection(AlignmentFile samfile, positions, int multiple_iterators=True)\n*(AlignmentFile samfile)*\n\n    iterate over reads in `samfile` at a given list of file positions.\n\n    .. note::\n        It is usually not necessary to create an object of this class\n        explicitly. It is returned as a result of call to a :meth:`AlignmentFile.fetch`.\n    ", /*tp_doc*/
  __pyx_tp_traverse_5pysam_14calignmentfile_IteratorRowSelection, /*tp_traverse*/
  __pyx_tp_clear_5pysam_14calignmentfile_IteratorRowSelection, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_pw_5pysam_14calignmentfile_20IteratorRowSelection_3__iter__, /*tp_iter*/
  __pyx_pw_5pysam_14calignmentfile_20IteratorRowSelection_5__next__, /*tp_iternext*/
  __pyx_methods_5pysam_14calignmentfile_IteratorRowSelection, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_5pysam_14calignmentfile_20IteratorRowSelection_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pysam_14calignmentfile_IteratorRowSelection, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorColumn __pyx_vtable_5pysam_14calignmentfile_IteratorColumn;

static PyObject *__pyx_tp_new_5pysam_14calignmentfile_IteratorColumn(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *)o);
  p->__pyx_vtab = __pyx_vtabptr_5pysam_14calignmentfile_IteratorColumn;
  p->iter = ((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *)Py_None); Py_INCREF(Py_None);
  p->samfile = ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)Py_None); Py_INCREF(Py_None);
  p->fastafile = ((struct __pyx_obj_5pysam_6cfaidx_Fastafile *)Py_None); Py_INCREF(Py_None);
  p->stepper = Py_None; Py_INCREF(Py_None);
  if (unlikely(__pyx_pw_5pysam_14calignmentfile_14IteratorColumn_1__cinit__(o, a, k) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_5pysam_14calignmentfile_IteratorColumn(PyObject *o) {
  struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *p = (struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *)o;
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_5pysam_14calignmentfile_14IteratorColumn_9__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  Py_CLEAR(p->iter);
  Py_CLEAR(p->samfile);
  Py_CLEAR(p->fastafile);
  Py_CLEAR(p->stepper);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_5pysam_14calignmentfile_IteratorColumn(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *p = (struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *)o;
  if (p->iter) {
    e = (*v)(((PyObject*)p->iter), a); if (e) return e;
  }
  if (p->samfile) {
    e = (*v)(((PyObject*)p->samfile), a); if (e) return e;
  }
  if (p->fastafile) {
    e = (*v)(((PyObject*)p->fastafile), a); if (e) return e;
  }
  if (p->stepper) {
    e = (*v)(p->stepper, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_5pysam_14calignmentfile_IteratorColumn(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *p = (struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *)o;
  tmp = ((PyObject*)p->iter);
  p->iter = ((struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->samfile);
  p->samfile = ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->fastafile);
  p->fastafile = ((struct __pyx_obj_5pysam_6cfaidx_Fastafile *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->stepper);
  p->stepper = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_14IteratorColumn_seq_len(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_14IteratorColumn_7seq_len_1__get__(o);
}

static PyMethodDef __pyx_methods_5pysam_14calignmentfile_IteratorColumn[] = {
  {"addReference", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_14IteratorColumn_5addReference, METH_O, __pyx_doc_5pysam_14calignmentfile_14IteratorColumn_4addReference},
  {"hasReference", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_14IteratorColumn_7hasReference, METH_NOARGS, __pyx_doc_5pysam_14calignmentfile_14IteratorColumn_6hasReference},
  {0, 0, 0, 0}
};

static struct PyGetSetDef __pyx_getsets_5pysam_14calignmentfile_IteratorColumn[] = {
  {(char *)"seq_len", __pyx_getprop_5pysam_14calignmentfile_14IteratorColumn_seq_len, 0, (char *)"current sequence length.", 0},
  {0, 0, 0, 0, 0}
};

static PyTypeObject __pyx_type_5pysam_14calignmentfile_IteratorColumn = {
  PyVarObject_HEAD_INIT(0, 0)
  "pysam.calignmentfile.IteratorColumn", /*tp_name*/
  sizeof(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pysam_14calignmentfile_IteratorColumn, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "abstract base class for iterators over columns.\n\n    IteratorColumn objects wrap the pileup functionality of samtools.\n\n    For reasons of efficiency, the iterator points to the current\n    pileup buffer. The pileup buffer is updated at every iteration.\n    This might cause some unexpected behavious. For example,\n    consider the conversion to a list::\n\n       f = AlignmentFile(\"file.bam\", \"rb\")\n       result = list( f.pileup() )\n\n    Here, ``result`` will contain ``n`` objects of type\n    :class:`~pysam.PileupColumn` for ``n`` columns, but each object in\n    ``result`` will contain the same information.\n\n    The desired behaviour can be achieved by list comprehension::\n\n       result = [ x.pileups() for x in f.pileup() ]\n\n    ``result`` will be a list of ``n`` lists of objects of type\n    :class:`~pysam.PileupRead`.\n\n    If the iterator is associated with a :class:`~pysam.Fastafile` using the\n    :meth:`addReference` method, then the iterator will export the\n    current sequence via the methods :meth:`getSequence` and\n    :meth:`seq_len`.\n\n    Optional kwargs to the iterator:\n\n    stepper\n       The stepper controls how the iterator advances.\n\n       Valid values are None, \"all\" (default), \"nofilter\" or \"samtools\".\n\n       See AlignmentFile.pileup for description.\n    \n    fastafile\n       A :class:`~pysam.FastaFile` object\n\n    max_depth\n       maximum read depth. The default is 8000.\n\n    ", /*tp_doc*/
  __pyx_tp_traverse_5pysam_14calignmentfile_IteratorColumn, /*tp_traverse*/
  __pyx_tp_clear_5pysam_14calignmentfile_IteratorColumn, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_pw_5pysam_14calignmentfile_14IteratorColumn_3__iter__, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_5pysam_14calignmentfile_IteratorColumn, /*tp_methods*/
  0, /*tp_members*/
  __pyx_getsets_5pysam_14calignmentfile_IteratorColumn, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pysam_14calignmentfile_IteratorColumn, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorColumnRegion __pyx_vtable_5pysam_14calignmentfile_IteratorColumnRegion;

static PyObject *__pyx_tp_new_5pysam_14calignmentfile_IteratorColumnRegion(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnRegion *p;
  PyObject *o = __pyx_tp_new_5pysam_14calignmentfile_IteratorColumn(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnRegion *)o);
  p->__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorColumn*)__pyx_vtabptr_5pysam_14calignmentfile_IteratorColumnRegion;
  if (unlikely(__pyx_pw_5pysam_14calignmentfile_20IteratorColumnRegion_1__cinit__(o, a, k) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static PyMethodDef __pyx_methods_5pysam_14calignmentfile_IteratorColumnRegion[] = {
  {"__next__", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_20IteratorColumnRegion_3__next__, METH_NOARGS|METH_COEXIST, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_5pysam_14calignmentfile_IteratorColumnRegion = {
  PyVarObject_HEAD_INIT(0, 0)
  "pysam.calignmentfile.IteratorColumnRegion", /*tp_name*/
  sizeof(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnRegion), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pysam_14calignmentfile_IteratorColumn, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "iterates over a region only.\n    ", /*tp_doc*/
  __pyx_tp_traverse_5pysam_14calignmentfile_IteratorColumn, /*tp_traverse*/
  __pyx_tp_clear_5pysam_14calignmentfile_IteratorColumn, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_5pysam_14calignmentfile_14IteratorColumn_3__iter__, /*tp_iter*/
  #else
  0, /*tp_iter*/
  #endif
  __pyx_pw_5pysam_14calignmentfile_20IteratorColumnRegion_3__next__, /*tp_iternext*/
  __pyx_methods_5pysam_14calignmentfile_IteratorColumnRegion, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pysam_14calignmentfile_IteratorColumnRegion, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};
static struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorColumnAllRefs __pyx_vtable_5pysam_14calignmentfile_IteratorColumnAllRefs;

static PyObject *__pyx_tp_new_5pysam_14calignmentfile_IteratorColumnAllRefs(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnAllRefs *p;
  PyObject *o = __pyx_tp_new_5pysam_14calignmentfile_IteratorColumn(t, a, k);
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnAllRefs *)o);
  p->__pyx_base.__pyx_vtab = (struct __pyx_vtabstruct_5pysam_14calignmentfile_IteratorColumn*)__pyx_vtabptr_5pysam_14calignmentfile_IteratorColumnAllRefs;
  if (unlikely(__pyx_pw_5pysam_14calignmentfile_21IteratorColumnAllRefs_1__cinit__(o, a, k) < 0)) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static PyMethodDef __pyx_methods_5pysam_14calignmentfile_IteratorColumnAllRefs[] = {
  {"__next__", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_21IteratorColumnAllRefs_3__next__, METH_NOARGS|METH_COEXIST, 0},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_5pysam_14calignmentfile_IteratorColumnAllRefs = {
  PyVarObject_HEAD_INIT(0, 0)
  "pysam.calignmentfile.IteratorColumnAllRefs", /*tp_name*/
  sizeof(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumnAllRefs), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pysam_14calignmentfile_IteratorColumn, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "iterates over all columns by chaining iterators over each reference\n    ", /*tp_doc*/
  __pyx_tp_traverse_5pysam_14calignmentfile_IteratorColumn, /*tp_traverse*/
  __pyx_tp_clear_5pysam_14calignmentfile_IteratorColumn, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  #if CYTHON_COMPILING_IN_PYPY
  __pyx_pw_5pysam_14calignmentfile_14IteratorColumn_3__iter__, /*tp_iter*/
  #else
  0, /*tp_iter*/
  #endif
  __pyx_pw_5pysam_14calignmentfile_21IteratorColumnAllRefs_3__next__, /*tp_iternext*/
  __pyx_methods_5pysam_14calignmentfile_IteratorColumnAllRefs, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pysam_14calignmentfile_IteratorColumnAllRefs, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_5pysam_14calignmentfile_IndexedReads(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  struct __pyx_obj_5pysam_14calignmentfile_IndexedReads *p;
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  p = ((struct __pyx_obj_5pysam_14calignmentfile_IndexedReads *)o);
  p->samfile = ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)Py_None); Py_INCREF(Py_None);
  p->index = Py_None; Py_INCREF(Py_None);
  return o;
}

static void __pyx_tp_dealloc_5pysam_14calignmentfile_IndexedReads(PyObject *o) {
  struct __pyx_obj_5pysam_14calignmentfile_IndexedReads *p = (struct __pyx_obj_5pysam_14calignmentfile_IndexedReads *)o;
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && !_PyGC_FINALIZED(o)) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  PyObject_GC_UnTrack(o);
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pw_5pysam_14calignmentfile_12IndexedReads_7__dealloc__(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  Py_CLEAR(p->samfile);
  Py_CLEAR(p->index);
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_5pysam_14calignmentfile_IndexedReads(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_5pysam_14calignmentfile_IndexedReads *p = (struct __pyx_obj_5pysam_14calignmentfile_IndexedReads *)o;
  if (p->samfile) {
    e = (*v)(((PyObject*)p->samfile), a); if (e) return e;
  }
  if (p->index) {
    e = (*v)(p->index, a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_5pysam_14calignmentfile_IndexedReads(PyObject *o) {
  PyObject* tmp;
  struct __pyx_obj_5pysam_14calignmentfile_IndexedReads *p = (struct __pyx_obj_5pysam_14calignmentfile_IndexedReads *)o;
  tmp = ((PyObject*)p->samfile);
  p->samfile = ((struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  tmp = ((PyObject*)p->index);
  p->index = Py_None; Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyMethodDef __pyx_methods_5pysam_14calignmentfile_IndexedReads[] = {
  {"build", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_12IndexedReads_3build, METH_NOARGS, __pyx_doc_5pysam_14calignmentfile_12IndexedReads_2build},
  {"find", (PyCFunction)__pyx_pw_5pysam_14calignmentfile_12IndexedReads_5find, METH_O, __pyx_doc_5pysam_14calignmentfile_12IndexedReads_4find},
  {0, 0, 0, 0}
};

static PyTypeObject __pyx_type_5pysam_14calignmentfile_IndexedReads = {
  PyVarObject_HEAD_INIT(0, 0)
  "pysam.calignmentfile.IndexedReads", /*tp_name*/
  sizeof(struct __pyx_obj_5pysam_14calignmentfile_IndexedReads), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pysam_14calignmentfile_IndexedReads, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  "IndexedReads(AlignmentFile samfile, int multiple_iterators=True)\n*(AlignmentFile samfile, multiple_iterators=True)\n\n    Index a Sam/BAM-file by query name while keeping the\n    original sort order intact.\n\n    The index is kept in memory and can be substantial.\n\n    By default, the file is re-openend to avoid conflicts if multiple\n    operators work on the same file. Set `multiple_iterators` = False\n    to not re-open `samfile`.\n\n    Parameters\n    ----------\n\n    samfile : AlignmentFile\n        File to be indexed.\n\n    multiple_iterators : bool\n        Flag indicating whether the file should be reopened. Reopening prevents\n        existing iterators being affected by the indexing.\n\n    ", /*tp_doc*/
  __pyx_tp_traverse_5pysam_14calignmentfile_IndexedReads, /*tp_traverse*/
  __pyx_tp_clear_5pysam_14calignmentfile_IndexedReads, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_5pysam_14calignmentfile_IndexedReads, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pw_5pysam_14calignmentfile_12IndexedReads_1__init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pysam_14calignmentfile_IndexedReads, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyObject *__pyx_tp_new_5pysam_14calignmentfile_SNPCall(PyTypeObject *t, CYTHON_UNUSED PyObject *a, CYTHON_UNUSED PyObject *k) {
  PyObject *o;
  if (likely((t->tp_flags & Py_TPFLAGS_IS_ABSTRACT) == 0)) {
    o = (*t->tp_alloc)(t, 0);
  } else {
    o = (PyObject *) PyBaseObject_Type.tp_new(t, __pyx_empty_tuple, 0);
  }
  if (unlikely(!o)) return 0;
  return o;
}

static void __pyx_tp_dealloc_5pysam_14calignmentfile_SNPCall(PyObject *o) {
  #if PY_VERSION_HEX >= 0x030400a1
  if (unlikely(Py_TYPE(o)->tp_finalize) && (!PyType_IS_GC(Py_TYPE(o)) || !_PyGC_FINALIZED(o))) {
    if (PyObject_CallFinalizerFromDealloc(o)) return;
  }
  #endif
  (*Py_TYPE(o)->tp_free)(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_7SNPCall_tid(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_7SNPCall_3tid_1__get__(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_7SNPCall_pos(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_7SNPCall_3pos_1__get__(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_7SNPCall_reference_base(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_7SNPCall_14reference_base_1__get__(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_7SNPCall_genotype(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_7SNPCall_8genotype_1__get__(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_7SNPCall_consensus_quality(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_7SNPCall_17consensus_quality_1__get__(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_7SNPCall_snp_quality(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_7SNPCall_11snp_quality_1__get__(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_7SNPCall_mapping_quality(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_7SNPCall_15mapping_quality_1__get__(o);
}

static PyObject *__pyx_getprop_5pysam_14calignmentfile_7SNPCall_coverage(PyObject *o, CYTHON_UNUSED void *x) {
  return __pyx_pw_5pysam_14calignmentfile_7SNPCall_8coverage_1__get__(o);
}

static PyMethodDef __pyx_methods_5pysam_14calignmentfile_SNPCall[] = {
  {0, 0, 0, 0}
};

static struct PyGetSetDef __pyx_getsets_5pysam_14calignmentfile_SNPCall[] = {
  {(char *)"tid", __pyx_getprop_5pysam_14calignmentfile_7SNPCall_tid, 0, (char *)"the chromosome ID as is defined in the header", 0},
  {(char *)"pos", __pyx_getprop_5pysam_14calignmentfile_7SNPCall_pos, 0, (char *)"nucleotide position of SNP.", 0},
  {(char *)"reference_base", __pyx_getprop_5pysam_14calignmentfile_7SNPCall_reference_base, 0, (char *)"reference base at pos. ``N`` if no reference sequence supplied.", 0},
  {(char *)"genotype", __pyx_getprop_5pysam_14calignmentfile_7SNPCall_genotype, 0, (char *)"the genotype called.", 0},
  {(char *)"consensus_quality", __pyx_getprop_5pysam_14calignmentfile_7SNPCall_consensus_quality, 0, (char *)"the genotype quality (Phred-scaled).", 0},
  {(char *)"snp_quality", __pyx_getprop_5pysam_14calignmentfile_7SNPCall_snp_quality, 0, (char *)"the snp quality (Phred scaled) - probability of consensus being\n       identical to reference sequence.", 0},
  {(char *)"mapping_quality", __pyx_getprop_5pysam_14calignmentfile_7SNPCall_mapping_quality, 0, (char *)"the root mean square (rms) of the mapping quality of all reads\n       involved in the call.", 0},
  {(char *)"coverage", __pyx_getprop_5pysam_14calignmentfile_7SNPCall_coverage, 0, (char *)"coverage or read depth - the number of reads involved in the call.", 0},
  {0, 0, 0, 0, 0}
};

static PyTypeObject __pyx_type_5pysam_14calignmentfile_SNPCall = {
  PyVarObject_HEAD_INIT(0, 0)
  "pysam.calignmentfile.SNPCall", /*tp_name*/
  sizeof(struct __pyx_obj_5pysam_14calignmentfile_SNPCall), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_5pysam_14calignmentfile_SNPCall, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #endif
  #if PY_MAJOR_VERSION >= 3
  0, /*tp_as_async*/
  #endif
  0, /*tp_repr*/
  0, /*tp_as_number*/
  0, /*tp_as_sequence*/
  0, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  __pyx_pw_5pysam_14calignmentfile_7SNPCall_1__str__, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  0, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_HAVE_VERSION_TAG|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  "the results of a SNP call.", /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  0, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_5pysam_14calignmentfile_SNPCall, /*tp_methods*/
  0, /*tp_members*/
  __pyx_getsets_5pysam_14calignmentfile_SNPCall, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_5pysam_14calignmentfile_SNPCall, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  0, /*tp_version_tag*/
  #if PY_VERSION_HEX >= 0x030400a1
  0, /*tp_finalize*/
  #endif
};

static PyMethodDef __pyx_methods[] = {
  {0, 0, 0, 0}
};

#if PY_MAJOR_VERSION >= 3
static struct PyModuleDef __pyx_moduledef = {
  #if PY_VERSION_HEX < 0x03020000
    { PyObject_HEAD_INIT(NULL) NULL, 0, NULL },
  #else
    PyModuleDef_HEAD_INIT,
  #endif
    "calignmentfile",
    0, /* m_doc */
    -1, /* m_size */
    __pyx_methods /* m_methods */,
    NULL, /* m_reload */
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_n_s_A, __pyx_k_A, sizeof(__pyx_k_A), 0, 0, 1, 1},
  {&__pyx_n_s_AS, __pyx_k_AS, sizeof(__pyx_k_AS), 0, 0, 1, 1},
  {&__pyx_n_s_AlignmentFile, __pyx_k_AlignmentFile, sizeof(__pyx_k_AlignmentFile), 0, 0, 1, 1},
  {&__pyx_kp_s_AlignmentFile_mapped_only_availa, __pyx_k_AlignmentFile_mapped_only_availa, sizeof(__pyx_k_AlignmentFile_mapped_only_availa), 0, 0, 1, 0},
  {&__pyx_n_s_AttributeError, __pyx_k_AttributeError, sizeof(__pyx_k_AttributeError), 0, 0, 1, 1},
  {&__pyx_n_s_C, __pyx_k_C, sizeof(__pyx_k_C), 0, 0, 1, 1},
  {&__pyx_n_s_CL, __pyx_k_CL, sizeof(__pyx_k_CL), 0, 0, 1, 1},
  {&__pyx_n_s_CN, __pyx_k_CN, sizeof(__pyx_k_CN), 0, 0, 1, 1},
  {&__pyx_n_s_CO, __pyx_k_CO, sizeof(__pyx_k_CO), 0, 0, 1, 1},
  {&__pyx_n_s_DS, __pyx_k_DS, sizeof(__pyx_k_DS), 0, 0, 1, 1},
  {&__pyx_n_s_DT, __pyx_k_DT, sizeof(__pyx_k_DT), 0, 0, 1, 1},
  {&__pyx_n_s_FO, __pyx_k_FO, sizeof(__pyx_k_FO), 0, 0, 1, 1},
  {&__pyx_n_s_G, __pyx_k_G, sizeof(__pyx_k_G), 0, 0, 1, 1},
  {&__pyx_n_s_GO, __pyx_k_GO, sizeof(__pyx_k_GO), 0, 0, 1, 1},
  {&__pyx_n_s_HD, __pyx_k_HD, sizeof(__pyx_k_HD), 0, 0, 1, 1},
  {&__pyx_n_s_ID, __pyx_k_ID, sizeof(__pyx_k_ID), 0, 0, 1, 1},
  {&__pyx_n_s_IOError, __pyx_k_IOError, sizeof(__pyx_k_IOError), 0, 0, 1, 1},
  {&__pyx_kp_s_I_O_operation_on_closed_file, __pyx_k_I_O_operation_on_closed_file, sizeof(__pyx_k_I_O_operation_on_closed_file), 0, 0, 1, 0},
  {&__pyx_n_s_IndexedReads, __pyx_k_IndexedReads, sizeof(__pyx_k_IndexedReads), 0, 0, 1, 1},
  {&__pyx_n_s_IteratorColumn, __pyx_k_IteratorColumn, sizeof(__pyx_k_IteratorColumn), 0, 0, 1, 1},
  {&__pyx_n_s_IteratorRow, __pyx_k_IteratorRow, sizeof(__pyx_k_IteratorRow), 0, 0, 1, 1},
  {&__pyx_n_s_KNOWN_HEADER_FIELDS, __pyx_k_KNOWN_HEADER_FIELDS, sizeof(__pyx_k_KNOWN_HEADER_FIELDS), 0, 0, 1, 1},
  {&__pyx_n_s_KS, __pyx_k_KS, sizeof(__pyx_k_KS), 0, 0, 1, 1},
  {&__pyx_n_s_KeyError, __pyx_k_KeyError, sizeof(__pyx_k_KeyError), 0, 0, 1, 1},
  {&__pyx_n_s_L, __pyx_k_L, sizeof(__pyx_k_L), 0, 0, 1, 1},
  {&__pyx_n_s_LB, __pyx_k_LB, sizeof(__pyx_k_LB), 0, 0, 1, 1},
  {&__pyx_n_s_LN, __pyx_k_LN, sizeof(__pyx_k_LN), 0, 0, 1, 1},
  {&__pyx_n_s_M5, __pyx_k_M5, sizeof(__pyx_k_M5), 0, 0, 1, 1},
  {&__pyx_n_s_MemoryError, __pyx_k_MemoryError, sizeof(__pyx_k_MemoryError), 0, 0, 1, 1},
  {&__pyx_n_s_NotImplementedError, __pyx_k_NotImplementedError, sizeof(__pyx_k_NotImplementedError), 0, 0, 1, 1},
  {&__pyx_n_s_OSError, __pyx_k_OSError, sizeof(__pyx_k_OSError), 0, 0, 1, 1},
  {&__pyx_n_s_OverflowError, __pyx_k_OverflowError, sizeof(__pyx_k_OverflowError), 0, 0, 1, 1},
  {&__pyx_n_s_PG, __pyx_k_PG, sizeof(__pyx_k_PG), 0, 0, 1, 1},
  {&__pyx_n_s_PI, __pyx_k_PI, sizeof(__pyx_k_PI), 0, 0, 1, 1},
  {&__pyx_n_s_PL, __pyx_k_PL, sizeof(__pyx_k_PL), 0, 0, 1, 1},
  {&__pyx_n_s_PM, __pyx_k_PM, sizeof(__pyx_k_PM), 0, 0, 1, 1},
  {&__pyx_n_s_PN, __pyx_k_PN, sizeof(__pyx_k_PN), 0, 0, 1, 1},
  {&__pyx_n_s_PP, __pyx_k_PP, sizeof(__pyx_k_PP), 0, 0, 1, 1},
  {&__pyx_n_s_PU, __pyx_k_PU, sizeof(__pyx_k_PU), 0, 0, 1, 1},
  {&__pyx_n_s_RG, __pyx_k_RG, sizeof(__pyx_k_RG), 0, 0, 1, 1},
  {&__pyx_n_s_SM, __pyx_k_SM, sizeof(__pyx_k_SM), 0, 0, 1, 1},
  {&__pyx_n_s_SN, __pyx_k_SN, sizeof(__pyx_k_SN), 0, 0, 1, 1},
  {&__pyx_n_s_SO, __pyx_k_SO, sizeof(__pyx_k_SO), 0, 0, 1, 1},
  {&__pyx_n_s_SP, __pyx_k_SP, sizeof(__pyx_k_SP), 0, 0, 1, 1},
  {&__pyx_n_s_SQ, __pyx_k_SQ, sizeof(__pyx_k_SQ), 0, 0, 1, 1},
  {&__pyx_kp_s_SQ_SN_s_LN_s, __pyx_k_SQ_SN_s_LN_s, sizeof(__pyx_k_SQ_SN_s_LN_s), 0, 0, 1, 0},
  {&__pyx_n_s_StopIteration, __pyx_k_StopIteration, sizeof(__pyx_k_StopIteration), 0, 0, 1, 1},
  {&__pyx_n_s_StringIO, __pyx_k_StringIO, sizeof(__pyx_k_StringIO), 0, 0, 1, 1},
  {&__pyx_n_s_T, __pyx_k_T, sizeof(__pyx_k_T), 0, 0, 1, 1},
  {&__pyx_n_s_UR, __pyx_k_UR, sizeof(__pyx_k_UR), 0, 0, 1, 1},
  {&__pyx_n_s_VALID_HEADERS, __pyx_k_VALID_HEADERS, sizeof(__pyx_k_VALID_HEADERS), 0, 0, 1, 1},
  {&__pyx_n_s_VALID_HEADER_ORDER, __pyx_k_VALID_HEADER_ORDER, sizeof(__pyx_k_VALID_HEADER_ORDER), 0, 0, 1, 1},
  {&__pyx_n_s_VALID_HEADER_TYPES, __pyx_k_VALID_HEADER_TYPES, sizeof(__pyx_k_VALID_HEADER_TYPES), 0, 0, 1, 1},
  {&__pyx_n_s_VN, __pyx_k_VN, sizeof(__pyx_k_VN), 0, 0, 1, 1},
  {&__pyx_n_s_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 0, 0, 1, 1},
  {&__pyx_kp_b__12, __pyx_k__12, sizeof(__pyx_k__12), 0, 0, 0, 0},
  {&__pyx_kp_s__13, __pyx_k__13, sizeof(__pyx_k__13), 0, 0, 1, 0},
  {&__pyx_kp_s__2, __pyx_k__2, sizeof(__pyx_k__2), 0, 0, 1, 0},
  {&__pyx_kp_s__23, __pyx_k__23, sizeof(__pyx_k__23), 0, 0, 1, 0},
  {&__pyx_kp_s__3, __pyx_k__3, sizeof(__pyx_k__3), 0, 0, 1, 0},
  {&__pyx_kp_s__44, __pyx_k__44, sizeof(__pyx_k__44), 0, 0, 1, 0},
  {&__pyx_kp_s__50, __pyx_k__50, sizeof(__pyx_k__50), 0, 0, 1, 0},
  {&__pyx_kp_s_access_from_StringIO_objects_not, __pyx_k_access_from_StringIO_objects_not, sizeof(__pyx_k_access_from_StringIO_objects_not), 0, 0, 1, 0},
  {&__pyx_n_s_add_sq_text, __pyx_k_add_sq_text, sizeof(__pyx_k_add_sq_text), 0, 0, 1, 1},
  {&__pyx_n_s_all, __pyx_k_all, sizeof(__pyx_k_all), 0, 0, 1, 1},
  {&__pyx_n_s_all_2, __pyx_k_all_2, sizeof(__pyx_k_all_2), 0, 0, 1, 1},
  {&__pyx_n_s_append, __pyx_k_append, sizeof(__pyx_k_append), 0, 0, 1, 1},
  {&__pyx_n_s_array, __pyx_k_array, sizeof(__pyx_k_array), 0, 0, 1, 1},
  {&__pyx_n_s_ascii, __pyx_k_ascii, sizeof(__pyx_k_ascii), 0, 0, 1, 1},
  {&__pyx_n_s_b, __pyx_k_b, sizeof(__pyx_k_b), 0, 0, 1, 1},
  {&__pyx_kp_b_bai, __pyx_k_bai, sizeof(__pyx_k_bai), 0, 0, 0, 0},
  {&__pyx_n_s_beg, __pyx_k_beg, sizeof(__pyx_k_beg), 0, 0, 1, 1},
  {&__pyx_n_s_build_header_line, __pyx_k_build_header_line, sizeof(__pyx_k_build_header_line), 0, 0, 1, 1},
  {&__pyx_n_s_c, __pyx_k_c, sizeof(__pyx_k_c), 0, 0, 1, 1},
  {&__pyx_kp_s_can_not_iterate_over_samfile_wit, __pyx_k_can_not_iterate_over_samfile_wit, sizeof(__pyx_k_can_not_iterate_over_samfile_wit), 0, 0, 1, 0},
  {&__pyx_kp_s_can_only_IndexReads_on_bam_files, __pyx_k_can_only_IndexReads_on_bam_files, sizeof(__pyx_k_can_only_IndexReads_on_bam_files), 0, 0, 1, 0},
  {&__pyx_n_s_check_header, __pyx_k_check_header, sizeof(__pyx_k_check_header), 0, 0, 1, 1},
  {&__pyx_n_s_check_index, __pyx_k_check_index, sizeof(__pyx_k_check_index), 0, 0, 1, 1},
  {&__pyx_n_s_check_sq, __pyx_k_check_sq, sizeof(__pyx_k_check_sq), 0, 0, 1, 1},
  {&__pyx_n_s_close, __pyx_k_close, sizeof(__pyx_k_close), 0, 0, 1, 1},
  {&__pyx_n_s_closed, __pyx_k_closed, sizeof(__pyx_k_closed), 0, 0, 1, 1},
  {&__pyx_n_s_collections, __pyx_k_collections, sizeof(__pyx_k_collections), 0, 0, 1, 1},
  {&__pyx_n_s_consensus_quality, __pyx_k_consensus_quality, sizeof(__pyx_k_consensus_quality), 0, 0, 1, 1},
  {&__pyx_kp_s_could_not_open_file_mode_s_is_it, __pyx_k_could_not_open_file_mode_s_is_it, sizeof(__pyx_k_could_not_open_file_mode_s_is_it), 0, 0, 1, 0},
  {&__pyx_kp_s_could_not_open_file_s, __pyx_k_could_not_open_file_s, sizeof(__pyx_k_could_not_open_file_s), 0, 0, 1, 0},
  {&__pyx_n_s_coverage, __pyx_k_coverage, sizeof(__pyx_k_coverage), 0, 0, 1, 1},
  {&__pyx_kp_b_crai, __pyx_k_crai, sizeof(__pyx_k_crai), 0, 0, 0, 0},
  {&__pyx_n_s_defaultdict, __pyx_k_defaultdict, sizeof(__pyx_k_defaultdict), 0, 0, 1, 1},
  {&__pyx_kp_s_either_supply_options_template_h, __pyx_k_either_supply_options_template_h, sizeof(__pyx_k_either_supply_options_template_h), 0, 0, 1, 0},
  {&__pyx_n_s_encode, __pyx_k_encode, sizeof(__pyx_k_encode), 0, 0, 1, 1},
  {&__pyx_n_s_end, __pyx_k_end, sizeof(__pyx_k_end), 0, 0, 1, 1},
  {&__pyx_kp_s_end_out_of_range_i, __pyx_k_end_out_of_range_i, sizeof(__pyx_k_end_out_of_range_i), 0, 0, 1, 0},
  {&__pyx_n_s_enumerate, __pyx_k_enumerate, sizeof(__pyx_k_enumerate), 0, 0, 1, 1},
  {&__pyx_kp_s_error_during_iteration, __pyx_k_error_during_iteration, sizeof(__pyx_k_error_during_iteration), 0, 0, 1, 0},
  {&__pyx_kp_s_error_while_opening_index_for_s, __pyx_k_error_while_opening_index_for_s, sizeof(__pyx_k_error_while_opening_index_for_s), 0, 0, 1, 0},
  {&__pyx_n_s_exc_type, __pyx_k_exc_type, sizeof(__pyx_k_exc_type), 0, 0, 1, 1},
  {&__pyx_n_s_exc_value, __pyx_k_exc_value, sizeof(__pyx_k_exc_value), 0, 0, 1, 1},
  {&__pyx_n_s_exists, __pyx_k_exists, sizeof(__pyx_k_exists), 0, 0, 1, 1},
  {&__pyx_n_s_fastafile, __pyx_k_fastafile, sizeof(__pyx_k_fastafile), 0, 0, 1, 1},
  {&__pyx_n_s_fetch, __pyx_k_fetch, sizeof(__pyx_k_fetch), 0, 0, 1, 1},
  {&__pyx_kp_s_fetch_called_for_htsfile_without, __pyx_k_fetch_called_for_htsfile_without, sizeof(__pyx_k_fetch_called_for_htsfile_without), 0, 0, 1, 0},
  {&__pyx_kp_s_fetch_called_on_bamfile_without, __pyx_k_fetch_called_on_bamfile_without, sizeof(__pyx_k_fetch_called_on_bamfile_without), 0, 0, 1, 0},
  {&__pyx_kp_s_fetching_by_region_is_not_availa, __pyx_k_fetching_by_region_is_not_availa, sizeof(__pyx_k_fetching_by_region_is_not_availa), 0, 0, 1, 0},
  {&__pyx_n_s_fields, __pyx_k_fields, sizeof(__pyx_k_fields), 0, 0, 1, 1},
  {&__pyx_kp_s_file_does_not_have_valid_header, __pyx_k_file_does_not_have_valid_header, sizeof(__pyx_k_file_does_not_have_valid_header), 0, 0, 1, 0},
  {&__pyx_kp_s_file_does_not_have_valid_header_2, __pyx_k_file_does_not_have_valid_header_2, sizeof(__pyx_k_file_does_not_have_valid_header_2), 0, 0, 1, 0},
  {&__pyx_kp_s_file_has_no_sequences_defined_mo, __pyx_k_file_has_no_sequences_defined_mo, sizeof(__pyx_k_file_has_no_sequences_defined_mo), 0, 0, 1, 0},
  {&__pyx_kp_s_file_s_not_found, __pyx_k_file_s_not_found, sizeof(__pyx_k_file_s_not_found), 0, 0, 1, 0},
  {&__pyx_n_s_filename, __pyx_k_filename, sizeof(__pyx_k_filename), 0, 0, 1, 1},
  {&__pyx_n_s_fileno, __pyx_k_fileno, sizeof(__pyx_k_fileno), 0, 0, 1, 1},
  {&__pyx_n_s_filepath_index, __pyx_k_filepath_index, sizeof(__pyx_k_filepath_index), 0, 0, 1, 1},
  {&__pyx_n_s_filepath_or_object, __pyx_k_filepath_or_object, sizeof(__pyx_k_filepath_or_object), 0, 0, 1, 1},
  {&__pyx_n_s_flag, __pyx_k_flag, sizeof(__pyx_k_flag), 0, 0, 1, 1},
  {&__pyx_n_s_genotype, __pyx_k_genotype, sizeof(__pyx_k_genotype), 0, 0, 1, 1},
  {&__pyx_n_s_get, __pyx_k_get, sizeof(__pyx_k_get), 0, 0, 1, 1},
  {&__pyx_n_s_get_aligned_pairs, __pyx_k_get_aligned_pairs, sizeof(__pyx_k_get_aligned_pairs), 0, 0, 1, 1},
  {&__pyx_n_s_get_reference_name, __pyx_k_get_reference_name, sizeof(__pyx_k_get_reference_name), 0, 0, 1, 1},
  {&__pyx_n_s_get_tid, __pyx_k_get_tid, sizeof(__pyx_k_get_tid), 0, 0, 1, 1},
  {&__pyx_n_s_gettid, __pyx_k_gettid, sizeof(__pyx_k_gettid), 0, 0, 1, 1},
  {&__pyx_n_s_h, __pyx_k_h, sizeof(__pyx_k_h), 0, 0, 1, 1},
  {&__pyx_n_s_has_index, __pyx_k_has_index, sizeof(__pyx_k_has_index), 0, 0, 1, 1},
  {&__pyx_n_s_header, __pyx_k_header, sizeof(__pyx_k_header), 0, 0, 1, 1},
  {&__pyx_kp_s_header_line_with_invalid_type_s, __pyx_k_header_line_with_invalid_type_s, sizeof(__pyx_k_header_line_with_invalid_type_s), 0, 0, 1, 0},
  {&__pyx_kp_s_header_line_without_s, __pyx_k_header_line_without_s, sizeof(__pyx_k_header_line_without_s), 0, 0, 1, 0},
  {&__pyx_kp_s_home_vagrant_Downloads_pysam_py, __pyx_k_home_vagrant_Downloads_pysam_py, sizeof(__pyx_k_home_vagrant_Downloads_pysam_py), 0, 0, 1, 0},
  {&__pyx_n_s_import, __pyx_k_import, sizeof(__pyx_k_import), 0, 0, 1, 1},
  {&__pyx_kp_s_incomplete_sequence_information, __pyx_k_incomplete_sequence_information, sizeof(__pyx_k_incomplete_sequence_information), 0, 0, 1, 0},
  {&__pyx_n_s_init, __pyx_k_init, sizeof(__pyx_k_init), 0, 0, 1, 1},
  {&__pyx_kp_s_invalid_coordinates_start_i_end, __pyx_k_invalid_coordinates_start_i_end, sizeof(__pyx_k_invalid_coordinates_start_i_end), 0, 0, 1, 0},
  {&__pyx_kp_s_invalid_file_opening_mode_s, __pyx_k_invalid_file_opening_mode_s, sizeof(__pyx_k_invalid_file_opening_mode_s), 0, 0, 1, 0},
  {&__pyx_kp_s_invalid_reference_s, __pyx_k_invalid_reference_s, sizeof(__pyx_k_invalid_reference_s), 0, 0, 1, 0},
  {&__pyx_kp_s_invalid_type_for_record_s_s_expe, __pyx_k_invalid_type_for_record_s_s_expe, sizeof(__pyx_k_invalid_type_for_record_s_s_expe), 0, 0, 1, 0},
  {&__pyx_n_s_io, __pyx_k_io, sizeof(__pyx_k_io), 0, 0, 1, 1},
  {&__pyx_n_s_is_open, __pyx_k_is_open, sizeof(__pyx_k_is_open), 0, 0, 1, 1},
  {&__pyx_n_s_islower, __pyx_k_islower, sizeof(__pyx_k_islower), 0, 0, 1, 1},
  {&__pyx_n_s_isupper, __pyx_k_isupper, sizeof(__pyx_k_isupper), 0, 0, 1, 1},
  {&__pyx_n_s_items, __pyx_k_items, sizeof(__pyx_k_items), 0, 0, 1, 1},
  {&__pyx_n_s_join, __pyx_k_join, sizeof(__pyx_k_join), 0, 0, 1, 1},
  {&__pyx_n_s_key, __pyx_k_key, sizeof(__pyx_k_key), 0, 0, 1, 1},
  {&__pyx_n_s_lengths, __pyx_k_lengths, sizeof(__pyx_k_lengths), 0, 0, 1, 1},
  {&__pyx_n_s_line, __pyx_k_line, sizeof(__pyx_k_line), 0, 0, 1, 1},
  {&__pyx_n_s_main, __pyx_k_main, sizeof(__pyx_k_main), 0, 0, 1, 1},
  {&__pyx_kp_s_malformatted_header_no_in_field, __pyx_k_malformatted_header_no_in_field, sizeof(__pyx_k_malformatted_header_no_in_field), 0, 0, 1, 0},
  {&__pyx_n_s_map, __pyx_k_map, sizeof(__pyx_k_map), 0, 0, 1, 1},
  {&__pyx_kp_s_mapping_information_not_recorded, __pyx_k_mapping_information_not_recorded, sizeof(__pyx_k_mapping_information_not_recorded), 0, 0, 1, 0},
  {&__pyx_n_s_mapping_quality, __pyx_k_mapping_quality, sizeof(__pyx_k_mapping_quality), 0, 0, 1, 1},
  {&__pyx_kp_s_mate_not_found, __pyx_k_mate_not_found, sizeof(__pyx_k_mate_not_found), 0, 0, 1, 0},
  {&__pyx_kp_s_mate_s_is_unmapped, __pyx_k_mate_s_is_unmapped, sizeof(__pyx_k_mate_s_is_unmapped), 0, 0, 1, 0},
  {&__pyx_n_s_max_depth, __pyx_k_max_depth, sizeof(__pyx_k_max_depth), 0, 0, 1, 1},
  {&__pyx_n_s_mode, __pyx_k_mode, sizeof(__pyx_k_mode), 0, 0, 1, 1},
  {&__pyx_n_s_multiple_iterators, __pyx_k_multiple_iterators, sizeof(__pyx_k_multiple_iterators), 0, 0, 1, 1},
  {&__pyx_kp_s_multiple_s_lines_are_not_permitt, __pyx_k_multiple_s_lines_are_not_permitt, sizeof(__pyx_k_multiple_s_lines_are_not_permitt), 0, 0, 1, 0},
  {&__pyx_n_s_n, __pyx_k_n, sizeof(__pyx_k_n), 0, 0, 1, 1},
  {&__pyx_n_s_name, __pyx_k_name, sizeof(__pyx_k_name), 0, 0, 1, 1},
  {&__pyx_n_s_nextiter, __pyx_k_nextiter, sizeof(__pyx_k_nextiter), 0, 0, 1, 1},
  {&__pyx_kp_s_no_index_available_for_fetch, __pyx_k_no_index_available_for_fetch, sizeof(__pyx_k_no_index_available_for_fetch), 0, 0, 1, 0},
  {&__pyx_kp_s_no_index_available_for_iteration, __pyx_k_no_index_available_for_iteration, sizeof(__pyx_k_no_index_available_for_iteration), 0, 0, 1, 0},
  {&__pyx_kp_s_no_index_available_for_pileup, __pyx_k_no_index_available_for_pileup, sizeof(__pyx_k_no_index_available_for_pileup), 0, 0, 1, 0},
  {&__pyx_n_s_nofilter, __pyx_k_nofilter, sizeof(__pyx_k_nofilter), 0, 0, 1, 1},
  {&__pyx_n_s_nreferences, __pyx_k_nreferences, sizeof(__pyx_k_nreferences), 0, 0, 1, 1},
  {&__pyx_n_s_offset, __pyx_k_offset, sizeof(__pyx_k_offset), 0, 0, 1, 1},
  {&__pyx_n_s_open, __pyx_k_open, sizeof(__pyx_k_open), 0, 0, 1, 1},
  {&__pyx_n_s_os, __pyx_k_os, sizeof(__pyx_k_os), 0, 0, 1, 1},
  {&__pyx_n_s_parse_region, __pyx_k_parse_region, sizeof(__pyx_k_parse_region), 0, 0, 1, 1},
  {&__pyx_n_s_path, __pyx_k_path, sizeof(__pyx_k_path), 0, 0, 1, 1},
  {&__pyx_kp_s_pileup_of_samfiles_not_implement, __pyx_k_pileup_of_samfiles_not_implement, sizeof(__pyx_k_pileup_of_samfiles_not_implement), 0, 0, 1, 0},
  {&__pyx_n_s_port, __pyx_k_port, sizeof(__pyx_k_port), 0, 0, 1, 1},
  {&__pyx_n_s_pos, __pyx_k_pos, sizeof(__pyx_k_pos), 0, 0, 1, 1},
  {&__pyx_n_s_positions, __pyx_k_positions, sizeof(__pyx_k_positions), 0, 0, 1, 1},
  {&__pyx_n_s_pysam_calignmentfile, __pyx_k_pysam_calignmentfile, sizeof(__pyx_k_pysam_calignmentfile), 0, 0, 1, 1},
  {&__pyx_n_s_pyx_vtable, __pyx_k_pyx_vtable, sizeof(__pyx_k_pyx_vtable), 0, 0, 1, 1},
  {&__pyx_n_s_quality_threshold, __pyx_k_quality_threshold, sizeof(__pyx_k_quality_threshold), 0, 0, 1, 1},
  {&__pyx_n_s_query_name, __pyx_k_query_name, sizeof(__pyx_k_query_name), 0, 0, 1, 1},
  {&__pyx_n_s_query_qualities, __pyx_k_query_qualities, sizeof(__pyx_k_query_qualities), 0, 0, 1, 1},
  {&__pyx_n_s_r, __pyx_k_r, sizeof(__pyx_k_r), 0, 0, 1, 1},
  {&__pyx_n_s_rU, __pyx_k_rU, sizeof(__pyx_k_rU), 0, 0, 1, 1},
  {&__pyx_n_s_rb, __pyx_k_rb, sizeof(__pyx_k_rb), 0, 0, 1, 1},
  {&__pyx_n_s_rc, __pyx_k_rc, sizeof(__pyx_k_rc), 0, 0, 1, 1},
  {&__pyx_n_s_re, __pyx_k_re, sizeof(__pyx_k_re), 0, 0, 1, 1},
  {&__pyx_n_s_read_callback, __pyx_k_read_callback, sizeof(__pyx_k_read_callback), 0, 0, 1, 1},
  {&__pyx_kp_s_read_s_is_unpaired, __pyx_k_read_s_is_unpaired, sizeof(__pyx_k_read_s_is_unpaired), 0, 0, 1, 0},
  {&__pyx_kp_s_read_s_not_found, __pyx_k_read_s_not_found, sizeof(__pyx_k_read_s_not_found), 0, 0, 1, 0},
  {&__pyx_n_s_record, __pyx_k_record, sizeof(__pyx_k_record), 0, 0, 1, 1},
  {&__pyx_n_s_reference, __pyx_k_reference, sizeof(__pyx_k_reference), 0, 0, 1, 1},
  {&__pyx_n_s_reference_base, __pyx_k_reference_base, sizeof(__pyx_k_reference_base), 0, 0, 1, 1},
  {&__pyx_n_s_reference_filename, __pyx_k_reference_filename, sizeof(__pyx_k_reference_filename), 0, 0, 1, 1},
  {&__pyx_kp_s_reference_id_i_out_of_range_0_ti, __pyx_k_reference_id_i_out_of_range_0_ti, sizeof(__pyx_k_reference_id_i_out_of_range_0_ti), 0, 0, 1, 0},
  {&__pyx_n_s_reference_lengths, __pyx_k_reference_lengths, sizeof(__pyx_k_reference_lengths), 0, 0, 1, 1},
  {&__pyx_n_s_reference_names, __pyx_k_reference_names, sizeof(__pyx_k_reference_names), 0, 0, 1, 1},
  {&__pyx_kp_s_reference_sequence_for_s_tid_i_n, __pyx_k_reference_sequence_for_s_tid_i_n, sizeof(__pyx_k_reference_sequence_for_s_tid_i_n), 0, 0, 1, 0},
  {&__pyx_n_s_referencelengths, __pyx_k_referencelengths, sizeof(__pyx_k_referencelengths), 0, 0, 1, 1},
  {&__pyx_n_s_referencenames, __pyx_k_referencenames, sizeof(__pyx_k_referencenames), 0, 0, 1, 1},
  {&__pyx_n_s_references, __pyx_k_references, sizeof(__pyx_k_references), 0, 0, 1, 1},
  {&__pyx_n_s_region, __pyx_k_region, sizeof(__pyx_k_region), 0, 0, 1, 1},
  {&__pyx_kp_s_s, __pyx_k_s, sizeof(__pyx_k_s), 0, 0, 1, 0},
  {&__pyx_kp_s_s_s, __pyx_k_s_s, sizeof(__pyx_k_s_s), 0, 0, 1, 0},
  {&__pyx_kp_s_sam_write_failed, __pyx_k_sam_write_failed, sizeof(__pyx_k_sam_write_failed), 0, 0, 1, 0},
  {&__pyx_n_s_samfile, __pyx_k_samfile, sizeof(__pyx_k_samfile), 0, 0, 1, 1},
  {&__pyx_n_s_samtools, __pyx_k_samtools, sizeof(__pyx_k_samtools), 0, 0, 1, 1},
  {&__pyx_n_s_seek, __pyx_k_seek, sizeof(__pyx_k_seek), 0, 0, 1, 1},
  {&__pyx_kp_s_seek_no_available_in_streams, __pyx_k_seek_no_available_in_streams, sizeof(__pyx_k_seek_no_available_in_streams), 0, 0, 1, 0},
  {&__pyx_kp_s_seek_only_available_in_bam_files, __pyx_k_seek_only_available_in_bam_files, sizeof(__pyx_k_seek_only_available_in_bam_files), 0, 0, 1, 0},
  {&__pyx_n_s_seq, __pyx_k_seq, sizeof(__pyx_k_seq), 0, 0, 1, 1},
  {&__pyx_n_s_snp_quality, __pyx_k_snp_quality, sizeof(__pyx_k_snp_quality), 0, 0, 1, 1},
  {&__pyx_n_s_split, __pyx_k_split, sizeof(__pyx_k_split), 0, 0, 1, 1},
  {&__pyx_n_s_start, __pyx_k_start, sizeof(__pyx_k_start), 0, 0, 1, 1},
  {&__pyx_kp_s_start_out_of_range_i, __pyx_k_start_out_of_range_i, sizeof(__pyx_k_start_out_of_range_i), 0, 0, 1, 0},
  {&__pyx_n_s_startswith, __pyx_k_startswith, sizeof(__pyx_k_startswith), 0, 0, 1, 1},
  {&__pyx_n_s_stepper, __pyx_k_stepper, sizeof(__pyx_k_stepper), 0, 0, 1, 1},
  {&__pyx_n_s_stringio, __pyx_k_stringio, sizeof(__pyx_k_stringio), 0, 0, 1, 1},
  {&__pyx_n_s_strip, __pyx_k_strip, sizeof(__pyx_k_strip), 0, 0, 1, 1},
  {&__pyx_n_s_tell, __pyx_k_tell, sizeof(__pyx_k_tell), 0, 0, 1, 1},
  {&__pyx_n_s_template, __pyx_k_template, sizeof(__pyx_k_template), 0, 0, 1, 1},
  {&__pyx_n_s_test, __pyx_k_test, sizeof(__pyx_k_test), 0, 0, 1, 1},
  {&__pyx_n_s_text, __pyx_k_text, sizeof(__pyx_k_text), 0, 0, 1, 1},
  {&__pyx_n_s_tid, __pyx_k_tid, sizeof(__pyx_k_tid), 0, 0, 1, 1},
  {&__pyx_n_s_traceback, __pyx_k_traceback, sizeof(__pyx_k_traceback), 0, 0, 1, 1},
  {&__pyx_n_s_truncate, __pyx_k_truncate, sizeof(__pyx_k_truncate), 0, 0, 1, 1},
  {&__pyx_kp_s_truncated_file, __pyx_k_truncated_file, sizeof(__pyx_k_truncated_file), 0, 0, 1, 0},
  {&__pyx_kp_s_unable_to_open_index_at_s, __pyx_k_unable_to_open_index_at_s, sizeof(__pyx_k_unable_to_open_index_at_s), 0, 0, 1, 0},
  {&__pyx_kp_s_unable_to_open_remote_index_for, __pyx_k_unable_to_open_remote_index_for, sizeof(__pyx_k_unable_to_open_remote_index_for), 0, 0, 1, 0},
  {&__pyx_kp_s_unequal_names_and_lengths_of_ref, __pyx_k_unequal_names_and_lengths_of_ref, sizeof(__pyx_k_unequal_names_and_lengths_of_ref), 0, 0, 1, 0},
  {&__pyx_kp_s_unknown_stepper_option_s_in_Iter, __pyx_k_unknown_stepper_option_s_in_Iter, sizeof(__pyx_k_unknown_stepper_option_s_in_Iter), 0, 0, 1, 0},
  {&__pyx_n_s_until_eof, __pyx_k_until_eof, sizeof(__pyx_k_until_eof), 0, 0, 1, 1},
  {&__pyx_n_s_w, __pyx_k_w, sizeof(__pyx_k_w), 0, 0, 1, 1},
  {&__pyx_n_s_warn, __pyx_k_warn, sizeof(__pyx_k_warn), 0, 0, 1, 1},
  {&__pyx_n_s_warnings, __pyx_k_warnings, sizeof(__pyx_k_warnings), 0, 0, 1, 1},
  {&__pyx_n_s_wb, __pyx_k_wb, sizeof(__pyx_k_wb), 0, 0, 1, 1},
  {&__pyx_n_s_wb0, __pyx_k_wb0, sizeof(__pyx_k_wb0), 0, 0, 1, 1},
  {&__pyx_n_s_wbu, __pyx_k_wbu, sizeof(__pyx_k_wbu), 0, 0, 1, 1},
  {&__pyx_n_s_wc, __pyx_k_wc, sizeof(__pyx_k_wc), 0, 0, 1, 1},
  {&__pyx_n_s_wh, __pyx_k_wh, sizeof(__pyx_k_wh), 0, 0, 1, 1},
  {&__pyx_n_s_where, __pyx_k_where, sizeof(__pyx_k_where), 0, 0, 1, 1},
  {&__pyx_n_s_write, __pyx_k_write, sizeof(__pyx_k_write), 0, 0, 1, 1},
  {&__pyx_n_s_zip, __pyx_k_zip, sizeof(__pyx_k_zip), 0, 0, 1, 1},
  {0, 0, 0, 0, 0, 0, 0}
};
static int __Pyx_InitCachedBuiltins(void) {
  __pyx_builtin_ValueError = __Pyx_GetBuiltinName(__pyx_n_s_ValueError); if (!__pyx_builtin_ValueError) __PYX_ERR(0, 166, __pyx_L1_error)
  __pyx_builtin_KeyError = __Pyx_GetBuiltinName(__pyx_n_s_KeyError); if (!__pyx_builtin_KeyError) __PYX_ERR(0, 198, __pyx_L1_error)
  __pyx_builtin_AttributeError = __Pyx_GetBuiltinName(__pyx_n_s_AttributeError); if (!__pyx_builtin_AttributeError) __PYX_ERR(0, 363, __pyx_L1_error)
  __pyx_builtin_NotImplementedError = __Pyx_GetBuiltinName(__pyx_n_s_NotImplementedError); if (!__pyx_builtin_NotImplementedError) __PYX_ERR(0, 418, __pyx_L1_error)
  __pyx_builtin_IOError = __Pyx_GetBuiltinName(__pyx_n_s_IOError); if (!__pyx_builtin_IOError) __PYX_ERR(0, 533, __pyx_L1_error)
  __pyx_builtin_OSError = __Pyx_GetBuiltinName(__pyx_n_s_OSError); if (!__pyx_builtin_OSError) __PYX_ERR(0, 710, __pyx_L1_error)
  __pyx_builtin_OverflowError = __Pyx_GetBuiltinName(__pyx_n_s_OverflowError); if (!__pyx_builtin_OverflowError) __PYX_ERR(0, 776, __pyx_L1_error)
  __pyx_builtin_enumerate = __Pyx_GetBuiltinName(__pyx_n_s_enumerate); if (!__pyx_builtin_enumerate) __PYX_ERR(0, 1549, __pyx_L1_error)
  __pyx_builtin_zip = __Pyx_GetBuiltinName(__pyx_n_s_zip); if (!__pyx_builtin_zip) __PYX_ERR(0, 1588, __pyx_L1_error)
  __pyx_builtin_StopIteration = __Pyx_GetBuiltinName(__pyx_n_s_StopIteration); if (!__pyx_builtin_StopIteration) __PYX_ERR(0, 1629, __pyx_L1_error)
  __pyx_builtin_map = __Pyx_GetBuiltinName(__pyx_n_s_map); if (!__pyx_builtin_map) __PYX_ERR(0, 2394, __pyx_L1_error)
  __pyx_builtin_MemoryError = __Pyx_GetBuiltinName(__pyx_n_s_MemoryError); if (!__pyx_builtin_MemoryError) __PYX_ERR(2, 107, __pyx_L1_error)
  return 0;
  __pyx_L1_error:;
  return -1;
}

static int __Pyx_InitCachedConstants(void) {
  __Pyx_RefNannyDeclarations
  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants", 0);

  /* "pysam/calignmentfile.pyx":188
 *     dest.text = <char*>calloc(len(text), sizeof(char))
 *     dest.l_text = len(text)
 *     cdef bytes btext = text.encode('ascii')             # <<<<<<<<<<<<<<
 *     strncpy(dest.text, btext, dest.l_text)
 * 
 */
  __pyx_tuple__4 = PyTuple_Pack(1, __pyx_n_s_ascii); if (unlikely(!__pyx_tuple__4)) __PYX_ERR(0, 188, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__4);
  __Pyx_GIVEREF(__pyx_tuple__4);

  /* "pysam/calignmentfile.pyx":209
 *             dest.target_name[x] = <char*>calloc(
 *                 len(seqname) + 1, sizeof(char))
 *             bseqname = seqname.encode('ascii')             # <<<<<<<<<<<<<<
 *             strncpy(dest.target_name[x], bseqname,
 *                     len(seqname) + 1)
 */
  __pyx_tuple__5 = PyTuple_Pack(1, __pyx_n_s_ascii); if (unlikely(!__pyx_tuple__5)) __PYX_ERR(0, 209, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__5);
  __Pyx_GIVEREF(__pyx_tuple__5);

  /* "pysam/calignmentfile.pyx":361
 * 
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")             # <<<<<<<<<<<<<<
 *         if not self.is_bam and not self.is_cram:
 *             raise AttributeError(
 */
  __pyx_tuple__6 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__6)) __PYX_ERR(0, 361, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__6);
  __Pyx_GIVEREF(__pyx_tuple__6);

  /* "pysam/calignmentfile.pyx":363
 *             raise ValueError("I/O operation on closed file")
 *         if not self.is_bam and not self.is_cram:
 *             raise AttributeError(             # <<<<<<<<<<<<<<
 *                 "AlignmentFile.mapped only available in bam files")
 *         if self.index == NULL:
 */
  __pyx_tuple__7 = PyTuple_Pack(1, __pyx_kp_s_AlignmentFile_mapped_only_availa); if (unlikely(!__pyx_tuple__7)) __PYX_ERR(0, 363, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__7);
  __Pyx_GIVEREF(__pyx_tuple__7);

  /* "pysam/calignmentfile.pyx":366
 *                 "AlignmentFile.mapped only available in bam files")
 *         if self.index == NULL:
 *             raise ValueError(             # <<<<<<<<<<<<<<
 *                 "mapping information not recorded in index "
 *                 "or index not available")
 */
  __pyx_tuple__8 = PyTuple_Pack(1, __pyx_kp_s_mapping_information_not_recorded); if (unlikely(!__pyx_tuple__8)) __PYX_ERR(0, 366, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__8);
  __Pyx_GIVEREF(__pyx_tuple__8);

  /* "pysam/calignmentfile.pyx":418
 *         if isinstance(filepath_or_object, StringIO):
 *             filename = "stringio"
 *             raise NotImplementedError(             # <<<<<<<<<<<<<<
 *                 "access from StringIO objects not supported")
 *             if filepath_or_object.closed:
 */
  __pyx_tuple__9 = PyTuple_Pack(1, __pyx_kp_s_access_from_StringIO_objects_not); if (unlikely(!__pyx_tuple__9)) __PYX_ERR(0, 418, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__9);
  __Pyx_GIVEREF(__pyx_tuple__9);

  /* "pysam/calignmentfile.pyx":426
 *             filename = filepath_or_object.name
 *             if filepath_or_object.closed:
 *                 raise ValueError('I/O operation on closed file')             # <<<<<<<<<<<<<<
 *         else:
 *             filename = filepath_or_object
 */
  __pyx_tuple__10 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__10)) __PYX_ERR(0, 426, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__10);
  __Pyx_GIVEREF(__pyx_tuple__10);

  /* "pysam/calignmentfile.pyx":434
 *             mode = "wb0"
 * 
 *         cdef bytes bmode = mode.encode('ascii')             # <<<<<<<<<<<<<<
 *         self._filename = filename = encode_filename(filename)
 * 
 */
  __pyx_tuple__11 = PyTuple_Pack(1, __pyx_n_s_ascii); if (unlikely(!__pyx_tuple__11)) __PYX_ERR(0, 434, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__11);
  __Pyx_GIVEREF(__pyx_tuple__11);

  /* "pysam/calignmentfile.pyx":612
 *                     if self.is_bam \
 *                             and not os.path.exists(filename + b".bai") \
 *                             and not os.path.exists(filename[:-4] + b".bai"):             # <<<<<<<<<<<<<<
 *                         self.index = NULL
 *                         has_index = False
 */
  __pyx_slice__14 = PySlice_New(Py_None, __pyx_int_neg_4, Py_None); if (unlikely(!__pyx_slice__14)) __PYX_ERR(0, 612, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_slice__14);
  __Pyx_GIVEREF(__pyx_slice__14);

  /* "pysam/calignmentfile.pyx":617
 *                     elif self.is_cram \
 *                             and not os.path.exists(filename + b".crai") \
 *                             and not os.path.exists(filename[:-5] + b".crai"):             # <<<<<<<<<<<<<<
 *                         self.index = NULL
 *                         has_index = False
 */
  __pyx_slice__15 = PySlice_New(Py_None, __pyx_int_neg_5, Py_None); if (unlikely(!__pyx_slice__15)) __PYX_ERR(0, 617, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_slice__15);
  __Pyx_GIVEREF(__pyx_slice__15);

  /* "pysam/calignmentfile.pyx":652
 *         """
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")             # <<<<<<<<<<<<<<
 *         reference = force_bytes(reference)
 *         return bam_name2id(self.header, reference)
 */
  __pyx_tuple__16 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__16)) __PYX_ERR(0, 652, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__16);
  __Pyx_GIVEREF(__pyx_tuple__16);

  /* "pysam/calignmentfile.pyx":661
 *         """
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")             # <<<<<<<<<<<<<<
 *         if not 0 <= tid < self.header.n_targets:
 *             raise ValueError("reference_id %i out of range 0<=tid<%i" %
 */
  __pyx_tuple__17 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__17)) __PYX_ERR(0, 661, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__17);
  __Pyx_GIVEREF(__pyx_tuple__17);

  /* "pysam/calignmentfile.pyx":705
 * 
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")             # <<<<<<<<<<<<<<
 *         if not self.is_bam:
 *             raise NotImplementedError(
 */
  __pyx_tuple__18 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__18)) __PYX_ERR(0, 705, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__18);
  __Pyx_GIVEREF(__pyx_tuple__18);

  /* "pysam/calignmentfile.pyx":707
 *             raise ValueError("I/O operation on closed file")
 *         if not self.is_bam:
 *             raise NotImplementedError(             # <<<<<<<<<<<<<<
 *                 "seek only available in bam files")
 *         if self.is_stream:
 */
  __pyx_tuple__19 = PyTuple_Pack(1, __pyx_kp_s_seek_only_available_in_bam_files); if (unlikely(!__pyx_tuple__19)) __PYX_ERR(0, 707, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__19);
  __Pyx_GIVEREF(__pyx_tuple__19);

  /* "pysam/calignmentfile.pyx":710
 *                 "seek only available in bam files")
 *         if self.is_stream:
 *             raise OSError("seek no available in streams")             # <<<<<<<<<<<<<<
 * 
 *         cdef uint64_t pos
 */
  __pyx_tuple__20 = PyTuple_Pack(1, __pyx_kp_s_seek_no_available_in_streams); if (unlikely(!__pyx_tuple__20)) __PYX_ERR(0, 710, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__20);
  __Pyx_GIVEREF(__pyx_tuple__20);

  /* "pysam/calignmentfile.pyx":722
 *         """
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")             # <<<<<<<<<<<<<<
 *         if not (self.is_bam or self.is_cram):
 *             raise NotImplementedError(
 */
  __pyx_tuple__21 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__21)) __PYX_ERR(0, 722, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__21);
  __Pyx_GIVEREF(__pyx_tuple__21);

  /* "pysam/calignmentfile.pyx":724
 *             raise ValueError("I/O operation on closed file")
 *         if not (self.is_bam or self.is_cram):
 *             raise NotImplementedError(             # <<<<<<<<<<<<<<
 *                 "seek only available in bam files")
 * 
 */
  __pyx_tuple__22 = PyTuple_Pack(1, __pyx_kp_s_seek_only_available_in_bam_files); if (unlikely(!__pyx_tuple__22)) __PYX_ERR(0, 724, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__22);
  __Pyx_GIVEREF(__pyx_tuple__22);

  /* "pysam/calignmentfile.pyx":795
 * 
 *         if not reference:
 *             return 0, 0, 0, 0             # <<<<<<<<<<<<<<
 * 
 *         if tid is not None:
 */
  __pyx_tuple__24 = PyTuple_Pack(4, __pyx_int_0, __pyx_int_0, __pyx_int_0, __pyx_int_0); if (unlikely(!__pyx_tuple__24)) __PYX_ERR(0, 795, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__24);
  __Pyx_GIVEREF(__pyx_tuple__24);

  /* "pysam/calignmentfile.pyx":879
 * 
 *         if not self.is_open():
 *             raise ValueError( "I/O operation on closed file" )             # <<<<<<<<<<<<<<
 * 
 *         has_coord, rtid, rstart, rend = self.parse_region(
 */
  __pyx_tuple__25 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__25)) __PYX_ERR(0, 879, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__25);
  __Pyx_GIVEREF(__pyx_tuple__25);

  /* "pysam/calignmentfile.pyx":895
 *             if not until_eof and not self.is_remote:
 *                 if not self.has_index():
 *                     raise ValueError(             # <<<<<<<<<<<<<<
 *                         "fetch called on bamfile without index")
 * 
 */
  __pyx_tuple__26 = PyTuple_Pack(1, __pyx_kp_s_fetch_called_on_bamfile_without); if (unlikely(!__pyx_tuple__26)) __PYX_ERR(0, 895, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__26);
  __Pyx_GIVEREF(__pyx_tuple__26);

  /* "pysam/calignmentfile.pyx":915
 *         else:
 *             if has_coord:
 *                 raise ValueError(             # <<<<<<<<<<<<<<
 *                     "fetching by region is not available for sam files")
 * 
 */
  __pyx_tuple__27 = PyTuple_Pack(1, __pyx_kp_s_fetching_by_region_is_not_availa); if (unlikely(!__pyx_tuple__27)) __PYX_ERR(0, 915, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__27);
  __Pyx_GIVEREF(__pyx_tuple__27);

  /* "pysam/calignmentfile.pyx":919
 * 
 *             if self.header == NULL:
 *                 raise ValueError(             # <<<<<<<<<<<<<<
 *                     "fetch called for htsfile without header")
 * 
 */
  __pyx_tuple__28 = PyTuple_Pack(1, __pyx_kp_s_fetch_called_for_htsfile_without); if (unlikely(!__pyx_tuple__28)) __PYX_ERR(0, 919, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__28);
  __Pyx_GIVEREF(__pyx_tuple__28);

  /* "pysam/calignmentfile.pyx":925
 *             # give warning, sam_read1 segfaults
 *             if self.header.n_targets == 0:
 *                 warnings.warn("fetch called for htsfile without header")             # <<<<<<<<<<<<<<
 * 
 *             return IteratorRowAll(self,
 */
  __pyx_tuple__29 = PyTuple_Pack(1, __pyx_kp_s_fetch_called_for_htsfile_without); if (unlikely(!__pyx_tuple__29)) __PYX_ERR(0, 925, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__29);
  __Pyx_GIVEREF(__pyx_tuple__29);

  /* "pysam/calignmentfile.pyx":1007
 *                 break
 *         else:
 *             raise ValueError("mate not found")             # <<<<<<<<<<<<<<
 * 
 *         return mate
 */
  __pyx_tuple__30 = PyTuple_Pack(1, __pyx_kp_s_mate_not_found); if (unlikely(!__pyx_tuple__30)) __PYX_ERR(0, 1007, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__30);
  __Pyx_GIVEREF(__pyx_tuple__30);

  /* "pysam/calignmentfile.pyx":1080
 * 
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")             # <<<<<<<<<<<<<<
 * 
 *         has_coord, rtid, rstart, rend = self.parse_region(
 */
  __pyx_tuple__31 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__31)) __PYX_ERR(0, 1080, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__31);
  __Pyx_GIVEREF(__pyx_tuple__31);

  /* "pysam/calignmentfile.pyx":1087
 *         if self.is_bam or self.is_cram:
 *             if not self.has_index():
 *                 raise ValueError("no index available for pileup")             # <<<<<<<<<<<<<<
 * 
 *             if has_coord:
 */
  __pyx_tuple__32 = PyTuple_Pack(1, __pyx_kp_s_no_index_available_for_pileup); if (unlikely(!__pyx_tuple__32)) __PYX_ERR(0, 1087, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__32);
  __Pyx_GIVEREF(__pyx_tuple__32);

  /* "pysam/calignmentfile.pyx":1099
 * 
 *         else:
 *             raise NotImplementedError(             # <<<<<<<<<<<<<<
 *                 "pileup of samfiles not implemented yet")
 * 
 */
  __pyx_tuple__33 = PyTuple_Pack(1, __pyx_kp_s_pileup_of_samfiles_not_implement); if (unlikely(!__pyx_tuple__33)) __PYX_ERR(0, 1099, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__33);
  __Pyx_GIVEREF(__pyx_tuple__33);

  /* "pysam/calignmentfile.pyx":1165
 * 
 *         if not self.is_open():
 *             raise ValueError( "I/O operation on closed file" )             # <<<<<<<<<<<<<<
 * 
 *         cdef int filter_method = 0
 */
  __pyx_tuple__34 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__34)) __PYX_ERR(0, 1165, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__34);
  __Pyx_GIVEREF(__pyx_tuple__34);

  /* "pysam/calignmentfile.pyx":1301
 *             seq = read.seq
 *             quality = read.query_qualities
 *             for qpos, refpos in read.get_aligned_pairs(True):             # <<<<<<<<<<<<<<
 *                 if qpos is not None and refpos is not None and \
 *                    _start <= refpos < _stop:
 */
  __pyx_tuple__35 = PyTuple_Pack(1, Py_True); if (unlikely(!__pyx_tuple__35)) __PYX_ERR(0, 1301, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__35);
  __Pyx_GIVEREF(__pyx_tuple__35);

  /* "pysam/calignmentfile.pyx":1374
 *         #      exception set".
 *         if ret < 0:
 *             raise ValueError('sam write failed')             # <<<<<<<<<<<<<<
 * 
 *         return ret
 */
  __pyx_tuple__36 = PyTuple_Pack(1, __pyx_kp_s_sam_write_failed); if (unlikely(!__pyx_tuple__36)) __PYX_ERR(0, 1374, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__36);
  __Pyx_GIVEREF(__pyx_tuple__36);

  /* "pysam/calignmentfile.pyx":1408
 *         def __get__(self):
 *             if not self.is_open():
 *                 raise ValueError("I/O operation on closed file")             # <<<<<<<<<<<<<<
 *             return self.header.n_targets
 * 
 */
  __pyx_tuple__37 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__37)) __PYX_ERR(0, 1408, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__37);
  __Pyx_GIVEREF(__pyx_tuple__37);

  /* "pysam/calignmentfile.pyx":1415
 *         read-only attribute"""
 *         def __get__(self):
 *             if not self.is_open(): raise ValueError( "I/O operation on closed file" )             # <<<<<<<<<<<<<<
 *             t = []
 *             for x from 0 <= x < self.header.n_targets:
 */
  __pyx_tuple__38 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__38)) __PYX_ERR(0, 1415, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__38);
  __Pyx_GIVEREF(__pyx_tuple__38);

  /* "pysam/calignmentfile.pyx":1429
 *         def __get__(self):
 *             if not self.is_open():
 *                 raise ValueError("I/O operation on closed file")             # <<<<<<<<<<<<<<
 *             t = []
 *             for x from 0 <= x < self.header.n_targets:
 */
  __pyx_tuple__39 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__39)) __PYX_ERR(0, 1429, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__39);
  __Pyx_GIVEREF(__pyx_tuple__39);

  /* "pysam/calignmentfile.pyx":1482
 *         def __get__(self):
 *             if not self.is_open():
 *                 raise ValueError( "I/O operation on closed file" )             # <<<<<<<<<<<<<<
 *             return hts_format_description(&self.htsfile.format)
 * 
 */
  __pyx_tuple__40 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__40)) __PYX_ERR(0, 1482, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__40);
  __Pyx_GIVEREF(__pyx_tuple__40);

  /* "pysam/calignmentfile.pyx":1496
 *         def __get__(self):
 *             if not self.is_open():
 *                 raise ValueError( "I/O operation on closed file" )             # <<<<<<<<<<<<<<
 *             return from_string_and_size(self.header.text, self.header.l_text)
 * 
 */
  __pyx_tuple__41 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__41)) __PYX_ERR(0, 1496, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__41);
  __Pyx_GIVEREF(__pyx_tuple__41);

  /* "pysam/calignmentfile.pyx":1523
 *         def __get__(self):
 *             if not self.is_open():
 *                 raise ValueError( "I/O operation on closed file" )             # <<<<<<<<<<<<<<
 * 
 *             result = {}
 */
  __pyx_tuple__42 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__42)) __PYX_ERR(0, 1523, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__42);
  __Pyx_GIVEREF(__pyx_tuple__42);

  /* "pysam/calignmentfile.pyx":1531
 *                 # create 0-terminated string)
 *                 t = self.text
 *                 for line in t.split("\n"):             # <<<<<<<<<<<<<<
 *                     if not line.strip(): continue
 *                     assert line.startswith("@"), \
 */
  __pyx_tuple__43 = PyTuple_Pack(1, __pyx_kp_s__3); if (unlikely(!__pyx_tuple__43)) __PYX_ERR(0, 1531, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__43);
  __Pyx_GIVEREF(__pyx_tuple__43);

  /* "pysam/calignmentfile.pyx":1533
 *                 for line in t.split("\n"):
 *                     if not line.strip(): continue
 *                     assert line.startswith("@"), \             # <<<<<<<<<<<<<<
 *                         "header line without '@': '%s'" % line
 *                     fields = line[1:].split("\t")
 */
  __pyx_tuple__45 = PyTuple_Pack(1, __pyx_kp_s__44); if (unlikely(!__pyx_tuple__45)) __PYX_ERR(0, 1533, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__45);
  __Pyx_GIVEREF(__pyx_tuple__45);

  /* "pysam/calignmentfile.pyx":1535
 *                     assert line.startswith("@"), \
 *                         "header line without '@': '%s'" % line
 *                     fields = line[1:].split("\t")             # <<<<<<<<<<<<<<
 *                     record = fields[0]
 *                     assert record in VALID_HEADER_TYPES, \
 */
  __pyx_slice__46 = PySlice_New(__pyx_int_1, Py_None, Py_None); if (unlikely(!__pyx_slice__46)) __PYX_ERR(0, 1535, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_slice__46);
  __Pyx_GIVEREF(__pyx_slice__46);
  __pyx_tuple__47 = PyTuple_Pack(1, __pyx_kp_s__2); if (unlikely(!__pyx_tuple__47)) __PYX_ERR(0, 1535, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__47);
  __Pyx_GIVEREF(__pyx_tuple__47);

  /* "pysam/calignmentfile.pyx":1544
 *                         if record not in result:
 *                             result[record] = []
 *                         result[record].append("\t".join( fields[1:]))             # <<<<<<<<<<<<<<
 *                         continue
 *                     # the following is clumsy as generators do not work?
 */
  __pyx_slice__48 = PySlice_New(__pyx_int_1, Py_None, Py_None); if (unlikely(!__pyx_slice__48)) __PYX_ERR(0, 1544, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_slice__48);
  __Pyx_GIVEREF(__pyx_slice__48);

  /* "pysam/calignmentfile.pyx":1549
 *                     x = {}
 * 
 *                     for idx, field in enumerate(fields[1:]):             # <<<<<<<<<<<<<<
 *                         if ":" not in field:
 *                             raise ValueError("malformatted header: no ':' in field" )
 */
  __pyx_slice__49 = PySlice_New(__pyx_int_1, Py_None, Py_None); if (unlikely(!__pyx_slice__49)) __PYX_ERR(0, 1549, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_slice__49);
  __Pyx_GIVEREF(__pyx_slice__49);

  /* "pysam/calignmentfile.pyx":1551
 *                     for idx, field in enumerate(fields[1:]):
 *                         if ":" not in field:
 *                             raise ValueError("malformatted header: no ':' in field" )             # <<<<<<<<<<<<<<
 *                         key, value = field.split(":", 1)
 *                         if key in ("CL",):
 */
  __pyx_tuple__51 = PyTuple_Pack(1, __pyx_kp_s_malformatted_header_no_in_field); if (unlikely(!__pyx_tuple__51)) __PYX_ERR(0, 1551, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__51);
  __Pyx_GIVEREF(__pyx_tuple__51);

  /* "pysam/calignmentfile.pyx":1552
 *                         if ":" not in field:
 *                             raise ValueError("malformatted header: no ':' in field" )
 *                         key, value = field.split(":", 1)             # <<<<<<<<<<<<<<
 *                         if key in ("CL",):
 *                             # special treatment for command line
 */
  __pyx_tuple__52 = PyTuple_Pack(2, __pyx_kp_s__50, __pyx_int_1); if (unlikely(!__pyx_tuple__52)) __PYX_ERR(0, 1552, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__52);
  __Pyx_GIVEREF(__pyx_tuple__52);

  /* "pysam/calignmentfile.pyx":1560
 *                             # header. Thus, in contravention to the
 *                             # SAM API, consume the rest of the line.
 *                             key, value = "\t".join(fields[idx+1:]).split(":", 1)             # <<<<<<<<<<<<<<
 *                             x[key] = KNOWN_HEADER_FIELDS[record][key](value)
 *                             break
 */
  __pyx_tuple__53 = PyTuple_Pack(2, __pyx_kp_s__50, __pyx_int_1); if (unlikely(!__pyx_tuple__53)) __PYX_ERR(0, 1560, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__53);
  __Pyx_GIVEREF(__pyx_tuple__53);

  /* "pysam/calignmentfile.pyx":1601
 *     def __iter__(self):
 *         if not self.is_open():
 *             raise ValueError("I/O operation on closed file")             # <<<<<<<<<<<<<<
 * 
 *         if not self.is_bam and self.header.n_targets == 0:
 */
  __pyx_tuple__54 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__54)) __PYX_ERR(0, 1601, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__54);
  __Pyx_GIVEREF(__pyx_tuple__54);

  /* "pysam/calignmentfile.pyx":1604
 * 
 *         if not self.is_bam and self.header.n_targets == 0:
 *             raise NotImplementedError(             # <<<<<<<<<<<<<<
 *                 "can not iterate over samfile without header")
 *         return self
 */
  __pyx_tuple__55 = PyTuple_Pack(1, __pyx_kp_s_can_not_iterate_over_samfile_wit); if (unlikely(!__pyx_tuple__55)) __PYX_ERR(0, 1604, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__55);
  __Pyx_GIVEREF(__pyx_tuple__55);

  /* "pysam/calignmentfile.pyx":1627
 *             return makeAlignedSegment(self.b, self)
 *         elif ret == -2:
 *             raise IOError('truncated file')             # <<<<<<<<<<<<<<
 *         else:
 *             raise StopIteration
 */
  __pyx_tuple__56 = PyTuple_Pack(1, __pyx_kp_s_truncated_file); if (unlikely(!__pyx_tuple__56)) __PYX_ERR(0, 1627, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__56);
  __Pyx_GIVEREF(__pyx_tuple__56);

  /* "pysam/calignmentfile.pyx":1670
 * 
 *         if not samfile.is_open():
 *             raise ValueError("I/O operation on closed file")             # <<<<<<<<<<<<<<
 * 
 *         # makes sure that samfile stays alive as long as the
 */
  __pyx_tuple__57 = PyTuple_Pack(1, __pyx_kp_s_I_O_operation_on_closed_file); if (unlikely(!__pyx_tuple__57)) __PYX_ERR(0, 1670, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__57);
  __Pyx_GIVEREF(__pyx_tuple__57);

  /* "pysam/calignmentfile.pyx":1727
 * 
 *         if not samfile.has_index():
 *             raise ValueError("no index available for iteration")             # <<<<<<<<<<<<<<
 * 
 *         with nogil:
 */
  __pyx_tuple__58 = PyTuple_Pack(1, __pyx_kp_s_no_index_available_for_iteration); if (unlikely(!__pyx_tuple__58)) __PYX_ERR(0, 1727, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__58);
  __Pyx_GIVEREF(__pyx_tuple__58);

  /* "pysam/calignmentfile.pyx":1758
 *             # returns -2 for a truncated file.
 *             # See https://github.com/pysam-developers/pysam/pull/50#issuecomment-64928625
 *             raise IOError('truncated file')             # <<<<<<<<<<<<<<
 *         else:
 *             raise StopIteration
 */
  __pyx_tuple__59 = PyTuple_Pack(1, __pyx_kp_s_truncated_file); if (unlikely(!__pyx_tuple__59)) __PYX_ERR(0, 1758, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__59);
  __Pyx_GIVEREF(__pyx_tuple__59);

  /* "pysam/calignmentfile.pyx":1811
 *             return makeAlignedSegment(self.b, self.samfile)
 *         elif ret == -2:
 *             raise IOError('truncated file')             # <<<<<<<<<<<<<<
 *         else:
 *             raise StopIteration
 */
  __pyx_tuple__60 = PyTuple_Pack(1, __pyx_kp_s_truncated_file); if (unlikely(!__pyx_tuple__60)) __PYX_ERR(0, 1811, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__60);
  __Pyx_GIVEREF(__pyx_tuple__60);

  /* "pysam/calignmentfile.pyx":1855
 *             return makeAlignedSegment(self.b, self.samfile)
 *         elif ret == -2:
 *             raise IOError('truncated file')             # <<<<<<<<<<<<<<
 *         else:
 *             raise StopIteration
 */
  __pyx_tuple__61 = PyTuple_Pack(1, __pyx_kp_s_truncated_file); if (unlikely(!__pyx_tuple__61)) __PYX_ERR(0, 1855, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__61);
  __Pyx_GIVEREF(__pyx_tuple__61);

  /* "pysam/calignmentfile.pyx":1878
 * 
 *         if not samfile.has_index():
 *             raise ValueError("no index available for fetch")             # <<<<<<<<<<<<<<
 * 
 *         self.tid = -1
 */
  __pyx_tuple__62 = PyTuple_Pack(1, __pyx_kp_s_no_index_available_for_fetch); if (unlikely(!__pyx_tuple__62)) __PYX_ERR(0, 1878, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__62);
  __Pyx_GIVEREF(__pyx_tuple__62);

  /* "pysam/calignmentfile.pyx":1972
 *             return makeAlignedSegment(self.b, self.samfile)
 *         elif (ret == -2):
 *             raise IOError('truncated file')             # <<<<<<<<<<<<<<
 *         else:
 *             raise StopIteration
 */
  __pyx_tuple__63 = PyTuple_Pack(1, __pyx_kp_s_truncated_file); if (unlikely(!__pyx_tuple__63)) __PYX_ERR(0, 1972, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__63);
  __Pyx_GIVEREF(__pyx_tuple__63);

  /* "pysam/calignmentfile.pyx":2291
 *             self.cnext()
 *             if self.n_plp < 0:
 *                 raise ValueError("error during iteration" )             # <<<<<<<<<<<<<<
 * 
 *             if self.plp == NULL:
 */
  __pyx_tuple__65 = PyTuple_Pack(1, __pyx_kp_s_error_during_iteration); if (unlikely(!__pyx_tuple__65)) __PYX_ERR(0, 2291, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__65);
  __Pyx_GIVEREF(__pyx_tuple__65);

  /* "pysam/calignmentfile.pyx":2328
 * 
 *             if self.n_plp < 0:
 *                 raise ValueError("error during iteration" )             # <<<<<<<<<<<<<<
 * 
 *             # return result, if within same reference
 */
  __pyx_tuple__66 = PyTuple_Pack(1, __pyx_kp_s_error_during_iteration); if (unlikely(!__pyx_tuple__66)) __PYX_ERR(0, 2328, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__66);
  __Pyx_GIVEREF(__pyx_tuple__66);

  /* "pysam/calignmentfile.pyx":95
 * 
 * # order of records within SAM headers
 * VALID_HEADERS = ("HD", "SQ", "RG", "PG", "CO")             # <<<<<<<<<<<<<<
 * 
 * # default type conversions within SAM header records
 */
  __pyx_tuple__67 = PyTuple_Pack(5, __pyx_n_s_HD, __pyx_n_s_SQ, __pyx_n_s_RG, __pyx_n_s_PG, __pyx_n_s_CO); if (unlikely(!__pyx_tuple__67)) __PYX_ERR(0, 95, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__67);
  __Pyx_GIVEREF(__pyx_tuple__67);

  /* "pysam/calignmentfile.pyx":110
 * 
 * # output order of fields within records
 * VALID_HEADER_ORDER = {"HD" : ("VN", "SO", "GO"),             # <<<<<<<<<<<<<<
 *                       "SQ" : ("SN", "LN", "AS", "M5",
 *                                "UR", "SP"),
 */
  __pyx_tuple__68 = PyTuple_Pack(3, __pyx_n_s_VN, __pyx_n_s_SO, __pyx_n_s_GO); if (unlikely(!__pyx_tuple__68)) __PYX_ERR(0, 110, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__68);
  __Pyx_GIVEREF(__pyx_tuple__68);

  /* "pysam/calignmentfile.pyx":111
 * # output order of fields within records
 * VALID_HEADER_ORDER = {"HD" : ("VN", "SO", "GO"),
 *                       "SQ" : ("SN", "LN", "AS", "M5",             # <<<<<<<<<<<<<<
 *                                "UR", "SP"),
 *                       "RG" : ("ID", "SM", "LB", "DS",
 */
  __pyx_tuple__69 = PyTuple_Pack(6, __pyx_n_s_SN, __pyx_n_s_LN, __pyx_n_s_AS, __pyx_n_s_M5, __pyx_n_s_UR, __pyx_n_s_SP); if (unlikely(!__pyx_tuple__69)) __PYX_ERR(0, 111, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__69);
  __Pyx_GIVEREF(__pyx_tuple__69);

  /* "pysam/calignmentfile.pyx":113
 *                       "SQ" : ("SN", "LN", "AS", "M5",
 *                                "UR", "SP"),
 *                       "RG" : ("ID", "SM", "LB", "DS",             # <<<<<<<<<<<<<<
 *                               "PU", "PI", "CN", "DT",
 *                               "PL", "FO", "KS", "PG"),
 */
  __pyx_tuple__70 = PyTuple_Pack(12, __pyx_n_s_ID, __pyx_n_s_SM, __pyx_n_s_LB, __pyx_n_s_DS, __pyx_n_s_PU, __pyx_n_s_PI, __pyx_n_s_CN, __pyx_n_s_DT, __pyx_n_s_PL, __pyx_n_s_FO, __pyx_n_s_KS, __pyx_n_s_PG); if (unlikely(!__pyx_tuple__70)) __PYX_ERR(0, 113, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__70);
  __Pyx_GIVEREF(__pyx_tuple__70);

  /* "pysam/calignmentfile.pyx":116
 *                               "PU", "PI", "CN", "DT",
 *                               "PL", "FO", "KS", "PG"),
 *                       "PG" : ("PN", "ID", "VN", "CL",             # <<<<<<<<<<<<<<
 *                               "PP"),}
 * 
 */
  __pyx_tuple__71 = PyTuple_Pack(5, __pyx_n_s_PN, __pyx_n_s_ID, __pyx_n_s_VN, __pyx_n_s_CL, __pyx_n_s_PP); if (unlikely(!__pyx_tuple__71)) __PYX_ERR(0, 116, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__71);
  __Pyx_GIVEREF(__pyx_tuple__71);

  /* "pysam/calignmentfile.pyx":120
 * 
 * 
 * def build_header_line(fields, record):             # <<<<<<<<<<<<<<
 *     '''build a header line from `fields` dictionary for `record`'''
 * 
 */
  __pyx_tuple__72 = PyTuple_Pack(4, __pyx_n_s_fields, __pyx_n_s_record, __pyx_n_s_line, __pyx_n_s_key); if (unlikely(!__pyx_tuple__72)) __PYX_ERR(0, 120, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_tuple__72);
  __Pyx_GIVEREF(__pyx_tuple__72);
  __pyx_codeobj_ = (PyObject*)__Pyx_PyCode_New(2, 0, 4, 0, 0, __pyx_empty_bytes, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_tuple__72, __pyx_empty_tuple, __pyx_empty_tuple, __pyx_kp_s_home_vagrant_Downloads_pysam_py, __pyx_n_s_build_header_line, 120, __pyx_empty_bytes); if (unlikely(!__pyx_codeobj_)) __PYX_ERR(0, 120, __pyx_L1_error)
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_InitGlobals(void) {
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_15 = PyInt_FromLong(15); if (unlikely(!__pyx_int_15)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_1796 = PyInt_FromLong(1796); if (unlikely(!__pyx_int_1796)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_8000 = PyInt_FromLong(8000); if (unlikely(!__pyx_int_8000)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_536870912 = PyInt_FromLong(536870912L); if (unlikely(!__pyx_int_536870912)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_neg_4 = PyInt_FromLong(-4); if (unlikely(!__pyx_int_neg_4)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_int_neg_5 = PyInt_FromLong(-5); if (unlikely(!__pyx_int_neg_5)) __PYX_ERR(0, 1, __pyx_L1_error)
  return 0;
  __pyx_L1_error:;
  return -1;
}

#if PY_MAJOR_VERSION < 3
PyMODINIT_FUNC initcalignmentfile(void); /*proto*/
PyMODINIT_FUNC initcalignmentfile(void)
#else
PyMODINIT_FUNC PyInit_calignmentfile(void); /*proto*/
PyMODINIT_FUNC PyInit_calignmentfile(void)
#endif
{
  __Pyx_TraceDeclarations
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannyDeclarations
  #if CYTHON_REFNANNY
  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
  if (!__Pyx_RefNanny) {
      PyErr_Clear();
      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
      if (!__Pyx_RefNanny)
          Py_FatalError("failed to import 'refnanny' module");
  }
  #endif
  __Pyx_RefNannySetupContext("PyMODINIT_FUNC PyInit_calignmentfile(void)", 0);
  if (__Pyx_check_binary_version() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_empty_unicode = PyUnicode_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_unicode)) __PYX_ERR(0, 1, __pyx_L1_error)
  #ifdef __Pyx_CyFunction_USED
  if (__pyx_CyFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_FusedFunction_USED
  if (__pyx_FusedFunction_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Coroutine_USED
  if (__pyx_Coroutine_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_Generator_USED
  if (__pyx_Generator_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  #ifdef __Pyx_StopAsyncIteration_USED
  if (__pyx_StopAsyncIteration_init() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  /*--- Library function declarations ---*/
  /*--- Threads initialization code ---*/
  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  #ifdef WITH_THREAD /* Python build with threading support? */
  PyEval_InitThreads();
  #endif
  #endif
  /*--- Module creation code ---*/
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4("calignmentfile", __pyx_methods, 0, 0, PYTHON_API_VERSION); Py_XINCREF(__pyx_m);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (unlikely(!__pyx_m)) __PYX_ERR(0, 1, __pyx_L1_error)
  __pyx_d = PyModule_GetDict(__pyx_m); if (unlikely(!__pyx_d)) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_INCREF(__pyx_d);
  __pyx_b = PyImport_AddModule(__Pyx_BUILTIN_MODULE_NAME); if (unlikely(!__pyx_b)) __PYX_ERR(0, 1, __pyx_L1_error)
  #if CYTHON_COMPILING_IN_PYPY
  Py_INCREF(__pyx_b);
  #endif
  if (PyObject_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) __PYX_ERR(0, 1, __pyx_L1_error);
  /*--- Initialize various global constants etc. ---*/
  if (__Pyx_InitGlobals() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #if PY_MAJOR_VERSION < 3 && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
  if (__Pyx_init_sys_getdefaultencoding_params() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  if (__pyx_module_is_main_pysam__calignmentfile) {
    if (PyObject_SetAttrString(__pyx_m, "__name__", __pyx_n_s_main) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  }
  #if PY_MAJOR_VERSION >= 3
  {
    PyObject *modules = PyImport_GetModuleDict(); if (unlikely(!modules)) __PYX_ERR(0, 1, __pyx_L1_error)
    if (!PyDict_GetItemString(modules, "pysam.calignmentfile")) {
      if (unlikely(PyDict_SetItemString(modules, "pysam.calignmentfile", __pyx_m) < 0)) __PYX_ERR(0, 1, __pyx_L1_error)
    }
  }
  #endif
  /*--- Builtin init code ---*/
  if (__Pyx_InitCachedBuiltins() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  /*--- Constants init code ---*/
  if (__Pyx_InitCachedConstants() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  /*--- Global init code ---*/
  /*--- Variable export code ---*/
  /*--- Function export code ---*/
  /*--- Type init code ---*/
  __pyx_vtabptr_5pysam_14calignmentfile_AlignmentFile = &__pyx_vtable_5pysam_14calignmentfile_AlignmentFile;
  __pyx_vtable_5pysam_14calignmentfile_AlignmentFile.getCurrent = (bam1_t *(*)(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *))__pyx_f_5pysam_14calignmentfile_13AlignmentFile_getCurrent;
  __pyx_vtable_5pysam_14calignmentfile_AlignmentFile.cnext = (int (*)(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *))__pyx_f_5pysam_14calignmentfile_13AlignmentFile_cnext;
  __pyx_vtable_5pysam_14calignmentfile_AlignmentFile.write = (int (*)(struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *, struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment *, int __pyx_skip_dispatch))__pyx_f_5pysam_14calignmentfile_13AlignmentFile_write;
  if (PyType_Ready(&__pyx_type_5pysam_14calignmentfile_AlignmentFile) < 0) __PYX_ERR(0, 217, __pyx_L1_error)
  __pyx_type_5pysam_14calignmentfile_AlignmentFile.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_5pysam_14calignmentfile_AlignmentFile.tp_dict, __pyx_vtabptr_5pysam_14calignmentfile_AlignmentFile) < 0) __PYX_ERR(0, 217, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "AlignmentFile", (PyObject *)&__pyx_type_5pysam_14calignmentfile_AlignmentFile) < 0) __PYX_ERR(0, 217, __pyx_L1_error)
  __pyx_ptype_5pysam_14calignmentfile_AlignmentFile = &__pyx_type_5pysam_14calignmentfile_AlignmentFile;
  if (PyType_Ready(&__pyx_type_5pysam_14calignmentfile_PileupColumn) < 0) __PYX_ERR(1, 72, __pyx_L1_error)
  __pyx_type_5pysam_14calignmentfile_PileupColumn.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "PileupColumn", (PyObject *)&__pyx_type_5pysam_14calignmentfile_PileupColumn) < 0) __PYX_ERR(1, 72, __pyx_L1_error)
  __pyx_ptype_5pysam_14calignmentfile_PileupColumn = &__pyx_type_5pysam_14calignmentfile_PileupColumn;
  if (PyType_Ready(&__pyx_type_5pysam_14calignmentfile_PileupRead) < 0) __PYX_ERR(1, 78, __pyx_L1_error)
  __pyx_type_5pysam_14calignmentfile_PileupRead.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "PileupRead", (PyObject *)&__pyx_type_5pysam_14calignmentfile_PileupRead) < 0) __PYX_ERR(1, 78, __pyx_L1_error)
  __pyx_ptype_5pysam_14calignmentfile_PileupRead = &__pyx_type_5pysam_14calignmentfile_PileupRead;
  if (PyType_Ready(&__pyx_type_5pysam_14calignmentfile_IteratorRow) < 0) __PYX_ERR(0, 1641, __pyx_L1_error)
  __pyx_type_5pysam_14calignmentfile_IteratorRow.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "IteratorRow", (PyObject *)&__pyx_type_5pysam_14calignmentfile_IteratorRow) < 0) __PYX_ERR(0, 1641, __pyx_L1_error)
  __pyx_ptype_5pysam_14calignmentfile_IteratorRow = &__pyx_type_5pysam_14calignmentfile_IteratorRow;
  __pyx_vtabptr_5pysam_14calignmentfile_IteratorRowRegion = &__pyx_vtable_5pysam_14calignmentfile_IteratorRowRegion;
  __pyx_vtable_5pysam_14calignmentfile_IteratorRowRegion.getCurrent = (bam1_t *(*)(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *))__pyx_f_5pysam_14calignmentfile_17IteratorRowRegion_getCurrent;
  __pyx_vtable_5pysam_14calignmentfile_IteratorRowRegion.cnext = (int (*)(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowRegion *))__pyx_f_5pysam_14calignmentfile_17IteratorRowRegion_cnext;
  __pyx_type_5pysam_14calignmentfile_IteratorRowRegion.tp_base = __pyx_ptype_5pysam_14calignmentfile_IteratorRow;
  if (PyType_Ready(&__pyx_type_5pysam_14calignmentfile_IteratorRowRegion) < 0) __PYX_ERR(0, 1705, __pyx_L1_error)
  __pyx_type_5pysam_14calignmentfile_IteratorRowRegion.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_5pysam_14calignmentfile_IteratorRowRegion.tp_dict, __pyx_vtabptr_5pysam_14calignmentfile_IteratorRowRegion) < 0) __PYX_ERR(0, 1705, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "IteratorRowRegion", (PyObject *)&__pyx_type_5pysam_14calignmentfile_IteratorRowRegion) < 0) __PYX_ERR(0, 1705, __pyx_L1_error)
  __pyx_ptype_5pysam_14calignmentfile_IteratorRowRegion = &__pyx_type_5pysam_14calignmentfile_IteratorRowRegion;
  __pyx_vtabptr_5pysam_14calignmentfile_IteratorRowHead = &__pyx_vtable_5pysam_14calignmentfile_IteratorRowHead;
  __pyx_vtable_5pysam_14calignmentfile_IteratorRowHead.getCurrent = (bam1_t *(*)(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead *))__pyx_f_5pysam_14calignmentfile_15IteratorRowHead_getCurrent;
  __pyx_vtable_5pysam_14calignmentfile_IteratorRowHead.cnext = (int (*)(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowHead *))__pyx_f_5pysam_14calignmentfile_15IteratorRowHead_cnext;
  __pyx_type_5pysam_14calignmentfile_IteratorRowHead.tp_base = __pyx_ptype_5pysam_14calignmentfile_IteratorRow;
  if (PyType_Ready(&__pyx_type_5pysam_14calignmentfile_IteratorRowHead) < 0) __PYX_ERR(0, 1766, __pyx_L1_error)
  __pyx_type_5pysam_14calignmentfile_IteratorRowHead.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_5pysam_14calignmentfile_IteratorRowHead.tp_dict, __pyx_vtabptr_5pysam_14calignmentfile_IteratorRowHead) < 0) __PYX_ERR(0, 1766, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "IteratorRowHead", (PyObject *)&__pyx_type_5pysam_14calignmentfile_IteratorRowHead) < 0) __PYX_ERR(0, 1766, __pyx_L1_error)
  __pyx_ptype_5pysam_14calignmentfile_IteratorRowHead = &__pyx_type_5pysam_14calignmentfile_IteratorRowHead;
  __pyx_vtabptr_5pysam_14calignmentfile_IteratorRowAll = &__pyx_vtable_5pysam_14calignmentfile_IteratorRowAll;
  __pyx_vtable_5pysam_14calignmentfile_IteratorRowAll.getCurrent = (bam1_t *(*)(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll *))__pyx_f_5pysam_14calignmentfile_14IteratorRowAll_getCurrent;
  __pyx_vtable_5pysam_14calignmentfile_IteratorRowAll.cnext = (int (*)(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowAll *))__pyx_f_5pysam_14calignmentfile_14IteratorRowAll_cnext;
  __pyx_type_5pysam_14calignmentfile_IteratorRowAll.tp_base = __pyx_ptype_5pysam_14calignmentfile_IteratorRow;
  if (PyType_Ready(&__pyx_type_5pysam_14calignmentfile_IteratorRowAll) < 0) __PYX_ERR(0, 1816, __pyx_L1_error)
  __pyx_type_5pysam_14calignmentfile_IteratorRowAll.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_5pysam_14calignmentfile_IteratorRowAll.tp_dict, __pyx_vtabptr_5pysam_14calignmentfile_IteratorRowAll) < 0) __PYX_ERR(0, 1816, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "IteratorRowAll", (PyObject *)&__pyx_type_5pysam_14calignmentfile_IteratorRowAll) < 0) __PYX_ERR(0, 1816, __pyx_L1_error)
  __pyx_ptype_5pysam_14calignmentfile_IteratorRowAll = &__pyx_type_5pysam_14calignmentfile_IteratorRowAll;
  __pyx_type_5pysam_14calignmentfile_IteratorRowAllRefs.tp_base = __pyx_ptype_5pysam_14calignmentfile_IteratorRow;
  if (PyType_Ready(&__pyx_type_5pysam_14calignmentfile_IteratorRowAllRefs) < 0) __PYX_ERR(0, 1860, __pyx_L1_error)
  __pyx_type_5pysam_14calignmentfile_IteratorRowAllRefs.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "IteratorRowAllRefs", (PyObject *)&__pyx_type_5pysam_14calignmentfile_IteratorRowAllRefs) < 0) __PYX_ERR(0, 1860, __pyx_L1_error)
  __pyx_ptype_5pysam_14calignmentfile_IteratorRowAllRefs = &__pyx_type_5pysam_14calignmentfile_IteratorRowAllRefs;
  __pyx_vtabptr_5pysam_14calignmentfile_IteratorRowSelection = &__pyx_vtable_5pysam_14calignmentfile_IteratorRowSelection;
  __pyx_vtable_5pysam_14calignmentfile_IteratorRowSelection.getCurrent = (bam1_t *(*)(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *))__pyx_f_5pysam_14calignmentfile_20IteratorRowSelection_getCurrent;
  __pyx_vtable_5pysam_14calignmentfile_IteratorRowSelection.cnext = (int (*)(struct __pyx_obj_5pysam_14calignmentfile_IteratorRowSelection *))__pyx_f_5pysam_14calignmentfile_20IteratorRowSelection_cnext;
  __pyx_type_5pysam_14calignmentfile_IteratorRowSelection.tp_base = __pyx_ptype_5pysam_14calignmentfile_IteratorRow;
  if (PyType_Ready(&__pyx_type_5pysam_14calignmentfile_IteratorRowSelection) < 0) __PYX_ERR(0, 1925, __pyx_L1_error)
  __pyx_type_5pysam_14calignmentfile_IteratorRowSelection.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_5pysam_14calignmentfile_IteratorRowSelection.tp_dict, __pyx_vtabptr_5pysam_14calignmentfile_IteratorRowSelection) < 0) __PYX_ERR(0, 1925, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "IteratorRowSelection", (PyObject *)&__pyx_type_5pysam_14calignmentfile_IteratorRowSelection) < 0) __PYX_ERR(0, 1925, __pyx_L1_error)
  __pyx_ptype_5pysam_14calignmentfile_IteratorRowSelection = &__pyx_type_5pysam_14calignmentfile_IteratorRowSelection;
  __pyx_vtabptr_5pysam_14calignmentfile_IteratorColumn = &__pyx_vtable_5pysam_14calignmentfile_IteratorColumn;
  __pyx_vtable_5pysam_14calignmentfile_IteratorColumn.cnext = (int (*)(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *))__pyx_f_5pysam_14calignmentfile_14IteratorColumn_cnext;
  __pyx_vtable_5pysam_14calignmentfile_IteratorColumn.getSequence = (char *(*)(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *))__pyx_f_5pysam_14calignmentfile_14IteratorColumn_getSequence;
  __pyx_vtable_5pysam_14calignmentfile_IteratorColumn.setMask = (PyObject *(*)(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *, PyObject *))__pyx_f_5pysam_14calignmentfile_14IteratorColumn_setMask;
  __pyx_vtable_5pysam_14calignmentfile_IteratorColumn.setupIteratorData = (PyObject *(*)(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *, int, int, int, struct __pyx_opt_args_5pysam_14calignmentfile_14IteratorColumn_setupIteratorData *__pyx_optional_args))__pyx_f_5pysam_14calignmentfile_14IteratorColumn_setupIteratorData;
  __pyx_vtable_5pysam_14calignmentfile_IteratorColumn.reset = (PyObject *(*)(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *, PyObject *, PyObject *, PyObject *))__pyx_f_5pysam_14calignmentfile_14IteratorColumn_reset;
  __pyx_vtable_5pysam_14calignmentfile_IteratorColumn._free_pileup_iter = (PyObject *(*)(struct __pyx_obj_5pysam_14calignmentfile_IteratorColumn *))__pyx_f_5pysam_14calignmentfile_14IteratorColumn__free_pileup_iter;
  if (PyType_Ready(&__pyx_type_5pysam_14calignmentfile_IteratorColumn) < 0) __PYX_ERR(0, 2076, __pyx_L1_error)
  __pyx_type_5pysam_14calignmentfile_IteratorColumn.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_5pysam_14calignmentfile_IteratorColumn.tp_dict, __pyx_vtabptr_5pysam_14calignmentfile_IteratorColumn) < 0) __PYX_ERR(0, 2076, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "IteratorColumn", (PyObject *)&__pyx_type_5pysam_14calignmentfile_IteratorColumn) < 0) __PYX_ERR(0, 2076, __pyx_L1_error)
  __pyx_ptype_5pysam_14calignmentfile_IteratorColumn = &__pyx_type_5pysam_14calignmentfile_IteratorColumn;
  __pyx_vtabptr_5pysam_14calignmentfile_IteratorColumnRegion = &__pyx_vtable_5pysam_14calignmentfile_IteratorColumnRegion;
  __pyx_vtable_5pysam_14calignmentfile_IteratorColumnRegion.__pyx_base = *__pyx_vtabptr_5pysam_14calignmentfile_IteratorColumn;
  __pyx_type_5pysam_14calignmentfile_IteratorColumnRegion.tp_base = __pyx_ptype_5pysam_14calignmentfile_IteratorColumn;
  if (PyType_Ready(&__pyx_type_5pysam_14calignmentfile_IteratorColumnRegion) < 0) __PYX_ERR(0, 2270, __pyx_L1_error)
  __pyx_type_5pysam_14calignmentfile_IteratorColumnRegion.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_5pysam_14calignmentfile_IteratorColumnRegion.tp_dict, __pyx_vtabptr_5pysam_14calignmentfile_IteratorColumnRegion) < 0) __PYX_ERR(0, 2270, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "IteratorColumnRegion", (PyObject *)&__pyx_type_5pysam_14calignmentfile_IteratorColumnRegion) < 0) __PYX_ERR(0, 2270, __pyx_L1_error)
  __pyx_ptype_5pysam_14calignmentfile_IteratorColumnRegion = &__pyx_type_5pysam_14calignmentfile_IteratorColumnRegion;
  __pyx_vtabptr_5pysam_14calignmentfile_IteratorColumnAllRefs = &__pyx_vtable_5pysam_14calignmentfile_IteratorColumnAllRefs;
  __pyx_vtable_5pysam_14calignmentfile_IteratorColumnAllRefs.__pyx_base = *__pyx_vtabptr_5pysam_14calignmentfile_IteratorColumn;
  __pyx_type_5pysam_14calignmentfile_IteratorColumnAllRefs.tp_base = __pyx_ptype_5pysam_14calignmentfile_IteratorColumn;
  if (PyType_Ready(&__pyx_type_5pysam_14calignmentfile_IteratorColumnAllRefs) < 0) __PYX_ERR(0, 2307, __pyx_L1_error)
  __pyx_type_5pysam_14calignmentfile_IteratorColumnAllRefs.tp_print = 0;
  if (__Pyx_SetVtable(__pyx_type_5pysam_14calignmentfile_IteratorColumnAllRefs.tp_dict, __pyx_vtabptr_5pysam_14calignmentfile_IteratorColumnAllRefs) < 0) __PYX_ERR(0, 2307, __pyx_L1_error)
  if (PyObject_SetAttrString(__pyx_m, "IteratorColumnAllRefs", (PyObject *)&__pyx_type_5pysam_14calignmentfile_IteratorColumnAllRefs) < 0) __PYX_ERR(0, 2307, __pyx_L1_error)
  __pyx_ptype_5pysam_14calignmentfile_IteratorColumnAllRefs = &__pyx_type_5pysam_14calignmentfile_IteratorColumnAllRefs;
  if (PyType_Ready(&__pyx_type_5pysam_14calignmentfile_IndexedReads) < 0) __PYX_ERR(0, 2405, __pyx_L1_error)
  __pyx_type_5pysam_14calignmentfile_IndexedReads.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "IndexedReads", (PyObject *)&__pyx_type_5pysam_14calignmentfile_IndexedReads) < 0) __PYX_ERR(0, 2405, __pyx_L1_error)
  __pyx_ptype_5pysam_14calignmentfile_IndexedReads = &__pyx_type_5pysam_14calignmentfile_IndexedReads;
  if (PyType_Ready(&__pyx_type_5pysam_14calignmentfile_SNPCall) < 0) __PYX_ERR(0, 2346, __pyx_L1_error)
  __pyx_type_5pysam_14calignmentfile_SNPCall.tp_print = 0;
  if (PyObject_SetAttrString(__pyx_m, "SNPCall", (PyObject *)&__pyx_type_5pysam_14calignmentfile_SNPCall) < 0) __PYX_ERR(0, 2346, __pyx_L1_error)
  __pyx_ptype_5pysam_14calignmentfile_SNPCall = &__pyx_type_5pysam_14calignmentfile_SNPCall;
  /*--- Type import code ---*/
  __pyx_ptype_7cpython_4type_type = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "type", 
  #if CYTHON_COMPILING_IN_PYPY
  sizeof(PyTypeObject),
  #else
  sizeof(PyHeapTypeObject),
  #endif
  0); if (unlikely(!__pyx_ptype_7cpython_4type_type)) __PYX_ERR(3, 9, __pyx_L1_error)
  __pyx_ptype_7cpython_4bool_bool = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "bool", sizeof(PyBoolObject), 0); if (unlikely(!__pyx_ptype_7cpython_4bool_bool)) __PYX_ERR(4, 8, __pyx_L1_error)
  __pyx_ptype_7cpython_7complex_complex = __Pyx_ImportType(__Pyx_BUILTIN_MODULE_NAME, "complex", sizeof(PyComplexObject), 0); if (unlikely(!__pyx_ptype_7cpython_7complex_complex)) __PYX_ERR(5, 15, __pyx_L1_error)
  __pyx_ptype_7cpython_5array_array = __Pyx_ImportType("array", "array", sizeof(arrayobject), 0); if (unlikely(!__pyx_ptype_7cpython_5array_array)) __PYX_ERR(2, 58, __pyx_L1_error)
  __pyx_ptype_5pysam_6cfaidx_FastaFile = __Pyx_ImportType("pysam.cfaidx", "FastaFile", sizeof(struct __pyx_obj_5pysam_6cfaidx_FastaFile), 1); if (unlikely(!__pyx_ptype_5pysam_6cfaidx_FastaFile)) __PYX_ERR(6, 40, __pyx_L1_error)
  __pyx_vtabptr_5pysam_6cfaidx_FastaFile = (struct __pyx_vtabstruct_5pysam_6cfaidx_FastaFile*)__Pyx_GetVtable(__pyx_ptype_5pysam_6cfaidx_FastaFile->tp_dict); if (unlikely(!__pyx_vtabptr_5pysam_6cfaidx_FastaFile)) __PYX_ERR(6, 40, __pyx_L1_error)
  __pyx_ptype_5pysam_6cfaidx_FastqProxy = __Pyx_ImportType("pysam.cfaidx", "FastqProxy", sizeof(struct __pyx_obj_5pysam_6cfaidx_FastqProxy), 1); if (unlikely(!__pyx_ptype_5pysam_6cfaidx_FastqProxy)) __PYX_ERR(6, 48, __pyx_L1_error)
  __pyx_vtabptr_5pysam_6cfaidx_FastqProxy = (struct __pyx_vtabstruct_5pysam_6cfaidx_FastqProxy*)__Pyx_GetVtable(__pyx_ptype_5pysam_6cfaidx_FastqProxy->tp_dict); if (unlikely(!__pyx_vtabptr_5pysam_6cfaidx_FastqProxy)) __PYX_ERR(6, 48, __pyx_L1_error)
  __pyx_ptype_5pysam_6cfaidx_PersistentFastqProxy = __Pyx_ImportType("pysam.cfaidx", "PersistentFastqProxy", sizeof(struct __pyx_obj_5pysam_6cfaidx_PersistentFastqProxy), 1); if (unlikely(!__pyx_ptype_5pysam_6cfaidx_PersistentFastqProxy)) __PYX_ERR(6, 54, __pyx_L1_error)
  __pyx_vtabptr_5pysam_6cfaidx_PersistentFastqProxy = (struct __pyx_vtabstruct_5pysam_6cfaidx_PersistentFastqProxy*)__Pyx_GetVtable(__pyx_ptype_5pysam_6cfaidx_PersistentFastqProxy->tp_dict); if (unlikely(!__pyx_vtabptr_5pysam_6cfaidx_PersistentFastqProxy)) __PYX_ERR(6, 54, __pyx_L1_error)
  __pyx_ptype_5pysam_6cfaidx_FastxFile = __Pyx_ImportType("pysam.cfaidx", "FastxFile", sizeof(struct __pyx_obj_5pysam_6cfaidx_FastxFile), 1); if (unlikely(!__pyx_ptype_5pysam_6cfaidx_FastxFile)) __PYX_ERR(6, 63, __pyx_L1_error)
  __pyx_vtabptr_5pysam_6cfaidx_FastxFile = (struct __pyx_vtabstruct_5pysam_6cfaidx_FastxFile*)__Pyx_GetVtable(__pyx_ptype_5pysam_6cfaidx_FastxFile->tp_dict); if (unlikely(!__pyx_vtabptr_5pysam_6cfaidx_FastxFile)) __PYX_ERR(6, 63, __pyx_L1_error)
  __pyx_ptype_5pysam_6cfaidx_FastqFile = __Pyx_ImportType("pysam.cfaidx", "FastqFile", sizeof(struct __pyx_obj_5pysam_6cfaidx_FastqFile), 1); if (unlikely(!__pyx_ptype_5pysam_6cfaidx_FastqFile)) __PYX_ERR(6, 74, __pyx_L1_error)
  __pyx_vtabptr_5pysam_6cfaidx_FastqFile = (struct __pyx_vtabstruct_5pysam_6cfaidx_FastqFile*)__Pyx_GetVtable(__pyx_ptype_5pysam_6cfaidx_FastqFile->tp_dict); if (unlikely(!__pyx_vtabptr_5pysam_6cfaidx_FastqFile)) __PYX_ERR(6, 74, __pyx_L1_error)
  __pyx_ptype_5pysam_6cfaidx_Fastafile = __Pyx_ImportType("pysam.cfaidx", "Fastafile", sizeof(struct __pyx_obj_5pysam_6cfaidx_Fastafile), 1); if (unlikely(!__pyx_ptype_5pysam_6cfaidx_Fastafile)) __PYX_ERR(6, 79, __pyx_L1_error)
  __pyx_vtabptr_5pysam_6cfaidx_Fastafile = (struct __pyx_vtabstruct_5pysam_6cfaidx_Fastafile*)__Pyx_GetVtable(__pyx_ptype_5pysam_6cfaidx_Fastafile->tp_dict); if (unlikely(!__pyx_vtabptr_5pysam_6cfaidx_Fastafile)) __PYX_ERR(6, 79, __pyx_L1_error)
  __pyx_ptype_5pysam_15calignedsegment_AlignedSegment = __Pyx_ImportType("pysam.calignedsegment", "AlignedSegment", sizeof(struct __pyx_obj_5pysam_15calignedsegment_AlignedSegment), 1); if (unlikely(!__pyx_ptype_5pysam_15calignedsegment_AlignedSegment)) __PYX_ERR(7, 40, __pyx_L1_error)
  __pyx_vtabptr_5pysam_15calignedsegment_AlignedSegment = (struct __pyx_vtabstruct_5pysam_15calignedsegment_AlignedSegment*)__Pyx_GetVtable(__pyx_ptype_5pysam_15calignedsegment_AlignedSegment->tp_dict); if (unlikely(!__pyx_vtabptr_5pysam_15calignedsegment_AlignedSegment)) __PYX_ERR(7, 40, __pyx_L1_error)
  __pyx_ptype_5pysam_15calignedsegment_PileupColumn = __Pyx_ImportType("pysam.calignedsegment", "PileupColumn", sizeof(struct __pyx_obj_5pysam_15calignedsegment_PileupColumn), 1); if (unlikely(!__pyx_ptype_5pysam_15calignedsegment_PileupColumn)) __PYX_ERR(7, 69, __pyx_L1_error)
  __pyx_ptype_5pysam_15calignedsegment_PileupRead = __Pyx_ImportType("pysam.calignedsegment", "PileupRead", sizeof(struct __pyx_obj_5pysam_15calignedsegment_PileupRead), 1); if (unlikely(!__pyx_ptype_5pysam_15calignedsegment_PileupRead)) __PYX_ERR(7, 77, __pyx_L1_error)
  /*--- Variable import code ---*/
  /*--- Function import code ---*/
  __pyx_t_1 = __Pyx_ImportModule("pysam.calignedsegment"); if (!__pyx_t_1) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ImportFunction(__pyx_t_1, "makeAlignedSegment", (void (**)(void))&__pyx_f_5pysam_15calignedsegment_makeAlignedSegment, "PyObject *(bam1_t *, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ImportFunction(__pyx_t_1, "makePileupColumn", (void (**)(void))&__pyx_f_5pysam_15calignedsegment_makePileupColumn, "PyObject *(bam_pileup1_t **, int, int, int, struct __pyx_obj_5pysam_14calignmentfile_AlignmentFile *)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_t_2 = __Pyx_ImportModule("pysam.cutils"); if (!__pyx_t_2) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ImportFunction(__pyx_t_2, "charptr_to_str", (void (**)(void))&__pyx_f_5pysam_6cutils_charptr_to_str, "PyObject *(char const *, struct __pyx_opt_args_5pysam_6cutils_charptr_to_str *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ImportFunction(__pyx_t_2, "force_str", (void (**)(void))&__pyx_f_5pysam_6cutils_force_str, "PyObject *(PyObject *, struct __pyx_opt_args_5pysam_6cutils_force_str *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ImportFunction(__pyx_t_2, "force_bytes", (void (**)(void))&__pyx_f_5pysam_6cutils_force_bytes, "PyObject *(PyObject *, struct __pyx_opt_args_5pysam_6cutils_force_bytes *__pyx_optional_args)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ImportFunction(__pyx_t_2, "encode_filename", (void (**)(void))&__pyx_f_5pysam_6cutils_encode_filename, "PyObject *(PyObject *)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  if (__Pyx_ImportFunction(__pyx_t_2, "from_string_and_size", (void (**)(void))&__pyx_f_5pysam_6cutils_from_string_and_size, "PyObject *(char const *, size_t)") < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  Py_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  /*--- Execution code ---*/
  #if defined(__Pyx_Generator_USED) || defined(__Pyx_Coroutine_USED)
  if (__Pyx_patch_abc() < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  #endif
  __Pyx_TraceCall("PyMODINIT_FUNC PyInit_calignmentfile(void)", __pyx_f[0], 1, 0, __PYX_ERR(0, 1, __pyx_L1_error));

  /* "pysam/calignmentfile.pyx":55
 * #
 * ########################################################
 * import os             # <<<<<<<<<<<<<<
 * import collections
 * import re
 */
  __pyx_t_3 = __Pyx_Import(__pyx_n_s_os, 0, -1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 55, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_os, __pyx_t_3) < 0) __PYX_ERR(0, 55, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "pysam/calignmentfile.pyx":56
 * ########################################################
 * import os
 * import collections             # <<<<<<<<<<<<<<
 * import re
 * import warnings
 */
  __pyx_t_3 = __Pyx_Import(__pyx_n_s_collections, 0, -1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 56, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_collections, __pyx_t_3) < 0) __PYX_ERR(0, 56, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "pysam/calignmentfile.pyx":57
 * import os
 * import collections
 * import re             # <<<<<<<<<<<<<<
 * import warnings
 * import array
 */
  __pyx_t_3 = __Pyx_Import(__pyx_n_s_re, 0, -1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 57, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_re, __pyx_t_3) < 0) __PYX_ERR(0, 57, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "pysam/calignmentfile.pyx":58
 * import collections
 * import re
 * import warnings             # <<<<<<<<<<<<<<
 * import array
 * 
 */
  __pyx_t_3 = __Pyx_Import(__pyx_n_s_warnings, 0, -1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 58, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_warnings, __pyx_t_3) < 0) __PYX_ERR(0, 58, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "pysam/calignmentfile.pyx":59
 * import re
 * import warnings
 * import array             # <<<<<<<<<<<<<<
 * 
 * from cpython cimport array as c_array
 */
  __pyx_t_3 = __Pyx_Import(__pyx_n_s_array, 0, -1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 59, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_array, __pyx_t_3) < 0) __PYX_ERR(0, 59, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "pysam/calignmentfile.pyx":69
 * from pysam.chtslib cimport hisremote
 * 
 * if PY_MAJOR_VERSION >= 3:             # <<<<<<<<<<<<<<
 *     from io import StringIO
 * else:
 */
  __pyx_t_4 = ((PY_MAJOR_VERSION >= 3) != 0);
  if (__pyx_t_4) {

    /* "pysam/calignmentfile.pyx":70
 * 
 * if PY_MAJOR_VERSION >= 3:
 *     from io import StringIO             # <<<<<<<<<<<<<<
 * else:
 *     from StringIO import StringIO
 */
    __pyx_t_3 = PyList_New(1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 70, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_INCREF(__pyx_n_s_StringIO);
    __Pyx_GIVEREF(__pyx_n_s_StringIO);
    PyList_SET_ITEM(__pyx_t_3, 0, __pyx_n_s_StringIO);
    __pyx_t_5 = __Pyx_Import(__pyx_n_s_io, __pyx_t_3, -1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 70, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = __Pyx_ImportFrom(__pyx_t_5, __pyx_n_s_StringIO); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 70, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    if (PyDict_SetItem(__pyx_d, __pyx_n_s_StringIO, __pyx_t_3) < 0) __PYX_ERR(0, 70, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

    /* "pysam/calignmentfile.pyx":69
 * from pysam.chtslib cimport hisremote
 * 
 * if PY_MAJOR_VERSION >= 3:             # <<<<<<<<<<<<<<
 *     from io import StringIO
 * else:
 */
    goto __pyx_L2;
  }

  /* "pysam/calignmentfile.pyx":72
 *     from io import StringIO
 * else:
 *     from StringIO import StringIO             # <<<<<<<<<<<<<<
 * 
 * cimport cython
 */
  /*else*/ {
    __pyx_t_5 = PyList_New(1); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 72, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_INCREF(__pyx_n_s_StringIO);
    __Pyx_GIVEREF(__pyx_n_s_StringIO);
    PyList_SET_ITEM(__pyx_t_5, 0, __pyx_n_s_StringIO);
    __pyx_t_3 = __Pyx_Import(__pyx_n_s_StringIO, __pyx_t_5, -1); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 72, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __pyx_t_5 = __Pyx_ImportFrom(__pyx_t_3, __pyx_n_s_StringIO); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 72, __pyx_L1_error)
    __Pyx_GOTREF(__pyx_t_5);
    if (PyDict_SetItem(__pyx_d, __pyx_n_s_StringIO, __pyx_t_5) < 0) __PYX_ERR(0, 72, __pyx_L1_error)
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  }
  __pyx_L2:;

  /* "pysam/calignmentfile.pyx":85
 * 
 * # maximum genomic coordinace
 * cdef int MAX_POS = 2 << 29             # <<<<<<<<<<<<<<
 * 
 * # valid types for SAM headers
 */
  __pyx_v_5pysam_14calignmentfile_MAX_POS = 0x40000000;

  /* "pysam/calignmentfile.pyx":88
 * 
 * # valid types for SAM headers
 * VALID_HEADER_TYPES = {"HD" : dict,             # <<<<<<<<<<<<<<
 *                       "SQ" : list,
 *                       "RG" : list,
 */
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 88, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_HD, ((PyObject *)(&PyDict_Type))) < 0) __PYX_ERR(0, 88, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":89
 * # valid types for SAM headers
 * VALID_HEADER_TYPES = {"HD" : dict,
 *                       "SQ" : list,             # <<<<<<<<<<<<<<
 *                       "RG" : list,
 *                       "PG" : list,
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_SQ, ((PyObject *)(&PyList_Type))) < 0) __PYX_ERR(0, 88, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":90
 * VALID_HEADER_TYPES = {"HD" : dict,
 *                       "SQ" : list,
 *                       "RG" : list,             # <<<<<<<<<<<<<<
 *                       "PG" : list,
 *                       "CO" : list}
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_RG, ((PyObject *)(&PyList_Type))) < 0) __PYX_ERR(0, 88, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":91
 *                       "SQ" : list,
 *                       "RG" : list,
 *                       "PG" : list,             # <<<<<<<<<<<<<<
 *                       "CO" : list}
 * 
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_PG, ((PyObject *)(&PyList_Type))) < 0) __PYX_ERR(0, 88, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":92
 *                       "RG" : list,
 *                       "PG" : list,
 *                       "CO" : list}             # <<<<<<<<<<<<<<
 * 
 * # order of records within SAM headers
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_CO, ((PyObject *)(&PyList_Type))) < 0) __PYX_ERR(0, 88, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_VALID_HEADER_TYPES, __pyx_t_3) < 0) __PYX_ERR(0, 88, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "pysam/calignmentfile.pyx":95
 * 
 * # order of records within SAM headers
 * VALID_HEADERS = ("HD", "SQ", "RG", "PG", "CO")             # <<<<<<<<<<<<<<
 * 
 * # default type conversions within SAM header records
 */
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_VALID_HEADERS, __pyx_tuple__67) < 0) __PYX_ERR(0, 95, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":98
 * 
 * # default type conversions within SAM header records
 * KNOWN_HEADER_FIELDS = {"HD" : {"VN" : str, "SO" : str, "GO" : str},             # <<<<<<<<<<<<<<
 *                        "SQ" : {"SN" : str, "LN" : int, "AS" : str,
 *                                "M5" : str, "SP" : str, "UR" : str,},
 */
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 98, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_5 = PyDict_New(); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 98, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_VN, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 98, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_SO, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 98, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_GO, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 98, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_HD, __pyx_t_5) < 0) __PYX_ERR(0, 98, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

  /* "pysam/calignmentfile.pyx":99
 * # default type conversions within SAM header records
 * KNOWN_HEADER_FIELDS = {"HD" : {"VN" : str, "SO" : str, "GO" : str},
 *                        "SQ" : {"SN" : str, "LN" : int, "AS" : str,             # <<<<<<<<<<<<<<
 *                                "M5" : str, "SP" : str, "UR" : str,},
 *                        "RG" : {"ID" : str, "CN" : str, "DS" : str,
 */
  __pyx_t_5 = PyDict_New(); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 99, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_SN, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_LN, ((PyObject *)(&PyInt_Type))) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_AS, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 99, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":100
 * KNOWN_HEADER_FIELDS = {"HD" : {"VN" : str, "SO" : str, "GO" : str},
 *                        "SQ" : {"SN" : str, "LN" : int, "AS" : str,
 *                                "M5" : str, "SP" : str, "UR" : str,},             # <<<<<<<<<<<<<<
 *                        "RG" : {"ID" : str, "CN" : str, "DS" : str,
 *                                "DT" : str, "FO" : str, "KS" : str,
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_M5, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_SP, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_UR, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 99, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_SQ, __pyx_t_5) < 0) __PYX_ERR(0, 98, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

  /* "pysam/calignmentfile.pyx":101
 *                        "SQ" : {"SN" : str, "LN" : int, "AS" : str,
 *                                "M5" : str, "SP" : str, "UR" : str,},
 *                        "RG" : {"ID" : str, "CN" : str, "DS" : str,             # <<<<<<<<<<<<<<
 *                                "DT" : str, "FO" : str, "KS" : str,
 *                                "LB" : str, "PG" : str, "PI" : str,
 */
  __pyx_t_5 = PyDict_New(); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 101, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_ID, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 101, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_CN, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 101, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_DS, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 101, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":102
 *                                "M5" : str, "SP" : str, "UR" : str,},
 *                        "RG" : {"ID" : str, "CN" : str, "DS" : str,
 *                                "DT" : str, "FO" : str, "KS" : str,             # <<<<<<<<<<<<<<
 *                                "LB" : str, "PG" : str, "PI" : str,
 *                                "PL" : str, "PM" : str, "PU" : str,
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_DT, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 101, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_FO, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 101, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_KS, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 101, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":103
 *                        "RG" : {"ID" : str, "CN" : str, "DS" : str,
 *                                "DT" : str, "FO" : str, "KS" : str,
 *                                "LB" : str, "PG" : str, "PI" : str,             # <<<<<<<<<<<<<<
 *                                "PL" : str, "PM" : str, "PU" : str,
 *                                "SM" : str,},
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_LB, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 101, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_PG, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 101, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_PI, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 101, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":104
 *                                "DT" : str, "FO" : str, "KS" : str,
 *                                "LB" : str, "PG" : str, "PI" : str,
 *                                "PL" : str, "PM" : str, "PU" : str,             # <<<<<<<<<<<<<<
 *                                "SM" : str,},
 *                        "PG" : {"ID" : str, "PN" : str, "CL" : str,
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_PL, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 101, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_PM, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 101, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_PU, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 101, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":105
 *                                "LB" : str, "PG" : str, "PI" : str,
 *                                "PL" : str, "PM" : str, "PU" : str,
 *                                "SM" : str,},             # <<<<<<<<<<<<<<
 *                        "PG" : {"ID" : str, "PN" : str, "CL" : str,
 *                                "PP" : str, "DS" : str, "VN" : str,},}
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_SM, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 101, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_RG, __pyx_t_5) < 0) __PYX_ERR(0, 98, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;

  /* "pysam/calignmentfile.pyx":106
 *                                "PL" : str, "PM" : str, "PU" : str,
 *                                "SM" : str,},
 *                        "PG" : {"ID" : str, "PN" : str, "CL" : str,             # <<<<<<<<<<<<<<
 *                                "PP" : str, "DS" : str, "VN" : str,},}
 * 
 */
  __pyx_t_5 = PyDict_New(); if (unlikely(!__pyx_t_5)) __PYX_ERR(0, 106, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_5);
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_ID, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 106, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_PN, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 106, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_CL, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 106, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":107
 *                                "SM" : str,},
 *                        "PG" : {"ID" : str, "PN" : str, "CL" : str,
 *                                "PP" : str, "DS" : str, "VN" : str,},}             # <<<<<<<<<<<<<<
 * 
 * # output order of fields within records
 */
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_PP, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 106, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_DS, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 106, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_5, __pyx_n_s_VN, ((PyObject *)(&PyString_Type))) < 0) __PYX_ERR(0, 106, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_PG, __pyx_t_5) < 0) __PYX_ERR(0, 98, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_KNOWN_HEADER_FIELDS, __pyx_t_3) < 0) __PYX_ERR(0, 98, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "pysam/calignmentfile.pyx":110
 * 
 * # output order of fields within records
 * VALID_HEADER_ORDER = {"HD" : ("VN", "SO", "GO"),             # <<<<<<<<<<<<<<
 *                       "SQ" : ("SN", "LN", "AS", "M5",
 *                                "UR", "SP"),
 */
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 110, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_HD, __pyx_tuple__68) < 0) __PYX_ERR(0, 110, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":111
 * # output order of fields within records
 * VALID_HEADER_ORDER = {"HD" : ("VN", "SO", "GO"),
 *                       "SQ" : ("SN", "LN", "AS", "M5",             # <<<<<<<<<<<<<<
 *                                "UR", "SP"),
 *                       "RG" : ("ID", "SM", "LB", "DS",
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_SQ, __pyx_tuple__69) < 0) __PYX_ERR(0, 110, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":113
 *                       "SQ" : ("SN", "LN", "AS", "M5",
 *                                "UR", "SP"),
 *                       "RG" : ("ID", "SM", "LB", "DS",             # <<<<<<<<<<<<<<
 *                               "PU", "PI", "CN", "DT",
 *                               "PL", "FO", "KS", "PG"),
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_RG, __pyx_tuple__70) < 0) __PYX_ERR(0, 110, __pyx_L1_error)

  /* "pysam/calignmentfile.pyx":116
 *                               "PU", "PI", "CN", "DT",
 *                               "PL", "FO", "KS", "PG"),
 *                       "PG" : ("PN", "ID", "VN", "CL",             # <<<<<<<<<<<<<<
 *                               "PP"),}
 * 
 */
  if (PyDict_SetItem(__pyx_t_3, __pyx_n_s_PG, __pyx_tuple__71) < 0) __PYX_ERR(0, 110, __pyx_L1_error)
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_VALID_HEADER_ORDER, __pyx_t_3) < 0) __PYX_ERR(0, 110, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "pysam/calignmentfile.pyx":120
 * 
 * 
 * def build_header_line(fields, record):             # <<<<<<<<<<<<<<
 *     '''build a header line from `fields` dictionary for `record`'''
 * 
 */
  __pyx_t_3 = PyCFunction_NewEx(&__pyx_mdef_5pysam_14calignmentfile_1build_header_line, NULL, __pyx_n_s_pysam_calignmentfile); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 120, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_build_header_line, __pyx_t_3) < 0) __PYX_ERR(0, 120, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "pysam/calignmentfile.pyx":2276
 *                   int tid = 0,
 *                   int start = 0,
 *                   int end = MAX_POS,             # <<<<<<<<<<<<<<
 *                   int truncate = False,
 *                   **kwargs ):
 */
  __pyx_k__64 = __pyx_v_5pysam_14calignmentfile_MAX_POS;

  /* "pysam/calignmentfile.pyx":2507
 *             bam_hdr_destroy(self.header)
 * 
 * __all__ = [             # <<<<<<<<<<<<<<
 *     "AlignmentFile",
 *     "IteratorRow",
 */
  __pyx_t_3 = PyList_New(4); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 2507, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_INCREF(__pyx_n_s_AlignmentFile);
  __Pyx_GIVEREF(__pyx_n_s_AlignmentFile);
  PyList_SET_ITEM(__pyx_t_3, 0, __pyx_n_s_AlignmentFile);
  __Pyx_INCREF(__pyx_n_s_IteratorRow);
  __Pyx_GIVEREF(__pyx_n_s_IteratorRow);
  PyList_SET_ITEM(__pyx_t_3, 1, __pyx_n_s_IteratorRow);
  __Pyx_INCREF(__pyx_n_s_IteratorColumn);
  __Pyx_GIVEREF(__pyx_n_s_IteratorColumn);
  PyList_SET_ITEM(__pyx_t_3, 2, __pyx_n_s_IteratorColumn);
  __Pyx_INCREF(__pyx_n_s_IndexedReads);
  __Pyx_GIVEREF(__pyx_n_s_IndexedReads);
  PyList_SET_ITEM(__pyx_t_3, 3, __pyx_n_s_IndexedReads);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_all_2, __pyx_t_3) < 0) __PYX_ERR(0, 2507, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "pysam/calignmentfile.pyx":1
 * # cython: embedsignature=True             # <<<<<<<<<<<<<<
 * # cython: profile=True
 * ########################################################
 */
  __pyx_t_3 = PyDict_New(); if (unlikely(!__pyx_t_3)) __PYX_ERR(0, 1, __pyx_L1_error)
  __Pyx_GOTREF(__pyx_t_3);
  if (PyDict_SetItem(__pyx_d, __pyx_n_s_test, __pyx_t_3) < 0) __PYX_ERR(0, 1, __pyx_L1_error)
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "array.pxd":159
 *     return extend_buffer(self, other.data.as_chars, Py_SIZE(other))
 * 
 * cdef inline void zero(array self):             # <<<<<<<<<<<<<<
 *     """ set all elements of array to zero. """
 *     memset(self.data.as_chars, 0, Py_SIZE(self) * self.ob_descr.itemsize)
 */
  __Pyx_TraceReturn(Py_None, 0);

  /*--- Wrapped vars code ---*/

  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_5);
  if (__pyx_m) {
    if (__pyx_d) {
      __Pyx_AddTraceback("init pysam.calignmentfile", __pyx_clineno, __pyx_lineno, __pyx_filename);
    }
    Py_DECREF(__pyx_m); __pyx_m = 0;
  } else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_ImportError, "init pysam.calignmentfile");
  }
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  #if PY_MAJOR_VERSION < 3
  return;
  #else
  return __pyx_m;
  #endif
}

/* --- Runtime support code --- */
/* Refnanny */
#if CYTHON_REFNANNY
static __Pyx_RefNannyAPIStruct *__Pyx_RefNannyImportAPI(const char *modname) {
    PyObject *m = NULL, *p = NULL;
    void *r = NULL;
    m = PyImport_ImportModule((char *)modname);
    if (!m) goto end;
    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
    if (!p) goto end;
    r = PyLong_AsVoidPtr(p);
end:
    Py_XDECREF(p);
    Py_XDECREF(m);
    return (__Pyx_RefNannyAPIStruct *)r;
}
#endif

/* GetBuiltinName */
static PyObject *__Pyx_GetBuiltinName(PyObject *name) {
    PyObject* result = __Pyx_PyObject_GetAttrStr(__pyx_b, name);
    if (unlikely(!result)) {
        PyErr_Format(PyExc_NameError,
#if PY_MAJOR_VERSION >= 3
            "name '%U' is not defined", name);
#else
            "name '%.200s' is not defined", PyString_AS_STRING(name));
#endif
    }
    return result;
}

/* RaiseArgTupleInvalid */
static void __Pyx_RaiseArgtupleInvalid(
    const char* func_name,
    int exact,
    Py_ssize_t num_min,
    Py_ssize_t num_max,
    Py_ssize_t num_found)
{
    Py_ssize_t num_expected;
    const char *more_or_less;
    if (num_found < num_min) {
        num_expected = num_min;
        more_or_less = "at least";
    } else {
        num_expected = num_max;
        more_or_less = "at most";
    }
    if (exact) {
        more_or_less = "exactly";
    }
    PyErr_Format(PyExc_TypeError,
                 "%.200s() takes %.8s %" CYTHON_FORMAT_SSIZE_T "d positional argument%.1s (%" CYTHON_FORMAT_SSIZE_T "d given)",
                 func_name, more_or_less, num_expected,
                 (num_expected == 1) ? "" : "s", num_found);
}

/* RaiseDoubleKeywords */
static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name,
    PyObject* kw_name)
{
    PyErr_Format(PyExc_TypeError,
        #if PY_MAJOR_VERSION >= 3
        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
        #else
        "%s() got multiple values for keyword argument '%s'", func_name,
        PyString_AsString(kw_name));
        #endif
}

/* ParseKeywords */
static int __Pyx_ParseOptionalKeywords(
    PyObject *kwds,
    PyObject **argnames[],
    PyObject *kwds2,
    PyObject *values[],
    Py_ssize_t num_pos_args,
    const char* function_name)
{
    PyObject *key = 0, *value = 0;
    Py_ssize_t pos = 0;
    PyObject*** name;
    PyObject*** first_kw_arg = argnames + num_pos_args;
    while (PyDict_Next(kwds, &pos, &key, &value)) {
        name = first_kw_arg;
        while (*name && (**name != key)) name++;
        if (*name) {
            values[name-argnames] = value;
            continue;
        }
        name = first_kw_arg;
        #if PY_MAJOR_VERSION < 3
        if (likely(PyString_CheckExact(key)) || likely(PyString_Check(key))) {
            while (*name) {
                if ((CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**name) == PyString_GET_SIZE(key))
                        && _PyString_Eq(**name, key)) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    if ((**argname == key) || (
                            (CYTHON_COMPILING_IN_PYPY || PyString_GET_SIZE(**argname) == PyString_GET_SIZE(key))
                             && _PyString_Eq(**argname, key))) {
                        goto arg_passed_twice;
                    }
                    argname++;
                }
            }
        } else
        #endif
        if (likely(PyUnicode_Check(key))) {
            while (*name) {
                int cmp = (**name == key) ? 0 :
                #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                    (PyUnicode_GET_SIZE(**name) != PyUnicode_GET_SIZE(key)) ? 1 :
                #endif
                    PyUnicode_Compare(**name, key);
                if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                if (cmp == 0) {
                    values[name-argnames] = value;
                    break;
                }
                name++;
            }
            if (*name) continue;
            else {
                PyObject*** argname = argnames;
                while (argname != first_kw_arg) {
                    int cmp = (**argname == key) ? 0 :
                    #if !CYTHON_COMPILING_IN_PYPY && PY_MAJOR_VERSION >= 3
                        (PyUnicode_GET_SIZE(**argname) != PyUnicode_GET_SIZE(key)) ? 1 :
                    #endif
                        PyUnicode_Compare(**argname, key);
                    if (cmp < 0 && unlikely(PyErr_Occurred())) goto bad;
                    if (cmp == 0) goto arg_passed_twice;
                    argname++;
                }
            }
        } else
            goto invalid_keyword_type;
        if (kwds2) {
            if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
        } else {
            goto invalid_keyword;
        }
    }
    return 0;
arg_passed_twice:
    __Pyx_RaiseDoubleKeywordsError(function_name, key);
    goto bad;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    goto bad;
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
bad:
    return -1;
}

/* Profile */
#if CYTHON_PROFILE
static int __Pyx_TraceSetupAndCall(PyCodeObject** code,
                                   PyFrameObject** frame,
                                   const char *funcname,
                                   const char *srcfile,
                                   int firstlineno) {
    PyObject *type, *value, *traceback;
    int retval;
    PyThreadState* tstate = PyThreadState_GET();
    if (*frame == NULL || !CYTHON_PROFILE_REUSE_FRAME) {
        if (*code == NULL) {
            *code = __Pyx_createFrameCodeObject(funcname, srcfile, firstlineno);
            if (*code == NULL) return 0;
        }
        *frame = PyFrame_New(
            tstate,                          /*PyThreadState *tstate*/
            *code,                           /*PyCodeObject *code*/
            __pyx_d,                  /*PyObject *globals*/
            0                                /*PyObject *locals*/
        );
        if (*frame == NULL) return 0;
        if (CYTHON_TRACE && (*frame)->f_trace == NULL) {
            Py_INCREF(Py_None);
            (*frame)->f_trace = Py_None;
        }
#if PY_VERSION_HEX < 0x030400B1
    } else {
        (*frame)->f_tstate = tstate;
#endif
    }
    (*frame)->f_lineno = firstlineno;
    retval = 1;
    tstate->tracing++;
    tstate->use_tracing = 0;
    PyErr_Fetch(&type, &value, &traceback);
    #if CYTHON_TRACE
    if (tstate->c_tracefunc)
        retval = tstate->c_tracefunc(tstate->c_traceobj, *frame, PyTrace_CALL, NULL) == 0;
    if (retval && tstate->c_profilefunc)
    #endif
        retval = tstate->c_profilefunc(tstate->c_profileobj, *frame, PyTrace_CALL, NULL) == 0;
    tstate->use_tracing = (tstate->c_profilefunc ||
                           (CYTHON_TRACE && tstate->c_tracefunc));
    tstate->tracing--;
    if (retval) {
        PyErr_Restore(type, value, traceback);
        return tstate->use_tracing && retval;
    } else {
        Py_XDECREF(type);
        Py_XDECREF(value);
        Py_XDECREF(traceback);
        return -1;
    }
}
static PyCodeObject *__Pyx_createFrameCodeObject(const char *funcname, const char *srcfile, int firstlineno) {
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    PyCodeObject *py_code = 0;
    #if PY_MAJOR_VERSION < 3
    py_funcname = PyString_FromString(funcname);
    py_srcfile = PyString_FromString(srcfile);
    #else
    py_funcname = PyUnicode_FromString(funcname);
    py_srcfile = PyUnicode_FromString(srcfile);
    #endif
    if (!py_funcname | !py_srcfile) goto bad;
    py_code = PyCode_New(
        0,
        #if PY_MAJOR_VERSION >= 3
        0,
        #endif
        0,
        0,
        0,
        __pyx_empty_bytes,     /*PyObject *code,*/
        __pyx_empty_tuple,     /*PyObject *consts,*/
        __pyx_empty_tuple,     /*PyObject *names,*/
        __pyx_empty_tuple,     /*PyObject *varnames,*/
        __pyx_empty_tuple,     /*PyObject *freevars,*/
        __pyx_empty_tuple,     /*PyObject *cellvars,*/
        py_srcfile,       /*PyObject *filename,*/
        py_funcname,      /*PyObject *name,*/
        firstlineno,
        __pyx_empty_bytes      /*PyObject *lnotab*/
    );
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    return py_code;
}
#endif

/* BytesEquals */
static CYTHON_INLINE int __Pyx_PyBytes_Equals(PyObject* s1, PyObject* s2, int equals) {
#if CYTHON_COMPILING_IN_PYPY
    return PyObject_RichCompareBool(s1, s2, equals);
#else
    if (s1 == s2) {
        return (equals == Py_EQ);
    } else if (PyBytes_CheckExact(s1) & PyBytes_CheckExact(s2)) {
        const char *ps1, *ps2;
        Py_ssize_t length = PyBytes_GET_SIZE(s1);
        if (length != PyBytes_GET_SIZE(s2))
            return (equals == Py_NE);
        ps1 = PyBytes_AS_STRING(s1);
        ps2 = PyBytes_AS_STRING(s2);
        if (ps1[0] != ps2[0]) {
            return (equals == Py_NE);
        } else if (length == 1) {
            return (equals == Py_EQ);
        } else {
            int result = memcmp(ps1, ps2, (size_t)length);
            return (equals == Py_EQ) ? (result == 0) : (result != 0);
        }
    } else if ((s1 == Py_None) & PyBytes_CheckExact(s2)) {
        return (equals == Py_NE);
    } else if ((s2 == Py_None) & PyBytes_CheckExact(s1)) {
        return (equals == Py_NE);
    } else {
        int result;
        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
        if (!py_result)
            return -1;
        result = __Pyx_PyObject_IsTrue(py_result);
        Py_DECREF(py_result);
        return result;
    }
#endif
}

/* UnicodeEquals */
static CYTHON_INLINE int __Pyx_PyUnicode_Equals(PyObject* s1, PyObject* s2, int equals) {
#if CYTHON_COMPILING_IN_PYPY
    return PyObject_RichCompareBool(s1, s2, equals);
#else
#if PY_MAJOR_VERSION < 3
    PyObject* owned_ref = NULL;
#endif
    int s1_is_unicode, s2_is_unicode;
    if (s1 == s2) {
        goto return_eq;
    }
    s1_is_unicode = PyUnicode_CheckExact(s1);
    s2_is_unicode = PyUnicode_CheckExact(s2);
#if PY_MAJOR_VERSION < 3
    if ((s1_is_unicode & (!s2_is_unicode)) && PyString_CheckExact(s2)) {
        owned_ref = PyUnicode_FromObject(s2);
        if (unlikely(!owned_ref))
            return -1;
        s2 = owned_ref;
        s2_is_unicode = 1;
    } else if ((s2_is_unicode & (!s1_is_unicode)) && PyString_CheckExact(s1)) {
        owned_ref = PyUnicode_FromObject(s1);
        if (unlikely(!owned_ref))
            return -1;
        s1 = owned_ref;
        s1_is_unicode = 1;
    } else if (((!s2_is_unicode) & (!s1_is_unicode))) {
        return __Pyx_PyBytes_Equals(s1, s2, equals);
    }
#endif
    if (s1_is_unicode & s2_is_unicode) {
        Py_ssize_t length;
        int kind;
        void *data1, *data2;
        if (unlikely(__Pyx_PyUnicode_READY(s1) < 0) || unlikely(__Pyx_PyUnicode_READY(s2) < 0))
            return -1;
        length = __Pyx_PyUnicode_GET_LENGTH(s1);
        if (length != __Pyx_PyUnicode_GET_LENGTH(s2)) {
            goto return_ne;
        }
        kind = __Pyx_PyUnicode_KIND(s1);
        if (kind != __Pyx_PyUnicode_KIND(s2)) {
            goto return_ne;
        }
        data1 = __Pyx_PyUnicode_DATA(s1);
        data2 = __Pyx_PyUnicode_DATA(s2);
        if (__Pyx_PyUnicode_READ(kind, data1, 0) != __Pyx_PyUnicode_READ(kind, data2, 0)) {
            goto return_ne;
        } else if (length == 1) {
            goto return_eq;
        } else {
            int result = memcmp(data1, data2, (size_t)(length * kind));
            #if PY_MAJOR_VERSION < 3
            Py_XDECREF(owned_ref);
            #endif
            return (equals == Py_EQ) ? (result == 0) : (result != 0);
        }
    } else if ((s1 == Py_None) & s2_is_unicode) {
        goto return_ne;
    } else if ((s2 == Py_None) & s1_is_unicode) {
        goto return_ne;
    } else {
        int result;
        PyObject* py_result = PyObject_RichCompare(s1, s2, equals);
        if (!py_result)
            return -1;
        result = __Pyx_PyObject_IsTrue(py_result);
        Py_DECREF(py_result);
        return result;
    }
return_eq:
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(owned_ref);
    #endif
    return (equals == Py_EQ);
return_ne:
    #if PY_MAJOR_VERSION < 3
    Py_XDECREF(owned_ref);
    #endif
    return (equals == Py_NE);
#endif
}

/* PyObjectCall */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_Call(PyObject *func, PyObject *arg, PyObject *kw) {
    PyObject *result;
    ternaryfunc call = func->ob_type->tp_call;
    if (unlikely(!call))
        return PyObject_Call(func, arg, kw);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = (*call)(func, arg, kw);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

/* PyObjectCallMethO */
#if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallMethO(PyObject *func, PyObject *arg) {
    PyObject *self, *result;
    PyCFunction cfunc;
    cfunc = PyCFunction_GET_FUNCTION(func);
    self = PyCFunction_GET_SELF(func);
    if (unlikely(Py_EnterRecursiveCall((char*)" while calling a Python object")))
        return NULL;
    result = cfunc(self, arg);
    Py_LeaveRecursiveCall();
    if (unlikely(!result) && unlikely(!PyErr_Occurred())) {
        PyErr_SetString(
            PyExc_SystemError,
            "NULL result without error in PyObject_Call");
    }
    return result;
}
#endif

/* PyObjectCallOneArg */
#if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx__PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_New(1);
    if (unlikely(!args)) return NULL;
    Py_INCREF(arg);
    PyTuple_SET_ITEM(args, 0, arg);
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
#ifdef __Pyx_CyFunction_USED
    if (likely(PyCFunction_Check(func) || PyObject_TypeCheck(func, __pyx_CyFunctionType))) {
#else
    if (likely(PyCFunction_Check(func))) {
#endif
        if (likely(PyCFunction_GET_FLAGS(func) & METH_O)) {
            return __Pyx_PyObject_CallMethO(func, arg);
        }
    }
    return __Pyx__PyObject_CallOneArg(func, arg);
}
#else
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallOneArg(PyObject *func, PyObject *arg) {
    PyObject *result;
    PyObject *args = PyTuple_Pack(1, arg);
    if (unlikely(!args)) return NULL;
    result = __Pyx_PyObject_Call(func, args, NULL);
    Py_DECREF(args);
    return result;
}
#endif

/* PyObjectCallNoArg */
  #if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyObject_CallNoArg(PyObject *func) {
#ifdef __Pyx_CyFunction_USED
    if (likely(PyCFunction_Check(func) || PyObject_TypeCheck(func, __pyx_CyFunctionType))) {
#else
    if (likely(PyCFunction_Check(func))) {
#endif
        if (likely(PyCFunction_GET_FLAGS(func) & METH_NOARGS)) {
            return __Pyx_PyObject_CallMethO(func, NULL);
        }
    }
    return __Pyx_PyObject_Call(func, __pyx_empty_tuple, NULL);
}
#endif

/* GetModuleGlobalName */
    static CYTHON_INLINE PyObject *__Pyx_GetModuleGlobalName(PyObject *name) {
    PyObject *result;
#if CYTHON_COMPILING_IN_CPYTHON
    result = PyDict_GetItem(__pyx_d, name);
    if (likely(result)) {
        Py_INCREF(result);
    } else {
#else
    result = PyObject_GetItem(__pyx_d, name);
    if (!result) {
        PyErr_Clear();
#endif
        result = __Pyx_GetBuiltinName(name);
    }
    return result;
}

/* StringJoin */
      #if !CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE PyObject* __Pyx_PyBytes_Join(PyObject* sep, PyObject* values) {
    return PyObject_CallMethodObjArgs(sep, __pyx_n_s_join, values, NULL);
}
#endif

/* PyErrFetchRestore */
      #if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE void __Pyx_ErrRestoreInState(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    tmp_type = tstate->curexc_type;
    tmp_value = tstate->curexc_value;
    tmp_tb = tstate->curexc_traceback;
    tstate->curexc_type = type;
    tstate->curexc_value = value;
    tstate->curexc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}
static CYTHON_INLINE void __Pyx_ErrFetchInState(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
}
#endif

/* RaiseException */
      #if PY_MAJOR_VERSION < 3
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb,
                        CYTHON_UNUSED PyObject *cause) {
    __Pyx_PyThreadState_declare
    Py_XINCREF(type);
    if (!value || value == Py_None)
        value = NULL;
    else
        Py_INCREF(value);
    if (!tb || tb == Py_None)
        tb = NULL;
    else {
        Py_INCREF(tb);
        if (!PyTraceBack_Check(tb)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: arg 3 must be a traceback or None");
            goto raise_error;
        }
    }
    if (PyType_Check(type)) {
#if CYTHON_COMPILING_IN_PYPY
        if (!value) {
            Py_INCREF(Py_None);
            value = Py_None;
        }
#endif
        PyErr_NormalizeException(&type, &value, &tb);
    } else {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        value = type;
        type = (PyObject*) Py_TYPE(type);
        Py_INCREF(type);
        if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
            PyErr_SetString(PyExc_TypeError,
                "raise: exception class must be a subclass of BaseException");
            goto raise_error;
        }
    }
    __Pyx_PyThreadState_assign
    __Pyx_ErrRestore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}
#else
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb, PyObject *cause) {
    PyObject* owned_instance = NULL;
    if (tb == Py_None) {
        tb = 0;
    } else if (tb && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto bad;
    }
    if (value == Py_None)
        value = 0;
    if (PyExceptionInstance_Check(type)) {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto bad;
        }
        value = type;
        type = (PyObject*) Py_TYPE(value);
    } else if (PyExceptionClass_Check(type)) {
        PyObject *instance_class = NULL;
        if (value && PyExceptionInstance_Check(value)) {
            instance_class = (PyObject*) Py_TYPE(value);
            if (instance_class != type) {
                int is_subclass = PyObject_IsSubclass(instance_class, type);
                if (!is_subclass) {
                    instance_class = NULL;
                } else if (unlikely(is_subclass == -1)) {
                    goto bad;
                } else {
                    type = instance_class;
                }
            }
        }
        if (!instance_class) {
            PyObject *args;
            if (!value)
                args = PyTuple_New(0);
            else if (PyTuple_Check(value)) {
                Py_INCREF(value);
                args = value;
            } else
                args = PyTuple_Pack(1, value);
            if (!args)
                goto bad;
            owned_instance = PyObject_Call(type, args, NULL);
            Py_DECREF(args);
            if (!owned_instance)
                goto bad;
            value = owned_instance;
            if (!PyExceptionInstance_Check(value)) {
                PyErr_Format(PyExc_TypeError,
                             "calling %R should have returned an instance of "
                             "BaseException, not %R",
                             type, Py_TYPE(value));
                goto bad;
            }
        }
    } else {
        PyErr_SetString(PyExc_TypeError,
            "raise: exception class must be a subclass of BaseException");
        goto bad;
    }
#if PY_VERSION_HEX >= 0x03030000
    if (cause) {
#else
    if (cause && cause != Py_None) {
#endif
        PyObject *fixed_cause;
        if (cause == Py_None) {
            fixed_cause = NULL;
        } else if (PyExceptionClass_Check(cause)) {
            fixed_cause = PyObject_CallObject(cause, NULL);
            if (fixed_cause == NULL)
                goto bad;
        } else if (PyExceptionInstance_Check(cause)) {
            fixed_cause = cause;
            Py_INCREF(fixed_cause);
        } else {
            PyErr_SetString(PyExc_TypeError,
                            "exception causes must derive from "
                            "BaseException");
            goto bad;
        }
        PyException_SetCause(value, fixed_cause);
    }
    PyErr_SetObject(type, value);
    if (tb) {
#if CYTHON_COMPILING_IN_PYPY
        PyObject *tmp_type, *tmp_value, *tmp_tb;
        PyErr_Fetch(&tmp_type, &tmp_value, &tmp_tb);
        Py_INCREF(tb);
        PyErr_Restore(tmp_type, tmp_value, tb);
        Py_XDECREF(tmp_tb);
#else
        PyThreadState *tstate = PyThreadState_GET();
        PyObject* tmp_tb = tstate->curexc_traceback;
        if (tb != tmp_tb) {
            Py_INCREF(tb);
            tstate->curexc_traceback = tb;
            Py_XDECREF(tmp_tb);
        }
#endif
    }
bad:
    Py_XDECREF(owned_instance);
    return;
}
#endif

/* RaiseTooManyValuesToUnpack */
        static CYTHON_INLINE void __Pyx_RaiseTooManyValuesError(Py_ssize_t expected) {
    PyErr_Format(PyExc_ValueError,
                 "too many values to unpack (expected %" CYTHON_FORMAT_SSIZE_T "d)", expected);
}

/* RaiseNeedMoreValuesToUnpack */
        static CYTHON_INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
    PyErr_Format(PyExc_ValueError,
                 "need more than %" CYTHON_FORMAT_SSIZE_T "d value%.1s to unpack",
                 index, (index == 1) ? "" : "s");
}

/* IterFinish */
        static CYTHON_INLINE int __Pyx_IterFinish(void) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyThreadState *tstate = PyThreadState_GET();
    PyObject* exc_type = tstate->curexc_type;
    if (unlikely(exc_type)) {
        if (likely(exc_type == PyExc_StopIteration) || PyErr_GivenExceptionMatches(exc_type, PyExc_StopIteration)) {
            PyObject *exc_value, *exc_tb;
            exc_value = tstate->curexc_value;
            exc_tb = tstate->curexc_traceback;
            tstate->curexc_type = 0;
            tstate->curexc_value = 0;
            tstate->curexc_traceback = 0;
            Py_DECREF(exc_type);
            Py_XDECREF(exc_value);
            Py_XDECREF(exc_tb);
            return 0;
        } else {
            return -1;
        }
    }
    return 0;
#else
    if (unlikely(PyErr_Occurred())) {
        if (likely(PyErr_ExceptionMatches(PyExc_StopIteration))) {
            PyErr_Clear();
            return 0;
        } else {
            return -1;
        }
    }
    return 0;
#endif
}

/* UnpackItemEndCheck */
        static int __Pyx_IternextUnpackEndCheck(PyObject *retval, Py_ssize_t expected) {
    if (unlikely(retval)) {
        Py_DECREF(retval);
        __Pyx_RaiseTooManyValuesError(expected);
        return -1;
    } else {
        return __Pyx_IterFinish();
    }
    return 0;
}

/* SaveResetException */
        #if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
    *type = tstate->exc_type;
    *value = tstate->exc_value;
    *tb = tstate->exc_traceback;
    Py_XINCREF(*type);
    Py_XINCREF(*value);
    Py_XINCREF(*tb);
}
static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = type;
    tstate->exc_value = value;
    tstate->exc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}
#endif

/* PyErrExceptionMatches */
        #if CYTHON_COMPILING_IN_CPYTHON
static CYTHON_INLINE int __Pyx_PyErr_ExceptionMatchesInState(PyThreadState* tstate, PyObject* err) {
    PyObject *exc_type = tstate->curexc_type;
    if (exc_type == err) return 1;
    if (unlikely(!exc_type)) return 0;
    return PyErr_GivenExceptionMatches(exc_type, err);
}
#endif

/* GetException */
        #if CYTHON_COMPILING_IN_CPYTHON
static int __Pyx__GetException(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
#else
static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb) {
#endif
    PyObject *local_type, *local_value, *local_tb;
#if CYTHON_COMPILING_IN_CPYTHON
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    local_type = tstate->curexc_type;
    local_value = tstate->curexc_value;
    local_tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
#else
    PyErr_Fetch(&local_type, &local_value, &local_tb);
#endif
    PyErr_NormalizeException(&local_type, &local_value, &local_tb);
#if CYTHON_COMPILING_IN_CPYTHON
    if (unlikely(tstate->curexc_type))
#else
    if (unlikely(PyErr_Occurred()))
#endif
        goto bad;
    #if PY_MAJOR_VERSION >= 3
    if (local_tb) {
        if (unlikely(PyException_SetTraceback(local_value, local_tb) < 0))
            goto bad;
    }
    #endif
    Py_XINCREF(local_tb);
    Py_XINCREF(local_type);
    Py_XINCREF(local_value);
    *type = local_type;
    *value = local_value;
    *tb = local_tb;
#if CYTHON_COMPILING_IN_CPYTHON
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = local_type;
    tstate->exc_value = local_value;
    tstate->exc_traceback = local_tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
#else
    PyErr_SetExcInfo(local_type, local_value, local_tb);
#endif
    return 0;
bad:
    *type = 0;
    *value = 0;
    *tb = 0;
    Py_XDECREF(local_type);
    Py_XDECREF(local_value);
    Py_XDECREF(local_tb);
    return -1;
}

/* GetItemInt */
          static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
    PyObject *r;
    if (!j) return NULL;
    r = PyObject_GetItem(o, j);
    Py_DECREF(j);
    return r;
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i,
                                                              CYTHON_NCP_UNUSED int wraparound,
                                                              CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_COMPILING_IN_CPYTHON
    if (wraparound & unlikely(i < 0)) i += PyList_GET_SIZE(o);
    if ((!boundscheck) || likely((0 <= i) & (i < PyList_GET_SIZE(o)))) {
        PyObject *r = PyList_GET_ITEM(o, i);
        Py_INCREF(r);
        return r;
    }
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
#else
    return PySequence_GetItem(o, i);
#endif
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i,
                                                              CYTHON_NCP_UNUSED int wraparound,
                                                              CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_COMPILING_IN_CPYTHON
    if (wraparound & unlikely(i < 0)) i += PyTuple_GET_SIZE(o);
    if ((!boundscheck) || likely((0 <= i) & (i < PyTuple_GET_SIZE(o)))) {
        PyObject *r = PyTuple_GET_ITEM(o, i);
        Py_INCREF(r);
        return r;
    }
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
#else
    return PySequence_GetItem(o, i);
#endif
}
static CYTHON_INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i, int is_list,
                                                     CYTHON_NCP_UNUSED int wraparound,
                                                     CYTHON_NCP_UNUSED int boundscheck) {
#if CYTHON_COMPILING_IN_CPYTHON
    if (is_list || PyList_CheckExact(o)) {
        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyList_GET_SIZE(o);
        if ((!boundscheck) || (likely((n >= 0) & (n < PyList_GET_SIZE(o))))) {
            PyObject *r = PyList_GET_ITEM(o, n);
            Py_INCREF(r);
            return r;
        }
    }
    else if (PyTuple_CheckExact(o)) {
        Py_ssize_t n = ((!wraparound) | likely(i >= 0)) ? i : i + PyTuple_GET_SIZE(o);
        if ((!boundscheck) || likely((n >= 0) & (n < PyTuple_GET_SIZE(o)))) {
            PyObject *r = PyTuple_GET_ITEM(o, n);
            Py_INCREF(r);
            return r;
        }
    } else {
        PySequenceMethods *m = Py_TYPE(o)->tp_as_sequence;
        if (likely(m && m->sq_item)) {
            if (wraparound && unlikely(i < 0) && likely(m->sq_length)) {
                Py_ssize_t l = m->sq_length(o);
                if (likely(l >= 0)) {
                    i += l;
                } else {
                    if (!PyErr_ExceptionMatches(PyExc_OverflowError))
                        return NULL;
                    PyErr_Clear();
                }
            }
            return m->sq_item(o, i);
        }
    }
#else
    if (is_list || PySequence_Check(o)) {
        return PySequence_GetItem(o, i);
    }
#endif
    return __Pyx_GetItemInt_Generic(o, PyInt_FromSsize_t(i));
}

/* WriteUnraisableException */
          static void __Pyx_WriteUnraisable(const char *name, CYTHON_UNUSED int clineno,
                                  CYTHON_UNUSED int lineno, CYTHON_UNUSED const char *filename,
                                  int full_traceback, CYTHON_UNUSED int nogil) {
    PyObject *old_exc, *old_val, *old_tb;
    PyObject *ctx;
    __Pyx_PyThreadState_declare
#ifdef WITH_THREAD
    PyGILState_STATE state;
    if (nogil)
        state = PyGILState_Ensure();
#ifdef _MSC_VER
    else state = (PyGILState_STATE)-1;
#endif
#endif
    __Pyx_PyThreadState_assign
    __Pyx_ErrFetch(&old_exc, &old_val, &old_tb);
    if (full_traceback) {
        Py_XINCREF(old_exc);
        Py_XINCREF(old_val);
        Py_XINCREF(old_tb);
        __Pyx_ErrRestore(old_exc, old_val, old_tb);
        PyErr_PrintEx(1);
    }
    #if PY_MAJOR_VERSION < 3
    ctx = PyString_FromString(name);
    #else
    ctx = PyUnicode_FromString(name);
    #endif
    __Pyx_ErrRestore(old_exc, old_val, old_tb);
    if (!ctx) {
        PyErr_WriteUnraisable(Py_None);
    } else {
        PyErr_WriteUnraisable(ctx);
        Py_DECREF(ctx);
    }
#ifdef WITH_THREAD
    if (nogil)
        PyGILState_Release(state);
#endif
}

/* KeywordStringCheck */
          static CYTHON_INLINE int __Pyx_CheckKeywordStrings(
    PyObject *kwdict,
    const char* function_name,
    int kw_allowed)
{
    PyObject* key = 0;
    Py_ssize_t pos = 0;
#if CYTHON_COMPILING_IN_PYPY
    if (!kw_allowed && PyDict_Next(kwdict, &pos, &key, 0))
        goto invalid_keyword;
    return 1;
#else
    while (PyDict_Next(kwdict, &pos, &key, 0)) {
        #if PY_MAJOR_VERSION < 3
        if (unlikely(!PyString_CheckExact(key)) && unlikely(!PyString_Check(key)))
        #endif
            if (unlikely(!PyUnicode_Check(key)))
                goto invalid_keyword_type;
    }
    if ((!kw_allowed) && unlikely(key))
        goto invalid_keyword;
    return 1;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%.200s() keywords must be strings", function_name);
    return 0;
#endif
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%.200s() got an unexpected keyword argument '%.200s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
    return 0;
}

/* ArgTypeTest */
          static void __Pyx_RaiseArgumentTypeInvalid(const char* name, PyObject *obj, PyTypeObject *type) {
    PyErr_Format(PyExc_TypeError,
        "Argument '%.200s' has incorrect type (expected %.200s, got %.200s)",
        name, type->tp_name, Py_TYPE(obj)->tp_name);
}
static CYTHON_INLINE int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
    const char *name, int exact)
{
    if (unlikely(!type)) {
        PyErr_SetString(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (none_allowed && obj == Py_None) return 1;
    else if (exact) {
        if (likely(Py_TYPE(obj) == type)) return 1;
        #if PY_MAJOR_VERSION == 2
        else if ((type == &PyBaseString_Type) && likely(__Pyx_PyBaseString_CheckExact(obj))) return 1;
        #endif
    }
    else {
        if (likely(PyObject_TypeCheck(obj, type))) return 1;
    }
    __Pyx_RaiseArgumentTypeInvalid(name, obj, type);
    return 0;
}

/* PyObjectCallMethod1 */
          static PyObject* __Pyx_PyObject_CallMethod1(PyObject* obj, PyObject* method_name, PyObject* arg) {
    PyObject *method, *result = NULL;
    method = __Pyx_PyObject_GetAttrStr(obj, method_name);
    if (unlikely(!method)) goto bad;
#if CYTHON_COMPILING_IN_CPYTHON
    if (likely(PyMethod_Check(method))) {
        PyObject *self = PyMethod_GET_SELF(method);
        if (likely(self)) {
            PyObject *args;
            PyObject *function = PyMethod_GET_FUNCTION(method);
            args = PyTuple_New(2);
            if (unlikely(!args)) goto bad;
            Py_INCREF(self);
            PyTuple_SET_ITEM(args, 0, self);
            Py_INCREF(arg);
            PyTuple_SET_ITEM(args, 1, arg);
            Py_INCREF(function);
            Py_DECREF(method); method = NULL;
            result = __Pyx_PyObject_Call(function, args, NULL);
            Py_DECREF(args);
            Py_DECREF(function);
            return result;
        }
    }
#endif
    result = __Pyx_PyObject_CallOneArg(method, arg);
bad:
    Py_XDECREF(method);
    return result;
}

/* append */
          static CYTHON_INLINE int __Pyx_PyObject_Append(PyObject* L, PyObject* x) {
    if (likely(PyList_CheckExact(L))) {
        if (unlikely(__Pyx_PyList_Append(L, x) < 0)) return -1;
    } else {
        PyObject* retval = __Pyx_PyObject_CallMethod1(L, __pyx_n_s_append, x);
        if (unlikely(!retval))
            return -1;
        Py_DECREF(retval);
    }
    return 0;
}

/* SliceObject */
          static CYTHON_INLINE PyObject* __Pyx_PyObject_GetSlice(PyObject* obj,
        Py_ssize_t cstart, Py_ssize_t cstop,
        PyObject** _py_start, PyObject** _py_stop, PyObject** _py_slice,
        int has_cstart, int has_cstop, CYTHON_UNUSED int wraparound) {
#if CYTHON_COMPILING_IN_CPYTHON
    PyMappingMethods* mp;
#if PY_MAJOR_VERSION < 3
    PySequenceMethods* ms = Py_TYPE(obj)->tp_as_sequence;
    if (likely(ms && ms->sq_slice)) {
        if (!has_cstart) {
            if (_py_start && (*_py_start != Py_None)) {
                cstart = __Pyx_PyIndex_AsSsize_t(*_py_start);
                if ((cstart == (Py_ssize_t)-1) && PyErr_Occurred()) goto bad;
            } else
                cstart = 0;
        }
        if (!has_cstop) {
            if (_py_stop && (*_py_stop != Py_None)) {
                cstop = __Pyx_PyIndex_AsSsize_t(*_py_stop);
                if ((cstop == (Py_ssize_t)-1) && PyErr_Occurred()) goto bad;
            } else
                cstop = PY_SSIZE_T_MAX;
        }
        if (wraparound && unlikely((cstart < 0) | (cstop < 0)) && likely(ms->sq_length)) {
            Py_ssize_t l = ms->sq_length(obj);
            if (likely(l >= 0)) {
                if (cstop < 0) {
                    cstop += l;
                    if (cstop < 0) cstop = 0;
                }
                if (cstart < 0) {
                    cstart += l;
                    if (cstart < 0) cstart = 0;
                }
            } else {
                if (!PyErr_ExceptionMatches(PyExc_OverflowError))
                    goto bad;
                PyErr_Clear();
            }
        }
        return ms->sq_slice(obj, cstart, cstop);
    }
#endif
    mp = Py_TYPE(obj)->tp_as_mapping;
    if (likely(mp && mp->mp_subscript))
#endif
    {
        PyObject* result;
        PyObject *py_slice, *py_start, *py_stop;
        if (_py_slice) {
            py_slice = *_py_slice;
        } else {
            PyObject* owned_start = NULL;
            PyObject* owned_stop = NULL;
            if (_py_start) {
                py_start = *_py_start;
            } else {
                if (has_cstart) {
                    owned_start = py_start = PyInt_FromSsize_t(cstart);
                    if (unlikely(!py_start)) goto bad;
                } else
                    py_start = Py_None;
            }
            if (_py_stop) {
                py_stop = *_py_stop;
            } else {
                if (has_cstop) {
                    owned_stop = py_stop = PyInt_FromSsize_t(cstop);
                    if (unlikely(!py_stop)) {
                        Py_XDECREF(owned_start);
                        goto bad;
                    }
                } else
                    py_stop = Py_None;
            }
            py_slice = PySlice_New(py_start, py_stop, Py_None);
            Py_XDECREF(owned_start);
            Py_XDECREF(owned_stop);
            if (unlikely(!py_slice)) goto bad;
        }
#if CYTHON_COMPILING_IN_CPYTHON
        result = mp->mp_subscript(obj, py_slice);
#else
        result = PyObject_GetItem(obj, py_slice);
#endif
        if (!_py_slice) {
            Py_DECREF(py_slice);
        }
        return result;
    }
    PyErr_Format(PyExc_TypeError,
        "'%.200s' object is unsliceable", Py_TYPE(obj)->tp_name);
bad:
    return NULL;
}

/* PyIntBinop */
          #if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx_PyInt_SubtractObjC(PyObject *op1, PyObject *op2, CYTHON_UNUSED long intval, CYTHON_UNUSED int inplace) {
    #if PY_MAJOR_VERSION < 3
    if (likely(PyInt_CheckExact(op1))) {
        const long b = intval;
        long x;
        long a = PyInt_AS_LONG(op1);
            x = (long)((unsigned long)a - b);
            if (likely((x^a) >= 0 || (x^~b) >= 0))
                return PyInt_FromLong(x);
            return PyLong_Type.tp_as_number->nb_subtract(op1, op2);
    }
    #endif
    #if CYTHON_USE_PYLONG_INTERNALS && PY_MAJOR_VERSION >= 3
    if (likely(PyLong_CheckExact(op1))) {
        const long b = intval;
        long a, x;
        const PY_LONG_LONG llb = intval;
        PY_LONG_LONG lla, llx;
        const digit* digits = ((PyLongObject*)op1)->ob_digit;
        const Py_ssize_t size = Py_SIZE(op1);
        if (likely(__Pyx_sst_abs(size) <= 1)) {
            a = likely(size) ? digits[0] : 0;
            if (size == -1) a = -a;
        } else {
            switch (size) {
                case -2:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        a = -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case 2:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        a = (long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case -3:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        a = -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case 3:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        a = (long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case -4:
                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                        a = -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case 4:
                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                        a = (long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                default: return PyLong_Type.tp_as_number->nb_subtract(op1, op2);
            }
        }
                x = a - b;
            return PyLong_FromLong(x);
        long_long:
                llx = lla - llb;
            return PyLong_FromLongLong(llx);
    }
    #endif
    if (PyFloat_CheckExact(op1)) {
        const long b = intval;
        double a = PyFloat_AS_DOUBLE(op1);
            double result;
            PyFPE_START_PROTECT("subtract", return NULL)
            result = ((double)a) - (double)b;
            PyFPE_END_PROTECT(result)
            return PyFloat_FromDouble(result);
    }
    return (inplace ? PyNumber_InPlaceSubtract : PyNumber_Subtract)(op1, op2);
}
#endif

/* PyObjectCallMethod0 */
          static PyObject* __Pyx_PyObject_CallMethod0(PyObject* obj, PyObject* method_name) {
    PyObject *method, *result = NULL;
    method = __Pyx_PyObject_GetAttrStr(obj, method_name);
    if (unlikely(!method)) goto bad;
#if CYTHON_COMPILING_IN_CPYTHON
    if (likely(PyMethod_Check(method))) {
        PyObject *self = PyMethod_GET_SELF(method);
        if (likely(self)) {
            PyObject *function = PyMethod_GET_FUNCTION(method);
            result = __Pyx_PyObject_CallOneArg(function, self);
            Py_DECREF(method);
            return result;
        }
    }
#endif
    result = __Pyx_PyObject_CallNoArg(method);
    Py_DECREF(method);
bad:
    return result;
}

/* RaiseNoneIterError */
          static CYTHON_INLINE void __Pyx_RaiseNoneNotIterableError(void) {
    PyErr_SetString(PyExc_TypeError, "'NoneType' object is not iterable");
}

/* UnpackTupleError */
          static void __Pyx_UnpackTupleError(PyObject *t, Py_ssize_t index) {
    if (t == Py_None) {
      __Pyx_RaiseNoneNotIterableError();
    } else if (PyTuple_GET_SIZE(t) < index) {
      __Pyx_RaiseNeedMoreValuesError(PyTuple_GET_SIZE(t));
    } else {
      __Pyx_RaiseTooManyValuesError(index);
    }
}

/* UnpackTuple2 */
          static CYTHON_INLINE int __Pyx_unpack_tuple2(PyObject* tuple, PyObject** pvalue1, PyObject** pvalue2,
                                             int is_tuple, int has_known_size, int decref_tuple) {
    Py_ssize_t index;
    PyObject *value1 = NULL, *value2 = NULL, *iter = NULL;
    if (!is_tuple && unlikely(!PyTuple_Check(tuple))) {
        iternextfunc iternext;
        iter = PyObject_GetIter(tuple);
        if (unlikely(!iter)) goto bad;
        if (decref_tuple) { Py_DECREF(tuple); tuple = NULL; }
        iternext = Py_TYPE(iter)->tp_iternext;
        value1 = iternext(iter); if (unlikely(!value1)) { index = 0; goto unpacking_failed; }
        value2 = iternext(iter); if (unlikely(!value2)) { index = 1; goto unpacking_failed; }
        if (!has_known_size && unlikely(__Pyx_IternextUnpackEndCheck(iternext(iter), 2))) goto bad;
        Py_DECREF(iter);
    } else {
        if (!has_known_size && unlikely(PyTuple_GET_SIZE(tuple) != 2)) {
            __Pyx_UnpackTupleError(tuple, 2);
            goto bad;
        }
#if CYTHON_COMPILING_IN_PYPY
        value1 = PySequence_ITEM(tuple, 0);
        if (unlikely(!value1)) goto bad;
        value2 = PySequence_ITEM(tuple, 1);
        if (unlikely(!value2)) goto bad;
#else
        value1 = PyTuple_GET_ITEM(tuple, 0);
        value2 = PyTuple_GET_ITEM(tuple, 1);
        Py_INCREF(value1);
        Py_INCREF(value2);
#endif
        if (decref_tuple) { Py_DECREF(tuple); }
    }
    *pvalue1 = value1;
    *pvalue2 = value2;
    return 0;
unpacking_failed:
    if (!has_known_size && __Pyx_IterFinish() == 0)
        __Pyx_RaiseNeedMoreValuesError(index);
bad:
    Py_XDECREF(iter);
    Py_XDECREF(value1);
    Py_XDECREF(value2);
    if (decref_tuple) { Py_XDECREF(tuple); }
    return -1;
}

/* dict_iter */
          static CYTHON_INLINE PyObject* __Pyx_dict_iterator(PyObject* iterable, int is_dict, PyObject* method_name,
                                                   Py_ssize_t* p_orig_length, int* p_source_is_dict) {
    is_dict = is_dict || likely(PyDict_CheckExact(iterable));
    *p_source_is_dict = is_dict;
#if !CYTHON_COMPILING_IN_PYPY
    if (is_dict) {
        *p_orig_length = PyDict_Size(iterable);
        Py_INCREF(iterable);
        return iterable;
    }
#endif
    *p_orig_length = 0;
    if (method_name) {
        PyObject* iter;
        iterable = __Pyx_PyObject_CallMethod0(iterable, method_name);
        if (!iterable)
            return NULL;
#if !CYTHON_COMPILING_IN_PYPY
        if (PyTuple_CheckExact(iterable) || PyList_CheckExact(iterable))
            return iterable;
#endif
        iter = PyObject_GetIter(iterable);
        Py_DECREF(iterable);
        return iter;
    }
    return PyObject_GetIter(iterable);
}
static CYTHON_INLINE int __Pyx_dict_iter_next(
        PyObject* iter_obj, CYTHON_NCP_UNUSED Py_ssize_t orig_length, CYTHON_NCP_UNUSED Py_ssize_t* ppos,
        PyObject** pkey, PyObject** pvalue, PyObject** pitem, int source_is_dict) {
    PyObject* next_item;
#if !CYTHON_COMPILING_IN_PYPY
    if (source_is_dict) {
        PyObject *key, *value;
        if (unlikely(orig_length != PyDict_Size(iter_obj))) {
            PyErr_SetString(PyExc_RuntimeError, "dictionary changed size during iteration");
            return -1;
        }
        if (unlikely(!PyDict_Next(iter_obj, ppos, &key, &value))) {
            return 0;
        }
        if (pitem) {
            PyObject* tuple = PyTuple_New(2);
            if (unlikely(!tuple)) {
                return -1;
            }
            Py_INCREF(key);
            Py_INCREF(value);
            PyTuple_SET_ITEM(tuple, 0, key);
            PyTuple_SET_ITEM(tuple, 1, value);
            *pitem = tuple;
        } else {
            if (pkey) {
                Py_INCREF(key);
                *pkey = key;
            }
            if (pvalue) {
                Py_INCREF(value);
                *pvalue = value;
            }
        }
        return 1;
    } else if (PyTuple_CheckExact(iter_obj)) {
        Py_ssize_t pos = *ppos;
        if (unlikely(pos >= PyTuple_GET_SIZE(iter_obj))) return 0;
        *ppos = pos + 1;
        next_item = PyTuple_GET_ITEM(iter_obj, pos);
        Py_INCREF(next_item);
    } else if (PyList_CheckExact(iter_obj)) {
        Py_ssize_t pos = *ppos;
        if (unlikely(pos >= PyList_GET_SIZE(iter_obj))) return 0;
        *ppos = pos + 1;
        next_item = PyList_GET_ITEM(iter_obj, pos);
        Py_INCREF(next_item);
    } else
#endif
    {
        next_item = PyIter_Next(iter_obj);
        if (unlikely(!next_item)) {
            return __Pyx_IterFinish();
        }
    }
    if (pitem) {
        *pitem = next_item;
    } else if (pkey && pvalue) {
        if (__Pyx_unpack_tuple2(next_item, pkey, pvalue, source_is_dict, source_is_dict, 1))
            return -1;
    } else if (pkey) {
        *pkey = next_item;
    } else {
        *pvalue = next_item;
    }
    return 1;
}

/* MergeKeywords */
          static int __Pyx_MergeKeywords(PyObject *kwdict, PyObject *source_mapping) {
    PyObject *iter, *key = NULL, *value = NULL;
    int source_is_dict, result;
    Py_ssize_t orig_length, ppos = 0;
    iter = __Pyx_dict_iterator(source_mapping, 0, __pyx_n_s_items, &orig_length, &source_is_dict);
    if (unlikely(!iter)) {
        PyObject *args;
        if (!PyErr_ExceptionMatches(PyExc_AttributeError)) goto bad;
        PyErr_Clear();
        args = PyTuple_Pack(1, source_mapping);
        if (likely(args)) {
            PyObject *fallback = PyObject_Call((PyObject*)&PyDict_Type, args, NULL);
            Py_DECREF(args);
            if (likely(fallback)) {
                iter = __Pyx_dict_iterator(fallback, 1, __pyx_n_s_items, &orig_length, &source_is_dict);
                Py_DECREF(fallback);
            }
        }
        if (unlikely(!iter)) goto bad;
    }
    while (1) {
        result = __Pyx_dict_iter_next(iter, orig_length, &ppos, &key, &value, NULL, source_is_dict);
        if (unlikely(result < 0)) goto bad;
        if (!result) break;
        if (unlikely(PyDict_Contains(kwdict, key))) {
            __Pyx_RaiseDoubleKeywordsError("function", key);
            result = -1;
        } else {
            result = PyDict_SetItem(kwdict, key, value);
        }
        Py_DECREF(key);
        Py_DECREF(value);
        if (unlikely(result < 0)) goto bad;
    }
    Py_XDECREF(iter);
    return 0;
bad:
    Py_XDECREF(iter);
    return -1;
}

/* ExtTypeTest */
          static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
    if (unlikely(!type)) {
        PyErr_SetString(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (likely(PyObject_TypeCheck(obj, type)))
        return 1;
    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
                 Py_TYPE(obj)->tp_name, type->tp_name);
    return 0;
}

/* PyIntBinop */
          #if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx_PyInt_AndObjC(PyObject *op1, PyObject *op2, CYTHON_UNUSED long intval, CYTHON_UNUSED int inplace) {
    #if PY_MAJOR_VERSION < 3
    if (likely(PyInt_CheckExact(op1))) {
        const long b = intval;
        long a = PyInt_AS_LONG(op1);
            return PyInt_FromLong(a & b);
    }
    #endif
    #if CYTHON_USE_PYLONG_INTERNALS && PY_MAJOR_VERSION >= 3
    if (likely(PyLong_CheckExact(op1))) {
        const long b = intval;
        long a, x;
        const PY_LONG_LONG llb = intval;
        PY_LONG_LONG lla, llx;
        const digit* digits = ((PyLongObject*)op1)->ob_digit;
        const Py_ssize_t size = Py_SIZE(op1);
        if (likely(__Pyx_sst_abs(size) <= 1)) {
            a = likely(size) ? digits[0] : 0;
            if (size == -1) a = -a;
        } else {
            switch (size) {
                case -2:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        a = -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case 2:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        a = (long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case -3:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        a = -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case 3:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        a = (long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case -4:
                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                        a = -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case 4:
                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                        a = (long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                default: return PyLong_Type.tp_as_number->nb_and(op1, op2);
            }
        }
                x = a & b;
            return PyLong_FromLong(x);
        long_long:
                llx = lla & llb;
            return PyLong_FromLongLong(llx);
    }
    #endif
    return (inplace ? PyNumber_InPlaceAnd : PyNumber_And)(op1, op2);
}
#endif

/* PyIntBinop */
          #if CYTHON_COMPILING_IN_CPYTHON
static PyObject* __Pyx_PyInt_AddObjC(PyObject *op1, PyObject *op2, CYTHON_UNUSED long intval, CYTHON_UNUSED int inplace) {
    #if PY_MAJOR_VERSION < 3
    if (likely(PyInt_CheckExact(op1))) {
        const long b = intval;
        long x;
        long a = PyInt_AS_LONG(op1);
            x = (long)((unsigned long)a + b);
            if (likely((x^a) >= 0 || (x^b) >= 0))
                return PyInt_FromLong(x);
            return PyLong_Type.tp_as_number->nb_add(op1, op2);
    }
    #endif
    #if CYTHON_USE_PYLONG_INTERNALS && PY_MAJOR_VERSION >= 3
    if (likely(PyLong_CheckExact(op1))) {
        const long b = intval;
        long a, x;
        const PY_LONG_LONG llb = intval;
        PY_LONG_LONG lla, llx;
        const digit* digits = ((PyLongObject*)op1)->ob_digit;
        const Py_ssize_t size = Py_SIZE(op1);
        if (likely(__Pyx_sst_abs(size) <= 1)) {
            a = likely(size) ? digits[0] : 0;
            if (size == -1) a = -a;
        } else {
            switch (size) {
                case -2:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        a = -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case 2:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        a = (long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case -3:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        a = -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case 3:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        a = (long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((((unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case -4:
                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                        a = -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                        lla = -(PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                case 4:
                    if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                        a = (long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0]));
                        break;
                    } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                        lla = (PY_LONG_LONG) (((((((((unsigned PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (unsigned PY_LONG_LONG)digits[0]));
                        goto long_long;
                    }
                default: return PyLong_Type.tp_as_number->nb_add(op1, op2);
            }
        }
                x = a + b;
            return PyLong_FromLong(x);
        long_long:
                llx = lla + llb;
            return PyLong_FromLongLong(llx);
    }
    #endif
    if (PyFloat_CheckExact(op1)) {
        const long b = intval;
        double a = PyFloat_AS_DOUBLE(op1);
            double result;
            PyFPE_START_PROTECT("add", return NULL)
            result = ((double)a) + (double)b;
            PyFPE_END_PROTECT(result)
            return PyFloat_FromDouble(result);
    }
    return (inplace ? PyNumber_InPlaceAdd : PyNumber_Add)(op1, op2);
}
#endif

/* dict_getitem_default */
          static PyObject* __Pyx_PyDict_GetItemDefault(PyObject* d, PyObject* key, PyObject* default_value) {
    PyObject* value;
#if PY_MAJOR_VERSION >= 3 && !CYTHON_COMPILING_IN_PYPY
    value = PyDict_GetItemWithError(d, key);
    if (unlikely(!value)) {
        if (unlikely(PyErr_Occurred()))
            return NULL;
        value = default_value;
    }
    Py_INCREF(value);
#else
    if (PyString_CheckExact(key) || PyUnicode_CheckExact(key) || PyInt_CheckExact(key)) {
        value = PyDict_GetItem(d, key);
        if (unlikely(!value)) {
            value = default_value;
        }
        Py_INCREF(value);
    } else {
        if (default_value == Py_None)
            default_value = NULL;
        value = PyObject_CallMethodObjArgs(
            d, __pyx_n_s_get, key, default_value, NULL);
    }
#endif
    return value;
}

/* SetVTable */
          static int __Pyx_SetVtable(PyObject *dict, void *vtable) {
#if PY_VERSION_HEX >= 0x02070000
    PyObject *ob = PyCapsule_New(vtable, 0, 0);
#else
    PyObject *ob = PyCObject_FromVoidPtr(vtable, 0);
#endif
    if (!ob)
        goto bad;
    if (PyDict_SetItem(dict, __pyx_n_s_pyx_vtable, ob) < 0)
        goto bad;
    Py_DECREF(ob);
    return 0;
bad:
    Py_XDECREF(ob);
    return -1;
}

/* GetVTable */
          static void* __Pyx_GetVtable(PyObject *dict) {
    void* ptr;
    PyObject *ob = PyObject_GetItem(dict, __pyx_n_s_pyx_vtable);
    if (!ob)
        goto bad;
#if PY_VERSION_HEX >= 0x02070000
    ptr = PyCapsule_GetPointer(ob, 0);
#else
    ptr = PyCObject_AsVoidPtr(ob);
#endif
    if (!ptr && !PyErr_Occurred())
        PyErr_SetString(PyExc_RuntimeError, "invalid vtable found for imported type");
    Py_DECREF(ob);
    return ptr;
bad:
    Py_XDECREF(ob);
    return NULL;
}

/* Import */
          static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list, int level) {
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    #if PY_VERSION_HEX < 0x03030000
    PyObject *py_import;
    py_import = __Pyx_PyObject_GetAttrStr(__pyx_b, __pyx_n_s_import);
    if (!py_import)
        goto bad;
    #endif
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    {
        #if PY_MAJOR_VERSION >= 3
        if (level == -1) {
            if (strchr(__Pyx_MODULE_NAME, '.')) {
                #if PY_VERSION_HEX < 0x03030000
                PyObject *py_level = PyInt_FromLong(1);
                if (!py_level)
                    goto bad;
                module = PyObject_CallFunctionObjArgs(py_import,
                    name, global_dict, empty_dict, list, py_level, NULL);
                Py_DECREF(py_level);
                #else
                module = PyImport_ImportModuleLevelObject(
                    name, global_dict, empty_dict, list, 1);
                #endif
                if (!module) {
                    if (!PyErr_ExceptionMatches(PyExc_ImportError))
                        goto bad;
                    PyErr_Clear();
                }
            }
            level = 0;
        }
        #endif
        if (!module) {
            #if PY_VERSION_HEX < 0x03030000
            PyObject *py_level = PyInt_FromLong(level);
            if (!py_level)
                goto bad;
            module = PyObject_CallFunctionObjArgs(py_import,
                name, global_dict, empty_dict, list, py_level, NULL);
            Py_DECREF(py_level);
            #else
            module = PyImport_ImportModuleLevelObject(
                name, global_dict, empty_dict, list, level);
            #endif
        }
    }
bad:
    #if PY_VERSION_HEX < 0x03030000
    Py_XDECREF(py_import);
    #endif
    Py_XDECREF(empty_list);
    Py_XDECREF(empty_dict);
    return module;
}

/* ImportFrom */
          static PyObject* __Pyx_ImportFrom(PyObject* module, PyObject* name) {
    PyObject* value = __Pyx_PyObject_GetAttrStr(module, name);
    if (unlikely(!value) && PyErr_ExceptionMatches(PyExc_AttributeError)) {
        PyErr_Format(PyExc_ImportError,
        #if PY_MAJOR_VERSION < 3
            "cannot import name %.230s", PyString_AS_STRING(name));
        #else
            "cannot import name %S", name);
        #endif
    }
    return value;
}

/* CodeObjectCache */
          static int __pyx_bisect_code_objects(__Pyx_CodeObjectCacheEntry* entries, int count, int code_line) {
    int start = 0, mid = 0, end = count - 1;
    if (end >= 0 && code_line > entries[end].code_line) {
        return count;
    }
    while (start < end) {
        mid = start + (end - start) / 2;
        if (code_line < entries[mid].code_line) {
            end = mid;
        } else if (code_line > entries[mid].code_line) {
             start = mid + 1;
        } else {
            return mid;
        }
    }
    if (code_line <= entries[mid].code_line) {
        return mid;
    } else {
        return mid + 1;
    }
}
static PyCodeObject *__pyx_find_code_object(int code_line) {
    PyCodeObject* code_object;
    int pos;
    if (unlikely(!code_line) || unlikely(!__pyx_code_cache.entries)) {
        return NULL;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if (unlikely(pos >= __pyx_code_cache.count) || unlikely(__pyx_code_cache.entries[pos].code_line != code_line)) {
        return NULL;
    }
    code_object = __pyx_code_cache.entries[pos].code_object;
    Py_INCREF(code_object);
    return code_object;
}
static void __pyx_insert_code_object(int code_line, PyCodeObject* code_object) {
    int pos, i;
    __Pyx_CodeObjectCacheEntry* entries = __pyx_code_cache.entries;
    if (unlikely(!code_line)) {
        return;
    }
    if (unlikely(!entries)) {
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Malloc(64*sizeof(__Pyx_CodeObjectCacheEntry));
        if (likely(entries)) {
            __pyx_code_cache.entries = entries;
            __pyx_code_cache.max_count = 64;
            __pyx_code_cache.count = 1;
            entries[0].code_line = code_line;
            entries[0].code_object = code_object;
            Py_INCREF(code_object);
        }
        return;
    }
    pos = __pyx_bisect_code_objects(__pyx_code_cache.entries, __pyx_code_cache.count, code_line);
    if ((pos < __pyx_code_cache.count) && unlikely(__pyx_code_cache.entries[pos].code_line == code_line)) {
        PyCodeObject* tmp = entries[pos].code_object;
        entries[pos].code_object = code_object;
        Py_DECREF(tmp);
        return;
    }
    if (__pyx_code_cache.count == __pyx_code_cache.max_count) {
        int new_max = __pyx_code_cache.max_count + 64;
        entries = (__Pyx_CodeObjectCacheEntry*)PyMem_Realloc(
            __pyx_code_cache.entries, (size_t)new_max*sizeof(__Pyx_CodeObjectCacheEntry));
        if (unlikely(!entries)) {
            return;
        }
        __pyx_code_cache.entries = entries;
        __pyx_code_cache.max_count = new_max;
    }
    for (i=__pyx_code_cache.count; i>pos; i--) {
        entries[i] = entries[i-1];
    }
    entries[pos].code_line = code_line;
    entries[pos].code_object = code_object;
    __pyx_code_cache.count++;
    Py_INCREF(code_object);
}

/* AddTraceback */
          #include "compile.h"
#include "frameobject.h"
#include "traceback.h"
static PyCodeObject* __Pyx_CreateCodeObjectForTraceback(
            const char *funcname, int c_line,
            int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    #if PY_MAJOR_VERSION < 3
    py_srcfile = PyString_FromString(filename);
    #else
    py_srcfile = PyUnicode_FromString(filename);
    #endif
    if (!py_srcfile) goto bad;
    if (c_line) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, c_line);
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        #else
        py_funcname = PyUnicode_FromString(funcname);
        #endif
    }
    if (!py_funcname) goto bad;
    py_code = __Pyx_PyCode_New(
        0,
        0,
        0,
        0,
        0,
        __pyx_empty_bytes, /*PyObject *code,*/
        __pyx_empty_tuple, /*PyObject *consts,*/
        __pyx_empty_tuple, /*PyObject *names,*/
        __pyx_empty_tuple, /*PyObject *varnames,*/
        __pyx_empty_tuple, /*PyObject *freevars,*/
        __pyx_empty_tuple, /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        py_line,
        __pyx_empty_bytes  /*PyObject *lnotab*/
    );
    Py_DECREF(py_srcfile);
    Py_DECREF(py_funcname);
    return py_code;
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    return NULL;
}
static void __Pyx_AddTraceback(const char *funcname, int c_line,
                               int py_line, const char *filename) {
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;
    py_code = __pyx_find_code_object(c_line ? c_line : py_line);
    if (!py_code) {
        py_code = __Pyx_CreateCodeObjectForTraceback(
            funcname, c_line, py_line, filename);
        if (!py_code) goto bad;
        __pyx_insert_code_object(c_line ? c_line : py_line, py_code);
    }
    py_frame = PyFrame_New(
        PyThreadState_GET(), /*PyThreadState *tstate,*/
        py_code,             /*PyCodeObject *code,*/
        __pyx_d,      /*PyObject *globals,*/
        0                    /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    py_frame->f_lineno = py_line;
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

/* CIntFromPyVerify */
          #define __PYX_VERIFY_RETURN_INT(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 0)
#define __PYX_VERIFY_RETURN_INT_EXC(target_type, func_type, func_value)\
    __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, 1)
#define __PYX__VERIFY_RETURN_INT(target_type, func_type, func_value, exc)\
    {\
        func_type value = func_value;\
        if (sizeof(target_type) < sizeof(func_type)) {\
            if (unlikely(value != (func_type) (target_type) value)) {\
                func_type zero = 0;\
                if (exc && unlikely(value == (func_type)-1 && PyErr_Occurred()))\
                    return (target_type) -1;\
                if (is_unsigned && unlikely(value < zero))\
                    goto raise_neg_overflow;\
                else\
                    goto raise_overflow;\
            }\
        }\
        return (target_type) value;\
    }

/* CIntToPy */
          static CYTHON_INLINE PyObject* __Pyx_PyInt_From_long(long value) {
    const long neg_one = (long) -1, const_zero = (long) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(long) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(long) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(long),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
          static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int(int value) {
    const int neg_one = (int) -1, const_zero = (int) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(int) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(int) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(int),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
          static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int32_t(int32_t value) {
    const int32_t neg_one = (int32_t) -1, const_zero = (int32_t) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(int32_t) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int32_t) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(int32_t) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(int32_t) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int32_t) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(int32_t),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
          static CYTHON_INLINE PyObject* __Pyx_PyInt_From_int64_t(int64_t value) {
    const int64_t neg_one = (int64_t) -1, const_zero = (int64_t) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(int64_t) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int64_t) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(int64_t) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(int64_t) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(int64_t) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(int64_t),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
          static CYTHON_INLINE PyObject* __Pyx_PyInt_From_uint64_t(uint64_t value) {
    const uint64_t neg_one = (uint64_t) -1, const_zero = (uint64_t) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(uint64_t) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(uint64_t) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(uint64_t) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(uint64_t) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(uint64_t) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(uint64_t),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
          static CYTHON_INLINE PyObject* __Pyx_PyInt_From_PY_LONG_LONG(PY_LONG_LONG value) {
    const PY_LONG_LONG neg_one = (PY_LONG_LONG) -1, const_zero = (PY_LONG_LONG) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(PY_LONG_LONG) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(PY_LONG_LONG) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(PY_LONG_LONG) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(PY_LONG_LONG) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(PY_LONG_LONG) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(PY_LONG_LONG),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
          static CYTHON_INLINE PyObject* __Pyx_PyInt_From_uint32_t(uint32_t value) {
    const uint32_t neg_one = (uint32_t) -1, const_zero = (uint32_t) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(uint32_t) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(uint32_t) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(uint32_t) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(uint32_t) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(uint32_t) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(uint32_t),
                                     little, !is_unsigned);
    }
}

/* CIntToPy */
          static CYTHON_INLINE PyObject* __Pyx_PyInt_From_uint16_t(uint16_t value) {
    const uint16_t neg_one = (uint16_t) -1, const_zero = (uint16_t) 0;
    const int is_unsigned = neg_one > const_zero;
    if (is_unsigned) {
        if (sizeof(uint16_t) < sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(uint16_t) <= sizeof(unsigned long)) {
            return PyLong_FromUnsignedLong((unsigned long) value);
        } else if (sizeof(uint16_t) <= sizeof(unsigned PY_LONG_LONG)) {
            return PyLong_FromUnsignedLongLong((unsigned PY_LONG_LONG) value);
        }
    } else {
        if (sizeof(uint16_t) <= sizeof(long)) {
            return PyInt_FromLong((long) value);
        } else if (sizeof(uint16_t) <= sizeof(PY_LONG_LONG)) {
            return PyLong_FromLongLong((PY_LONG_LONG) value);
        }
    }
    {
        int one = 1; int little = (int)*(unsigned char *)&one;
        unsigned char *bytes = (unsigned char *)&value;
        return _PyLong_FromByteArray(bytes, sizeof(uint16_t),
                                     little, !is_unsigned);
    }
}

/* CIntFromPy */
          static CYTHON_INLINE uint64_t __Pyx_PyInt_As_uint64_t(PyObject *x) {
    const uint64_t neg_one = (uint64_t) -1, const_zero = (uint64_t) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(uint64_t) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(uint64_t, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (uint64_t) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (uint64_t) 0;
                case  1: __PYX_VERIFY_RETURN_INT(uint64_t, digit, digits[0])
                case 2:
                    if (8 * sizeof(uint64_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) >= 2 * PyLong_SHIFT) {
                            return (uint64_t) (((((uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(uint64_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) >= 3 * PyLong_SHIFT) {
                            return (uint64_t) (((((((uint64_t)digits[2]) << PyLong_SHIFT) | (uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(uint64_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) >= 4 * PyLong_SHIFT) {
                            return (uint64_t) (((((((((uint64_t)digits[3]) << PyLong_SHIFT) | (uint64_t)digits[2]) << PyLong_SHIFT) | (uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (uint64_t) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(uint64_t) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint64_t, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(uint64_t) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint64_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (uint64_t) 0;
                case -1: __PYX_VERIFY_RETURN_INT(uint64_t, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(uint64_t,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(uint64_t) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) - 1 > 2 * PyLong_SHIFT) {
                            return (uint64_t) (((uint64_t)-1)*(((((uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(uint64_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) - 1 > 2 * PyLong_SHIFT) {
                            return (uint64_t) ((((((uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(uint64_t) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) - 1 > 3 * PyLong_SHIFT) {
                            return (uint64_t) (((uint64_t)-1)*(((((((uint64_t)digits[2]) << PyLong_SHIFT) | (uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(uint64_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) - 1 > 3 * PyLong_SHIFT) {
                            return (uint64_t) ((((((((uint64_t)digits[2]) << PyLong_SHIFT) | (uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(uint64_t) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) - 1 > 4 * PyLong_SHIFT) {
                            return (uint64_t) (((uint64_t)-1)*(((((((((uint64_t)digits[3]) << PyLong_SHIFT) | (uint64_t)digits[2]) << PyLong_SHIFT) | (uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(uint64_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint64_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint64_t) - 1 > 4 * PyLong_SHIFT) {
                            return (uint64_t) ((((((((((uint64_t)digits[3]) << PyLong_SHIFT) | (uint64_t)digits[2]) << PyLong_SHIFT) | (uint64_t)digits[1]) << PyLong_SHIFT) | (uint64_t)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(uint64_t) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint64_t, long, PyLong_AsLong(x))
            } else if (sizeof(uint64_t) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint64_t, PY_LONG_LONG, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            uint64_t val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (uint64_t) -1;
        }
    } else {
        uint64_t val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (uint64_t) -1;
        val = __Pyx_PyInt_As_uint64_t(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to uint64_t");
    return (uint64_t) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to uint64_t");
    return (uint64_t) -1;
}

/* CIntFromPy */
          static CYTHON_INLINE int __Pyx_PyInt_As_int(PyObject *x) {
    const int neg_one = (int) -1, const_zero = (int) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case  1: __PYX_VERIFY_RETURN_INT(int, digit, digits[0])
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 2 * PyLong_SHIFT) {
                            return (int) (((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 3 * PyLong_SHIFT) {
                            return (int) (((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) >= 4 * PyLong_SHIFT) {
                            return (int) (((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (int) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(int) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(int) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int) 0;
                case -1: __PYX_VERIFY_RETURN_INT(int, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(int,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(int) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(int) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                            return (int) ((((((int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(int) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                            return (int) ((((((((int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(int) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) (((int)-1)*(((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int) - 1 > 4 * PyLong_SHIFT) {
                            return (int) ((((((((((int)digits[3]) << PyLong_SHIFT) | (int)digits[2]) << PyLong_SHIFT) | (int)digits[1]) << PyLong_SHIFT) | (int)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(int) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, long, PyLong_AsLong(x))
            } else if (sizeof(int) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int, PY_LONG_LONG, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int) -1;
        }
    } else {
        int val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (int) -1;
        val = __Pyx_PyInt_As_int(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int");
    return (int) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int");
    return (int) -1;
}

/* CIntFromPy */
          static CYTHON_INLINE uint32_t __Pyx_PyInt_As_uint32_t(PyObject *x) {
    const uint32_t neg_one = (uint32_t) -1, const_zero = (uint32_t) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(uint32_t) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(uint32_t, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (uint32_t) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (uint32_t) 0;
                case  1: __PYX_VERIFY_RETURN_INT(uint32_t, digit, digits[0])
                case 2:
                    if (8 * sizeof(uint32_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) >= 2 * PyLong_SHIFT) {
                            return (uint32_t) (((((uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(uint32_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) >= 3 * PyLong_SHIFT) {
                            return (uint32_t) (((((((uint32_t)digits[2]) << PyLong_SHIFT) | (uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(uint32_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) >= 4 * PyLong_SHIFT) {
                            return (uint32_t) (((((((((uint32_t)digits[3]) << PyLong_SHIFT) | (uint32_t)digits[2]) << PyLong_SHIFT) | (uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (uint32_t) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(uint32_t) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint32_t, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(uint32_t) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint32_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (uint32_t) 0;
                case -1: __PYX_VERIFY_RETURN_INT(uint32_t, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(uint32_t,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(uint32_t) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) - 1 > 2 * PyLong_SHIFT) {
                            return (uint32_t) (((uint32_t)-1)*(((((uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(uint32_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) - 1 > 2 * PyLong_SHIFT) {
                            return (uint32_t) ((((((uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(uint32_t) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) - 1 > 3 * PyLong_SHIFT) {
                            return (uint32_t) (((uint32_t)-1)*(((((((uint32_t)digits[2]) << PyLong_SHIFT) | (uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(uint32_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) - 1 > 3 * PyLong_SHIFT) {
                            return (uint32_t) ((((((((uint32_t)digits[2]) << PyLong_SHIFT) | (uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(uint32_t) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) - 1 > 4 * PyLong_SHIFT) {
                            return (uint32_t) (((uint32_t)-1)*(((((((((uint32_t)digits[3]) << PyLong_SHIFT) | (uint32_t)digits[2]) << PyLong_SHIFT) | (uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(uint32_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(uint32_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(uint32_t) - 1 > 4 * PyLong_SHIFT) {
                            return (uint32_t) ((((((((((uint32_t)digits[3]) << PyLong_SHIFT) | (uint32_t)digits[2]) << PyLong_SHIFT) | (uint32_t)digits[1]) << PyLong_SHIFT) | (uint32_t)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(uint32_t) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint32_t, long, PyLong_AsLong(x))
            } else if (sizeof(uint32_t) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(uint32_t, PY_LONG_LONG, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            uint32_t val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (uint32_t) -1;
        }
    } else {
        uint32_t val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (uint32_t) -1;
        val = __Pyx_PyInt_As_uint32_t(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to uint32_t");
    return (uint32_t) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to uint32_t");
    return (uint32_t) -1;
}

/* CIntFromPy */
          static CYTHON_INLINE size_t __Pyx_PyInt_As_size_t(PyObject *x) {
    const size_t neg_one = (size_t) -1, const_zero = (size_t) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(size_t) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(size_t, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (size_t) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (size_t) 0;
                case  1: __PYX_VERIFY_RETURN_INT(size_t, digit, digits[0])
                case 2:
                    if (8 * sizeof(size_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) >= 2 * PyLong_SHIFT) {
                            return (size_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(size_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) >= 3 * PyLong_SHIFT) {
                            return (size_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(size_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) >= 4 * PyLong_SHIFT) {
                            return (size_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (size_t) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(size_t) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(size_t, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(size_t) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(size_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (size_t) 0;
                case -1: __PYX_VERIFY_RETURN_INT(size_t, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(size_t,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(size_t) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) - 1 > 2 * PyLong_SHIFT) {
                            return (size_t) (((size_t)-1)*(((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(size_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) - 1 > 2 * PyLong_SHIFT) {
                            return (size_t) ((((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(size_t) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) - 1 > 3 * PyLong_SHIFT) {
                            return (size_t) (((size_t)-1)*(((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(size_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) - 1 > 3 * PyLong_SHIFT) {
                            return (size_t) ((((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(size_t) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) - 1 > 4 * PyLong_SHIFT) {
                            return (size_t) (((size_t)-1)*(((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(size_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(size_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(size_t) - 1 > 4 * PyLong_SHIFT) {
                            return (size_t) ((((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(size_t) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(size_t, long, PyLong_AsLong(x))
            } else if (sizeof(size_t) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(size_t, PY_LONG_LONG, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            size_t val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (size_t) -1;
        }
    } else {
        size_t val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (size_t) -1;
        val = __Pyx_PyInt_As_size_t(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to size_t");
    return (size_t) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to size_t");
    return (size_t) -1;
}

/* CIntFromPy */
          static CYTHON_INLINE int64_t __Pyx_PyInt_As_int64_t(PyObject *x) {
    const int64_t neg_one = (int64_t) -1, const_zero = (int64_t) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(int64_t) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(int64_t, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (int64_t) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int64_t) 0;
                case  1: __PYX_VERIFY_RETURN_INT(int64_t, digit, digits[0])
                case 2:
                    if (8 * sizeof(int64_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int64_t) >= 2 * PyLong_SHIFT) {
                            return (int64_t) (((((int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int64_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int64_t) >= 3 * PyLong_SHIFT) {
                            return (int64_t) (((((((int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int64_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int64_t) >= 4 * PyLong_SHIFT) {
                            return (int64_t) (((((((((int64_t)digits[3]) << PyLong_SHIFT) | (int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (int64_t) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(int64_t) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int64_t, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(int64_t) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int64_t, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (int64_t) 0;
                case -1: __PYX_VERIFY_RETURN_INT(int64_t, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(int64_t,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(int64_t) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int64_t, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int64_t) - 1 > 2 * PyLong_SHIFT) {
                            return (int64_t) (((int64_t)-1)*(((((int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(int64_t) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int64_t) - 1 > 2 * PyLong_SHIFT) {
                            return (int64_t) ((((((int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(int64_t) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int64_t, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int64_t) - 1 > 3 * PyLong_SHIFT) {
                            return (int64_t) (((int64_t)-1)*(((((((int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(int64_t) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int64_t) - 1 > 3 * PyLong_SHIFT) {
                            return (int64_t) ((((((((int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(int64_t) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int64_t, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int64_t) - 1 > 4 * PyLong_SHIFT) {
                            return (int64_t) (((int64_t)-1)*(((((((((int64_t)digits[3]) << PyLong_SHIFT) | (int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(int64_t) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(int64_t, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(int64_t) - 1 > 4 * PyLong_SHIFT) {
                            return (int64_t) ((((((((((int64_t)digits[3]) << PyLong_SHIFT) | (int64_t)digits[2]) << PyLong_SHIFT) | (int64_t)digits[1]) << PyLong_SHIFT) | (int64_t)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(int64_t) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(int64_t, long, PyLong_AsLong(x))
            } else if (sizeof(int64_t) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(int64_t, PY_LONG_LONG, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            int64_t val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (int64_t) -1;
        }
    } else {
        int64_t val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (int64_t) -1;
        val = __Pyx_PyInt_As_int64_t(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to int64_t");
    return (int64_t) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to int64_t");
    return (int64_t) -1;
}

/* CIntFromPy */
          static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_As_PY_LONG_LONG(PyObject *x) {
    const PY_LONG_LONG neg_one = (PY_LONG_LONG) -1, const_zero = (PY_LONG_LONG) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(PY_LONG_LONG) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (PY_LONG_LONG) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (PY_LONG_LONG) 0;
                case  1: __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, digit, digits[0])
                case 2:
                    if (8 * sizeof(PY_LONG_LONG) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(PY_LONG_LONG) >= 2 * PyLong_SHIFT) {
                            return (PY_LONG_LONG) (((((PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(PY_LONG_LONG) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(PY_LONG_LONG) >= 3 * PyLong_SHIFT) {
                            return (PY_LONG_LONG) (((((((PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(PY_LONG_LONG) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(PY_LONG_LONG) >= 4 * PyLong_SHIFT) {
                            return (PY_LONG_LONG) (((((((((PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (PY_LONG_LONG) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(PY_LONG_LONG) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(PY_LONG_LONG, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(PY_LONG_LONG) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(PY_LONG_LONG, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (PY_LONG_LONG) 0;
                case -1: __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(PY_LONG_LONG,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(PY_LONG_LONG) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                            return (PY_LONG_LONG) (((PY_LONG_LONG)-1)*(((((PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(PY_LONG_LONG) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                            return (PY_LONG_LONG) ((((((PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(PY_LONG_LONG) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                            return (PY_LONG_LONG) (((PY_LONG_LONG)-1)*(((((((PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(PY_LONG_LONG) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                            return (PY_LONG_LONG) ((((((((PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(PY_LONG_LONG) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                            return (PY_LONG_LONG) (((PY_LONG_LONG)-1)*(((((((((PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(PY_LONG_LONG) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(PY_LONG_LONG, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(PY_LONG_LONG) - 1 > 4 * PyLong_SHIFT) {
                            return (PY_LONG_LONG) ((((((((((PY_LONG_LONG)digits[3]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[2]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[1]) << PyLong_SHIFT) | (PY_LONG_LONG)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(PY_LONG_LONG) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(PY_LONG_LONG, long, PyLong_AsLong(x))
            } else if (sizeof(PY_LONG_LONG) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(PY_LONG_LONG, PY_LONG_LONG, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            PY_LONG_LONG val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (PY_LONG_LONG) -1;
        }
    } else {
        PY_LONG_LONG val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (PY_LONG_LONG) -1;
        val = __Pyx_PyInt_As_PY_LONG_LONG(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to PY_LONG_LONG");
    return (PY_LONG_LONG) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to PY_LONG_LONG");
    return (PY_LONG_LONG) -1;
}

/* CIntFromPy */
          static CYTHON_INLINE long __Pyx_PyInt_As_long(PyObject *x) {
    const long neg_one = (long) -1, const_zero = (long) 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_MAJOR_VERSION < 3
    if (likely(PyInt_Check(x))) {
        if (sizeof(long) < sizeof(long)) {
            __PYX_VERIFY_RETURN_INT(long, long, PyInt_AS_LONG(x))
        } else {
            long val = PyInt_AS_LONG(x);
            if (is_unsigned && unlikely(val < 0)) {
                goto raise_neg_overflow;
            }
            return (long) val;
        }
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case  1: __PYX_VERIFY_RETURN_INT(long, digit, digits[0])
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 2 * PyLong_SHIFT) {
                            return (long) (((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 3 * PyLong_SHIFT) {
                            return (long) (((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) >= 4 * PyLong_SHIFT) {
                            return (long) (((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0]));
                        }
                    }
                    break;
            }
#endif
#if CYTHON_COMPILING_IN_CPYTHON
            if (unlikely(Py_SIZE(x) < 0)) {
                goto raise_neg_overflow;
            }
#else
            {
                int result = PyObject_RichCompareBool(x, Py_False, Py_LT);
                if (unlikely(result < 0))
                    return (long) -1;
                if (unlikely(result == 1))
                    goto raise_neg_overflow;
            }
#endif
            if (sizeof(long) <= sizeof(unsigned long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned long, PyLong_AsUnsignedLong(x))
            } else if (sizeof(long) <= sizeof(unsigned PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, unsigned PY_LONG_LONG, PyLong_AsUnsignedLongLong(x))
            }
        } else {
#if CYTHON_USE_PYLONG_INTERNALS
            const digit* digits = ((PyLongObject*)x)->ob_digit;
            switch (Py_SIZE(x)) {
                case  0: return (long) 0;
                case -1: __PYX_VERIFY_RETURN_INT(long, sdigit, (sdigit) (-(sdigit)digits[0]))
                case  1: __PYX_VERIFY_RETURN_INT(long,  digit, +digits[0])
                case -2:
                    if (8 * sizeof(long) - 1 > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 2:
                    if (8 * sizeof(long) > 1 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 2 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                            return (long) ((((((long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -3:
                    if (8 * sizeof(long) - 1 > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 3:
                    if (8 * sizeof(long) > 2 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 3 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                            return (long) ((((((((long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case -4:
                    if (8 * sizeof(long) - 1 > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, long, -(long) (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) (((long)-1)*(((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
                case 4:
                    if (8 * sizeof(long) > 3 * PyLong_SHIFT) {
                        if (8 * sizeof(unsigned long) > 4 * PyLong_SHIFT) {
                            __PYX_VERIFY_RETURN_INT(long, unsigned long, (((((((((unsigned long)digits[3]) << PyLong_SHIFT) | (unsigned long)digits[2]) << PyLong_SHIFT) | (unsigned long)digits[1]) << PyLong_SHIFT) | (unsigned long)digits[0])))
                        } else if (8 * sizeof(long) - 1 > 4 * PyLong_SHIFT) {
                            return (long) ((((((((((long)digits[3]) << PyLong_SHIFT) | (long)digits[2]) << PyLong_SHIFT) | (long)digits[1]) << PyLong_SHIFT) | (long)digits[0])));
                        }
                    }
                    break;
            }
#endif
            if (sizeof(long) <= sizeof(long)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, long, PyLong_AsLong(x))
            } else if (sizeof(long) <= sizeof(PY_LONG_LONG)) {
                __PYX_VERIFY_RETURN_INT_EXC(long, PY_LONG_LONG, PyLong_AsLongLong(x))
            }
        }
        {
#if CYTHON_COMPILING_IN_PYPY && !defined(_PyLong_AsByteArray)
            PyErr_SetString(PyExc_RuntimeError,
                            "_PyLong_AsByteArray() not available in PyPy, cannot convert large numbers");
#else
            long val;
            PyObject *v = __Pyx_PyNumber_IntOrLong(x);
 #if PY_MAJOR_VERSION < 3
            if (likely(v) && !PyLong_Check(v)) {
                PyObject *tmp = v;
                v = PyNumber_Long(tmp);
                Py_DECREF(tmp);
            }
 #endif
            if (likely(v)) {
                int one = 1; int is_little = (int)*(unsigned char *)&one;
                unsigned char *bytes = (unsigned char *)&val;
                int ret = _PyLong_AsByteArray((PyLongObject *)v,
                                              bytes, sizeof(val),
                                              is_little, !is_unsigned);
                Py_DECREF(v);
                if (likely(!ret))
                    return val;
            }
#endif
            return (long) -1;
        }
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_IntOrLong(x);
        if (!tmp) return (long) -1;
        val = __Pyx_PyInt_As_long(tmp);
        Py_DECREF(tmp);
        return val;
    }
raise_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "value too large to convert to long");
    return (long) -1;
raise_neg_overflow:
    PyErr_SetString(PyExc_OverflowError,
        "can't convert negative value to long");
    return (long) -1;
}

/* CheckBinaryVersion */
          static int __Pyx_check_binary_version(void) {
    char ctversion[4], rtversion[4];
    PyOS_snprintf(ctversion, 4, "%d.%d", PY_MAJOR_VERSION, PY_MINOR_VERSION);
    PyOS_snprintf(rtversion, 4, "%s", Py_GetVersion());
    if (ctversion[0] != rtversion[0] || ctversion[2] != rtversion[2]) {
        char message[200];
        PyOS_snprintf(message, sizeof(message),
                      "compiletime version %s of module '%.100s' "
                      "does not match runtime version %s",
                      ctversion, __Pyx_MODULE_NAME, rtversion);
        return PyErr_WarnEx(NULL, message, 1);
    }
    return 0;
}

/* ModuleImport */
          #ifndef __PYX_HAVE_RT_ImportModule
#define __PYX_HAVE_RT_ImportModule
static PyObject *__Pyx_ImportModule(const char *name) {
    PyObject *py_name = 0;
    PyObject *py_module = 0;
    py_name = __Pyx_PyIdentifier_FromString(name);
    if (!py_name)
        goto bad;
    py_module = PyImport_Import(py_name);
    Py_DECREF(py_name);
    return py_module;
bad:
    Py_XDECREF(py_name);
    return 0;
}
#endif

/* TypeImport */
          #ifndef __PYX_HAVE_RT_ImportType
#define __PYX_HAVE_RT_ImportType
static PyTypeObject *__Pyx_ImportType(const char *module_name, const char *class_name,
    size_t size, int strict)
{
    PyObject *py_module = 0;
    PyObject *result = 0;
    PyObject *py_name = 0;
    char warning[200];
    Py_ssize_t basicsize;
#ifdef Py_LIMITED_API
    PyObject *py_basicsize;
#endif
    py_module = __Pyx_ImportModule(module_name);
    if (!py_module)
        goto bad;
    py_name = __Pyx_PyIdentifier_FromString(class_name);
    if (!py_name)
        goto bad;
    result = PyObject_GetAttr(py_module, py_name);
    Py_DECREF(py_name);
    py_name = 0;
    Py_DECREF(py_module);
    py_module = 0;
    if (!result)
        goto bad;
    if (!PyType_Check(result)) {
        PyErr_Format(PyExc_TypeError,
            "%.200s.%.200s is not a type object",
            module_name, class_name);
        goto bad;
    }
#ifndef Py_LIMITED_API
    basicsize = ((PyTypeObject *)result)->tp_basicsize;
#else
    py_basicsize = PyObject_GetAttrString(result, "__basicsize__");
    if (!py_basicsize)
        goto bad;
    basicsize = PyLong_AsSsize_t(py_basicsize);
    Py_DECREF(py_basicsize);
    py_basicsize = 0;
    if (basicsize == (Py_ssize_t)-1 && PyErr_Occurred())
        goto bad;
#endif
    if (!strict && (size_t)basicsize > size) {
        PyOS_snprintf(warning, sizeof(warning),
            "%s.%s size changed, may indicate binary incompatibility. Expected %zd, got %zd",
            module_name, class_name, basicsize, size);
        if (PyErr_WarnEx(NULL, warning, 0) < 0) goto bad;
    }
    else if ((size_t)basicsize != size) {
        PyErr_Format(PyExc_ValueError,
            "%.200s.%.200s has the wrong size, try recompiling. Expected %zd, got %zd",
            module_name, class_name, basicsize, size);
        goto bad;
    }
    return (PyTypeObject *)result;
bad:
    Py_XDECREF(py_module);
    Py_XDECREF(result);
    return NULL;
}
#endif

/* FunctionImport */
          #ifndef __PYX_HAVE_RT_ImportFunction
#define __PYX_HAVE_RT_ImportFunction
static int __Pyx_ImportFunction(PyObject *module, const char *funcname, void (**f)(void), const char *sig) {
    PyObject *d = 0;
    PyObject *cobj = 0;
    union {
        void (*fp)(void);
        void *p;
    } tmp;
    d = PyObject_GetAttrString(module, (char *)"__pyx_capi__");
    if (!d)
        goto bad;
    cobj = PyDict_GetItemString(d, funcname);
    if (!cobj) {
        PyErr_Format(PyExc_ImportError,
            "%.200s does not export expected C function %.200s",
                PyModule_GetName(module), funcname);
        goto bad;
    }
#if PY_VERSION_HEX >= 0x02070000
    if (!PyCapsule_IsValid(cobj, sig)) {
        PyErr_Format(PyExc_TypeError,
            "C function %.200s.%.200s has wrong signature (expected %.500s, got %.500s)",
             PyModule_GetName(module), funcname, sig, PyCapsule_GetName(cobj));
        goto bad;
    }
    tmp.p = PyCapsule_GetPointer(cobj, sig);
#else
    {const char *desc, *s1, *s2;
    desc = (const char *)PyCObject_GetDesc(cobj);
    if (!desc)
        goto bad;
    s1 = desc; s2 = sig;
    while (*s1 != '\0' && *s1 == *s2) { s1++; s2++; }
    if (*s1 != *s2) {
        PyErr_Format(PyExc_TypeError,
            "C function %.200s.%.200s has wrong signature (expected %.500s, got %.500s)",
             PyModule_GetName(module), funcname, sig, desc);
        goto bad;
    }
    tmp.p = PyCObject_AsVoidPtr(cobj);}
#endif
    *f = tmp.fp;
    if (!(*f))
        goto bad;
    Py_DECREF(d);
    return 0;
bad:
    Py_XDECREF(d);
    return -1;
}
#endif

/* InitStrings */
          static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else
        if (t->is_unicode | t->is_str) {
            if (t->intern) {
                *t->p = PyUnicode_InternFromString(t->s);
            } else if (t->encoding) {
                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
            } else {
                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
            }
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

static CYTHON_INLINE PyObject* __Pyx_PyUnicode_FromString(const char* c_str) {
    return __Pyx_PyUnicode_FromStringAndSize(c_str, (Py_ssize_t)strlen(c_str));
}
static CYTHON_INLINE char* __Pyx_PyObject_AsString(PyObject* o) {
    Py_ssize_t ignore;
    return __Pyx_PyObject_AsStringAndSize(o, &ignore);
}
static CYTHON_INLINE char* __Pyx_PyObject_AsStringAndSize(PyObject* o, Py_ssize_t *length) {
#if CYTHON_COMPILING_IN_CPYTHON && (__PYX_DEFAULT_STRING_ENCODING_IS_ASCII || __PYX_DEFAULT_STRING_ENCODING_IS_DEFAULT)
    if (
#if PY_MAJOR_VERSION < 3 && __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
            __Pyx_sys_getdefaultencoding_not_ascii &&
#endif
            PyUnicode_Check(o)) {
#if PY_VERSION_HEX < 0x03030000
        char* defenc_c;
        PyObject* defenc = _PyUnicode_AsDefaultEncodedString(o, NULL);
        if (!defenc) return NULL;
        defenc_c = PyBytes_AS_STRING(defenc);
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
        {
            char* end = defenc_c + PyBytes_GET_SIZE(defenc);
            char* c;
            for (c = defenc_c; c < end; c++) {
                if ((unsigned char) (*c) >= 128) {
                    PyUnicode_AsASCIIString(o);
                    return NULL;
                }
            }
        }
#endif
        *length = PyBytes_GET_SIZE(defenc);
        return defenc_c;
#else
        if (__Pyx_PyUnicode_READY(o) == -1) return NULL;
#if __PYX_DEFAULT_STRING_ENCODING_IS_ASCII
        if (PyUnicode_IS_ASCII(o)) {
            *length = PyUnicode_GET_LENGTH(o);
            return PyUnicode_AsUTF8(o);
        } else {
            PyUnicode_AsASCIIString(o);
            return NULL;
        }
#else
        return PyUnicode_AsUTF8AndSize(o, length);
#endif
#endif
    } else
#endif
#if (!CYTHON_COMPILING_IN_PYPY) || (defined(PyByteArray_AS_STRING) && defined(PyByteArray_GET_SIZE))
    if (PyByteArray_Check(o)) {
        *length = PyByteArray_GET_SIZE(o);
        return PyByteArray_AS_STRING(o);
    } else
#endif
    {
        char* result;
        int r = PyBytes_AsStringAndSize(o, &result, length);
        if (unlikely(r < 0)) {
            return NULL;
        } else {
            return result;
        }
    }
}
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   int is_true = x == Py_True;
   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
   else return PyObject_IsTrue(x);
}
static CYTHON_INLINE PyObject* __Pyx_PyNumber_IntOrLong(PyObject* x) {
  PyNumberMethods *m;
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_MAJOR_VERSION < 3
  if (PyInt_Check(x) || PyLong_Check(x))
#else
  if (PyLong_Check(x))
#endif
    return __Pyx_NewRef(x);
  m = Py_TYPE(x)->tp_as_number;
#if PY_MAJOR_VERSION < 3
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = PyNumber_Long(x);
  }
#else
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Long(x);
  }
#endif
  if (res) {
#if PY_MAJOR_VERSION < 3
    if (!PyInt_Check(res) && !PyLong_Check(res)) {
#else
    if (!PyLong_Check(res)) {
#endif
      PyErr_Format(PyExc_TypeError,
                   "__%.4s__ returned non-%.4s (type %.200s)",
                   name, name, Py_TYPE(res)->tp_name);
      Py_DECREF(res);
      return NULL;
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}
static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject *x;
#if PY_MAJOR_VERSION < 3
  if (likely(PyInt_CheckExact(b))) {
    if (sizeof(Py_ssize_t) >= sizeof(long))
        return PyInt_AS_LONG(b);
    else
        return PyInt_AsSsize_t(x);
  }
#endif
  if (likely(PyLong_CheckExact(b))) {
    #if CYTHON_USE_PYLONG_INTERNALS
    const digit* digits = ((PyLongObject*)b)->ob_digit;
    const Py_ssize_t size = Py_SIZE(b);
    if (likely(__Pyx_sst_abs(size) <= 1)) {
        ival = likely(size) ? digits[0] : 0;
        if (size == -1) ival = -ival;
        return ival;
    } else {
      switch (size) {
         case 2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -2:
           if (8 * sizeof(Py_ssize_t) > 2 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -3:
           if (8 * sizeof(Py_ssize_t) > 3 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case 4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return (Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
         case -4:
           if (8 * sizeof(Py_ssize_t) > 4 * PyLong_SHIFT) {
             return -(Py_ssize_t) (((((((((size_t)digits[3]) << PyLong_SHIFT) | (size_t)digits[2]) << PyLong_SHIFT) | (size_t)digits[1]) << PyLong_SHIFT) | (size_t)digits[0]));
           }
           break;
      }
    }
    #endif
    return PyLong_AsSsize_t(b);
  }
  x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
    return PyInt_FromSize_t(ival);
}


#endif /* Py_PYTHON_H */
